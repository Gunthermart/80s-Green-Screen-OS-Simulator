<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aquarium Rétro 3D - Simulation de Vie Artificielle</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Explorez un aquarium 3D interactif de style terminal rétro des années 80. Observez des bancs de poissons colorés, gérez l'écosystème et introduisez des prédateurs dans cette simulation de vie artificielle.">
    <meta name="keywords" content="simulation 3d, aquarium, boids, vie artificielle, three.js, webgl, retro, terminal, poisson, prédateur, cichla, erpetoichthys, sous-marin, interactif">
    <meta name="author" content="Simulation Interactive">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://leonce-equity.com/aquarium/">
    <meta property="og:title" content="Aquarium Rétro 3D - Simulation de Vie Artificielle">
    <meta property="og:description" content="Plongez dans un écosystème numérique et contrôlez la vie de poissons virtuels dans un style wireframe unique.">
    <meta property="og:image" content="https://leonce-equity.com/aquarium/aquarium.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://leonce-equity.com/aquarium/">
    <meta property="twitter:title" content="Aquarium Rétro 3D - Simulation de Vie Artificielle">
    <meta property="twitter:description" content="Plongez dans un écosystème numérique et contrôlez la vie de poissons virtuels dans un style wireframe unique.">
    <meta property="twitter:image" content="https://leonce-equity.com/aquarium/aquarium.png">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(0, 40, 60, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(0, 60, 40, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at center, #0a0a0a 0%, #000000 100%);
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            text-align: center;
            position: relative;
        }
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000"><defs><filter id="noise"><feTurbulence type="turbulence" baseFrequency="0.9" numOctaves="1" seed="2"/><feColorMatrix values="0 0 0 0 0 0 0 0 0 0.2 0 0 0 0 0 0 0 0 0.03 0"/></filter></defs><rect width="100%" height="100%" filter="url(%23noise)"/></svg>');
            opacity: 0.6;
            pointer-events: none;
            z-index: -1;
        }
        #info {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 92%;
            padding: 20px;
            box-sizing: border-box;
            z-index: 100;
            display: block;
            text-shadow: 
                0 0 8px #00ff41, 
                0 0 16px #00ff41, 
                0 0 24px rgba(0, 255, 65, 0.6);
            pointer-events: none;
            background: linear-gradient(135deg, rgba(0, 20, 15, 0.85) 0%, rgba(0, 10, 8, 0.85) 100%);
            border: 2px solid rgba(0, 255, 65, 0.6);
            border-radius: 8px;
            backdrop-filter: blur(10px);
            box-shadow: 
                0 0 30px rgba(0, 255, 65, 0.3),
                inset 0 1px 0 rgba(0, 255, 65, 0.1);
        }
        canvas {
            display: block;
        }
        #exit-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 104;
            cursor: pointer;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff41;
            color: #00ff41;
        }
        #exit-btn:hover {
            color: #ff4141;
        }
        #main-controls-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 101;
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 200px;
            background: rgba(0, 15, 8, 0.85);
            border: 1px solid #00ff41;
            border-radius: 4px;
            padding: 8px;
            backdrop-filter: blur(5px);
        }
        .control-group-header {
            background: rgba(0, 255, 65, 0.1);
            color: #00ff41;
            padding: 8px 10px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 2px;
            transition: background 0.3s;
        }
        .control-group-header:hover {
            background: rgba(0, 255, 65, 0.2);
        }
        .control-group-header .caret {
            transition: transform 0.3s ease;
        }
        .control-group.active .control-group-header .caret {
            transform: rotate(90deg);
        }
        .control-group-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
            padding-left: 10px;
        }
        .settings-btn {
            cursor: pointer;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 8px 10px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            text-shadow: 0 0 5px #00ff41;
            transition: all 0.3s ease;
            width: 100%;
            text-align: left;
            border-radius: 2px;
            box-shadow: 0 0 0 rgba(0, 255, 65, 0);
            margin-top: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative; /* For tooltip */
        }
        .settings-btn:hover {
            background: rgba(0, 255, 65, 0.15);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.6);
            transform: translateY(-1px);
        }
        .btn-icon {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        /* Tooltip */
        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 105%;
            top: 50%;
            transform: translateY(-50%);
            background: #000;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            white-space: nowrap;
            z-index: 1000;
        }
        .settings-btn:disabled {
            cursor: not-allowed;
            background: rgba(50, 50, 50, 0.5);
            color: #555;
            text-shadow: none;
            border-color: #555;
        }
        #feed-btn {
            border-color: #ffff00;
            color: #ffff00;
            text-shadow: 0 0 8px #ffff00;
        }
        .settings-panel {
            position: absolute;
            width: 380px;
            background: linear-gradient(145deg, rgba(0, 20, 0, 0.95), rgba(0, 10, 0, 0.95));
            border: 2px solid #00ff41;
            box-shadow: 0 0 25px rgba(0, 255, 65, 0.4), inset 0 0 20px rgba(0, 255, 65, 0.05);
            z-index: 102;
            border-radius: 4px;
            backdrop-filter: blur(10px);
        }
        .settings-panel.hidden {
            display: none;
        }
        .panel-header {
            color: #00ff41;
            padding: 8px 10px;
            cursor: move;
            font-weight: bold;
            border-bottom: 1px solid #00ff41;
            text-shadow: 0 0 5px #00ff41;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-header .close-btn {
            cursor: pointer;
            font-weight: bold;
        }
        .panel-header .close-btn:hover {
            color: #ff4141;
        }
        .panel-content {
            padding: 15px;
            max-height: 60vh;
            overflow-y: auto;
        }
        .panel-content fieldset {
            border: 1px dashed #00ff41;
            padding: 10px;
            margin: 0;
            margin-bottom: 10px;
        }
        .panel-content fieldset:disabled {
            opacity: 0.5;
            border-color: #555;
        }
        .panel-content label {
            display: block;
            margin-bottom: 5px;
            margin-top: 10px;
        }
        #stats-panel-content p {
            margin: 4px 0;
            text-align: left;
        }
        #welcome-lang-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            padding: 8px;
            background: rgba(0, 255, 65, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 65, 0.2);
        }
        .lang-btn {
            flex-grow: 1;
            font-size: 0.85em;
            padding: 8px 12px;
            background: rgba(0, 30, 20, 0.8);
            border: 2px solid #00ff41;
            color: #00ff41;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .lang-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.2), transparent);
            transition: left 0.4s;
        }
        .lang-btn:hover::before {
            left: 100%;
        }
        .lang-btn:hover:not(.active) {
            background: rgba(0, 255, 65, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 65, 0.3);
        }
        .lang-btn.active {
            background: linear-gradient(145deg, #00ff41, #00cc33);
            color: #000;
            text-shadow: none;
            box-shadow: 
                0 0 15px rgba(0, 255, 65, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }
        /* Style de base des curseurs */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: #00ff41;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: 1px solid #00ff41;
            height: 16px;
            width: 16px;
            background: #00ff41;
            cursor: pointer;
            margin-top: -7px;
        }
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: #00ff41;
        }
        input[type=range]::-moz-range-thumb {
            border: 1px solid #00ff41;
            height: 16px;
            width: 16px;
            background: #00ff41;
            cursor: pointer;
        }

        /* Responsive Design for Mobile */
        @media (max-width: 768px) {
            #info {
                padding: 10px;
                font-size: 0.9em;
            }
            #info h1 {
                font-size: 1.3em;
                margin: 0 0 8px 0;
            }
            #info p {
                margin: 0 0 5px 0;
            }
            #stats {
                font-size: 0.75em !important;
            }
            #main-controls-container {
                top: auto;
                bottom: 15px;
                left: 15px;
                flex-direction: column;
                width: calc(100vw - 30px);
                max-width: 300px;
                gap: 5px;
            }
            .settings-btn {
                font-size: 0.8em;
                padding: 8px 10px;
            }
            .settings-panel {
                width: 95vw;
                max-width: 400px;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%);
                max-height: 80vh;
                overflow-y: auto;
            }
            .panel-content {
                padding: 10px;
            }
            .panel-content label {
                font-size: 0.85em;
            }
             .modal-footer {
                flex-direction: column;
                align-items: stretch;
            }
            #welcome-lang-selector {
                order: 1;
            }
            .start-btn {
                order: 2;
            }
            .checkbox-container {
                order: 3;
                justify-content: center;
            }
        }

        /* Accessibility improvements */
        .settings-btn:focus,
        .settings-panel:focus-within {
            outline: 2px solid #00ff41;
            outline-offset: 2px;
        }
        
        input[type=range]:focus {
            outline: 2px solid #00ff41;
            outline-offset: 2px;
        }
        
        /* Amélioration du contraste pour l'accessibilité */
        .panel-content fieldset legend {
            color: #00ff41;
            font-weight: bold;
        }

        /* Welcome Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(0, 30, 40, 0.98) 0%, rgba(0, 0, 0, 0.98) 100%);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
            animation: overlayFadeIn 1s ease-out;
        }
        .modal-overlay.hidden {
            display: none;
        }
        .modal-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="turbulence"><feTurbulence type="turbulence" baseFrequency="0.02" numOctaves="3" result="noise"/><feDisplacementMap in="SourceGraphic" in2="noise" scale="2"/></filter></defs><rect width="100" height="100" fill="rgba(0,255,65,0.02)" filter="url(%23turbulence)"/></svg>') repeat;
            opacity: 0.3;
            animation: waterFlow 20s linear infinite;
        }
        @keyframes overlayFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes waterFlow {
            0% { transform: translateX(0) translateY(0); }
            25% { transform: translateX(-20px) translateY(-10px); }
            50% { transform: translateX(-40px) translateY(20px); }
            75% { transform: translateX(-20px) translateY(30px); }
            100% { transform: translateX(0) translateY(0); }
        }
        .modal-content {
            background: linear-gradient(145deg, rgba(0, 25, 15, 0.96), rgba(0, 15, 10, 0.96));
            border: 3px solid #00ff41;
            border-radius: 12px;
            padding: 0;
            max-width: 650px;
            width: 92%;
            max-height: 92vh;
            overflow-y: auto;
            box-shadow: 
                0 0 60px rgba(0, 255, 65, 0.7), 
                inset 0 0 40px rgba(0, 255, 65, 0.12),
                0 20px 40px rgba(0, 0, 0, 0.6);
            animation: modalSlideIn 1s ease-out;
            position: relative;
        }
        .modal-content::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ff41, #00cc33, #00ff41, #00aa22);
            border-radius: 12px;
            z-index: -1;
            animation: borderGlow 3s ease-in-out infinite alternate;
        }
        @keyframes modalSlideIn {
            from { 
                transform: translateY(-80px) scale(0.9); 
                opacity: 0; 
                filter: blur(5px);
            }
            to { 
                transform: translateY(0) scale(1); 
                opacity: 1; 
                filter: blur(0);
            }
        }
        @keyframes borderGlow {
            0% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        .modal-header {
            padding: 25px 30px 20px;
            border-bottom: 2px solid #00ff41;
            position: relative;
            background: linear-gradient(90deg, rgba(0, 255, 65, 0.08) 0%, rgba(0, 255, 65, 0.03) 100%);
        }
        .modal-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, #00ff41, transparent);
            animation: scanLine 2s ease-in-out infinite;
        }
        @keyframes scanLine {
            0%, 100% { opacity: 0.3; transform: translateX(-100%); }
            50% { opacity: 1; transform: translateX(100%); }
        }
        .modal-header h2 {
            color: #00ff41;
            margin: 0;
            font-size: 1.6em;
            text-shadow: 
                0 0 10px #00ff41,
                0 0 20px #00ff41,
                0 0 30px rgba(0, 255, 65, 0.5);
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            letter-spacing: 2px;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        @keyframes titleGlow {
            0% { text-shadow: 0 0 10px #00ff41, 0 0 20px #00ff41, 0 0 30px rgba(0, 255, 65, 0.5); }
            100% { text-shadow: 0 0 15px #00ff41, 0 0 25px #00ff41, 0 0 35px rgba(0, 255, 65, 0.8); }
        }
        .typing-indicator {
            color: #00ff41;
            animation: blink 1.2s infinite;
            font-size: 1.4em;
            position: absolute;
            right: 30px;
            top: 28px;
            text-shadow: 0 0 8px #00ff41;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        .modal-body {
            padding: 25px 30px;
            position: relative;
        }
        .modal-body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><circle cx="50" cy="50" r="2" fill="rgba(0,255,65,0.1)"><animate attributeName="cy" values="50;150;50" dur="8s" repeatCount="indefinite"/></circle><circle cx="150" cy="100" r="1.5" fill="rgba(0,255,65,0.08)"><animate attributeName="cy" values="100;50;100" dur="6s" repeatCount="indefinite"/></circle><circle cx="100" cy="150" r="1" fill="rgba(0,255,65,0.06)"><animate attributeName="cy" values="150;25;150" dur="10s" repeatCount="indefinite"/></circle></svg>') repeat;
            opacity: 0.4;
            pointer-events: none;
        }
        .terminal-text {
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.7;
            position: relative;
            z-index: 1;
        }
        .terminal-text p {
            margin: 12px 0;
            animation: typeIn 0.8s ease-out;
            text-shadow: 0 0 5px rgba(0, 255, 65, 0.3);
        }
        .terminal-text p:first-child {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 18px;
        }
        @keyframes typeIn {
            from { 
                opacity: 0; 
                transform: translateX(-15px); 
                filter: blur(2px);
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
                filter: blur(0);
            }
        }
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 18px;
            margin: 25px 0;
            padding: 20px;
            border: 2px dashed #00ff41;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.08) 0%, rgba(0, 255, 65, 0.03) 100%);
            position: relative;
            overflow: hidden;
        }
        .features-grid::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 255, 65, 0.03) 0%, transparent 70%);
            animation: rotateGlow 10s linear infinite;
        }
        @keyframes rotateGlow {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .feature-item {
            display: flex;
            align-items: center;
            gap: 12px;
            animation: fadeInUp 0.8s ease-out;
            position: relative;
            z-index: 1;
            padding: 8px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        .feature-item:hover {
            background: rgba(0, 255, 65, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 65, 0.2);
        }
        @keyframes fadeInUp {
            from { 
                opacity: 0; 
                transform: translateY(30px); 
                filter: blur(3px);
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
                filter: blur(0);
            }
        }
        .feature-icon {
            font-size: 1.4em;
            filter: hue-rotate(120deg) drop-shadow(0 0 5px rgba(0, 255, 65, 0.6));
            animation: iconFloat 3s ease-in-out infinite;
        }
        @keyframes iconFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        .quick-tips {
            margin-top: 25px;
            padding: 20px;
            border: 2px solid #00ff41;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.1) 0%, rgba(0, 255, 65, 0.05) 100%);
            position: relative;
            overflow: hidden;
        }
        .quick-tips::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        .quick-tips h3 {
            color: #00ff41;
            margin: 0 0 15px 0;
            font-size: 1.2em;
            text-shadow: 
                0 0 8px #00ff41,
                0 0 16px rgba(0, 255, 65, 0.5);
            position: relative;
            z-index: 1;
            font-weight: bold;
        }
        .quick-tips ul {
            margin: 0;
            padding-left: 0;
            list-style: none;
            position: relative;
            z-index: 1;
        }
        .quick-tips li {
            margin: 10px 0;
            animation: slideInLeft 0.6s ease-out;
            padding: 5px 0;
            border-left: 3px solid transparent;
            padding-left: 10px;
            transition: all 0.3s ease;
        }
        .quick-tips li:hover {
            border-left-color: #00ff41;
            padding-left: 15px;
            background: rgba(0, 255, 65, 0.05);
            border-radius: 4px;
        }
        @keyframes slideInLeft {
            from { 
                opacity: 0; 
                transform: translateX(-30px); 
                filter: blur(2px);
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
                filter: blur(0);
            }
        }
        .modal-footer {
            padding: 20px 30px 25px;
            border-top: 2px solid #00ff41;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 18px;
            background: linear-gradient(90deg, rgba(0, 255, 65, 0.05) 0%, rgba(0, 255, 65, 0.02) 100%);
            position: relative;
        }
        .modal-footer::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, #00ff41, rgba(0, 255, 65, 0.3), #00ff41);
        }
        .start-btn {
            background: linear-gradient(145deg, #00ff41, #00cc33);
            border: 2px solid #00ff41;
            color: #000;
            padding: 15px 30px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.4s ease;
            text-shadow: none;
            box-shadow: 
                0 0 20px rgba(0, 255, 65, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        .start-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s;
        }
        .start-btn:hover::before {
            left: 100%;
        }
        .start-btn:hover {
            background: linear-gradient(145deg, #00cc33, #009925);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 8px 25px rgba(0, 255, 65, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border-color: #00cc33;
        }
        .start-btn:active {
            transform: translateY(-1px) scale(1);
            box-shadow: 0 3px 12px rgba(0, 255, 65, 0.6);
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 8px;
            border-radius: 4px;
        }
        .checkbox-container:hover {
            background: rgba(0, 255, 65, 0.05);
            text-shadow: 0 0 8px rgba(0, 255, 65, 0.6);
        }
        .checkbox-container input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #00ff41;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .checkbox-container input[type="checkbox"]:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 0 5px rgba(0, 255, 65, 0.8));
        }
        
        /* Scrollbar Styles */
        .panel-content::-webkit-scrollbar {
            width: 8px;
        }
        .panel-content::-webkit-scrollbar-track {
            background: rgba(10, 10, 10, 0.8);
            border-radius: 10px;
        }
        .panel-content::-webkit-scrollbar-thumb {
            background-color: #ffff00;
            border-radius: 10px;
            border: 1px solid #00ff41;
        }
        .panel-content::-webkit-scrollbar-thumb:hover {
            background-color: #ff0;
        }
        
        #auto-mode-timer {
            color: #ff69b4;
            text-shadow: 0 0 8px #ff69b4, 0 0 16px #ff69b4;
        }

        #exjv-modal .modal-content {
            width: 500px;
            height: 200px;
            padding: 0;
            overflow: hidden;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.5), inset 0 0 20px rgba(0, 255, 65, 0.3);
        }
        #exjv-modal .modal-content::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        #exjv-modal .modal-content::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(transparent 0%, rgba(0, 255, 65, 0.1) 50%, transparent 100%);
            opacity: .1;
            z-index: 2;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker {
            0% { opacity: 0.1; }
            20% { opacity: 1; }
            40% { opacity: 0.1; }
            60% { opacity: 1; }
            80% { opacity: 0.1; }
            100% { opacity: 1; }
        }
        #chase-canvas {
            width: 100%;
            height: calc(100% - 38px);
            display: block;
        }
    </style>
</head>
<body>
    <!-- Welcome Modal -->
    <div id="welcome-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 data-lang-key="welcome_title">BIENVENUE DANS AQUARIUM_TERMINAL.EXE</h2>
                <div class="typing-indicator">_</div>
            </div>
            <div class="modal-body">
                <div class="terminal-text">
                    <p data-lang-key="welcome_intro">>>> INITIALISATION DE LA SIMULATION DE VIE ARTIFICIELLE...</p>
                    <p data-lang-key="welcome_description">Cette simulation interactive présente un écosystème aquatique 3D dynamique. Observez les poissons naître, grandir, se reproduire et mourir, tout en gérant les paramètres de leur environnement.</p>
                    
                    <div class="features-grid">
                        <div class="feature-item">
                            <span class="feature-icon">🌿</span>
                            <span data-lang-key="feature_lifecycle">Cycle de vie complet</span>
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">🎯</span>
                            <span data-lang-key="feature_predation">Système de prédation</span>
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">⚙️</span>
                            <span data-lang-key="feature_controls">Contrôles avancés</span>
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">🌐</span>
                            <span data-lang-key="feature_multilingual">Interface multilingue</span>
                        </div>
                    </div>

                    <div class="quick-tips">
                        <h3 data-lang-key="quick_tips_title">>>> GUIDE RAPIDE:</h3>
                        <ul>
                            <li data-lang-key="tip_explore">• Faites glisser pour explorer l'aquarium 3D</li>
                            <li data-lang-key="tip_fertility">• Ajustez la 'Fécondité' pour contrôler la population</li>
                            <li data-lang-key="tip_predator">• Libérez l'Erpetoichthys pour observer le chaos</li>
                            <li data-lang-key="tip_submarine">• Changez de vue avec la caméra du sous-marin</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <div id="welcome-lang-selector">
                    <button class="lang-btn active" data-lang="en">EN</button>
                    <button class="lang-btn" data-lang="fr">FR</button>
                    <button class="lang-btn" data-lang="es">ES</button>
                    <button class="lang-btn" data-lang="de">DE</button>
                    <button class="lang-btn" data-lang="zh">ZH</button>
                </div>
                <button id="start-simulation-btn" class="start-btn" data-lang-key="start_simulation">DÉMARRER LA SIMULATION</button>
                <label class="checkbox-container">
                    <input type="checkbox" id="dont-show-again">
                    <span data-lang-key="dont_show_again">Ne plus afficher</span>
                </label>
            </div>
        </div>
    </div>

    <div id="info">
        <h1 data-lang-key="title">AQUARIUM_TERMINAL.EXE</h1>
        <p data-lang-key="subtitle">🐠 Simulation de vie artificielle • Glissez pour explorer • Cliquez sur les espèces pour configurer</p>
        <div id="stats" style="font-size: 0.9em; margin-top: 8px; opacity: 0.8;">
            <span id="fish-count-label" data-lang-key="fish_count_label">Poissons</span>: <span id="fish-count">0</span> | 
            <span id="predator-count-label" data-lang-key="predator_count_label">Prédateurs</span>: <span id="predator-count">0</span> | 
            <span id="ropefish-status-label" data-lang-key="ropefish_status_label">Erpetoichthys</span>: <span id="ropefish-status" data-lang-key="inactive">INACTIF</span> |
            <span id="auto-mode-status" style="display: none;">Mode Auto: <span id="auto-mode-status-value">INACTIF</span> | </span>
            <span id="auto-mode-timer" style="display: none;"></span>
            <span id="fps">FPS: 60</span>
        </div>
    </div>

    <div id="exit-btn" title="Retourner au répertoire parent">[X]</div>
    <div id="main-controls-container"></div>
    <div id="settings-container"></div>
    
    <div id="exjv-modal" class="modal-overlay hidden">
        <div class="modal-content">
             <div class="panel-header">
                <span>(C) EXJV</span>
                <span class="close-btn">[X]</span>
            </div>
            <canvas id="chase-canvas"></canvas>
        </div>
    </div>

    <script type="module">
        // Importation des modules nécessaires de Three.js
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls, superPredator, submarine, isSubmarineViewActive = false, isWireframeMode = true;
        let boids = [];
        let eggs = [];
        let food = [];
        const rocks = [];
        const plants = [];
        let particles = [];
        const worldSize = { width: 500, height: 250, depth: 350 };
        let aquariumBox;
        let lastFrameTime = 0;
        let highestZIndex = 102; // For panel management
        let lastHiddenTime = 0; // For background simulation
        let isAutoModeActive = false;
        let autoModeManager;
        let isImmortalMode = false;
        let chaseAnimationId;

        // --- Statistics ---
        const simulationStats = {
            preyEaten: 0,
            eggsLaid: {},
            babiesHatched: {},
            maxGeneration: {}
        };

        // --- Global Behavior Parameters ---
        const flockingForces = {
            alignment: 0.4,
            cohesion: 0.3,
            separation: 1.2
        };
        
        const environmentSettings = {
            rockCount: 15,
            plantCount: 60
        };

        // --- Fish Species Configuration ---
        const fishSpecies = {
            'cichla': {
                type: 'predator',
                count: 2, color: 0xff4444, scale: 1.4, maxSpeed: 0.7, perceptionRadius: 120,
                riskAssessment: { maxDistance: 150, maxGroupSize: 5 },
                vertices: new Float32Array([0,0,0, -18,0,0, -5,4,0, -5,-4,0, -18,0,0, -25,2,0, -25,-2,0])
            },
            'tetra': {
                type: 'prey',
                count: 50, color: 0xff69b4, scale: 0.45, maxSpeed: 0.4, perceptionRadius: 35, fearRadius: 80, fertility: 0.03,
                vertices: new Float32Array([0,0,0, -6,2.5,0, -12,0,0, 0,0,0, -12,0,0, -6,-2.5,0, -12,0,0, -16,4,0, -16,-4,0])
            },
            'guppy': {
                type: 'prey',
                count: 65, color: 0x00ddff, scale: 0.4, maxSpeed: 0.45, perceptionRadius: 40, fearRadius: 85, fertility: 0.03,
                vertices: new Float32Array([0,0,0, -5,2,0, -10,0,0, 0,0,0, -10,0,0, -5,-2,0, -10,0,0, -14,5,0, -14,-5,0])
            },
            'puffer': {
                type: 'prey',
                count: 30, color: 0xffaa00, scale: 0.5, maxSpeed: 0.3, perceptionRadius: 30, fearRadius: 70, fertility: 0.015,
                vertices: new Float32Array([3,0,0, 0,3,0, -6,0,0, 3,0,0, -6,0,0, 0,-3,0, -6,0,0, -9,0,0, -4,3,0, -6,0,0, -4,-3,0])
            },
            'angel': {
                type: 'prey',
                count: 25, color: 0xaa44ff, scale: 0.6, maxSpeed: 0.35, perceptionRadius: 35, fearRadius: 75, fertility: 0.024,
                vertices: new Float32Array([0,0,0, -5,5,0, -10,0,0, 0,0,0, -10,0,0, -5,-5,0, -10,0,0, -13,3,0, -10,0,0, -13,-3,0])
            }
        };
        
        // --- Internationalization ---
        const translations = {
            fr: {
                title: "AQUARIUM_TERMINAL.EXE",
                subtitle: "🐠 Simulation de vie artificielle • Glissez pour explorer • Cliquez sur les espèces pour configurer",
                fish_count_label: "Poissons",
                predator_count_label: "Prédateurs",
                ropefish_status_label: "Erpetoichthys",
                active: "ACTIF",
                inactive: "INACTIF",
                auto_mode: "MODE AUTOMATIQUE",
                random_mode: "MODE ALÉATOIRE",
                immortal_mode: "MODE IMMORTEL",
                exjv_credit: "(C) EXJV",
                mode_wireframe: "MODE: WIREFRAME",
                mode_solid: "MODE: PLEIN",
                view_sub: "VUE SOUS-MARIN",
                view_orbital: "VUE ORBITALE",
                release_ropefish: "LIBÉRER L'ERPETOICHTHYS",
                forces: "FORCES",
                environment: "ENVIRONNEMENT",
                statistics: "STATISTIQUES",
                help_title: "AIDE",
                help_content: `
                    <div style="text-align: left; line-height: 1.6; font-size: 0.9em;">
                        <h4 style="text-align: center; text-decoration: underline;">Aquarium Rétro 3D - Guide de Simulation</h4>
                        <p>Plongez dans un monde aquatique fascinant avec "Aquarium Rétro 3D", une simulation de vie artificielle dynamique au style "terminal" distinctif des années 80. Ce programme interactif vous offre une fenêtre sur un écosystème virtuel où vous pouvez observer, interagir et même influencer le cycle de vie de diverses espèces aquatiques.</p>
                        
                        <strong style="display: block; margin-top: 15px;">Caractéristiques Générales :</strong>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>Écosystème 3D Dynamique :</strong> Explorez un aquarium en trois dimensions, visualisé avec des graphiques en "wireframe" pour une ambiance rétro unique.</li>
                            <li><strong>Simulation de Vie Artificielle :</strong> Observez des poissons virtuels évoluer selon un cycle de vie complet : ils naissent, grandissent, se reproduisent et meurent.</li>
                            <li><strong>Interface Rétro Multilingue :</strong> L'interface imite un terminal des années 80 et supporte plusieurs langues.</li>
                        </ul>

                        <strong style="display: block; margin-top: 15px;">Interactions et Contrôles :</strong>
                        
                        <h5 style="margin-top: 10px; text-decoration: underline;">Exploration de l'Aquarium :</h5>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>Glisser la Souris :</strong> Faites pivoter la caméra pour explorer l'aquarium.</li>
                            <li><strong>Molette de la Souris :</strong> Zoomez et dézoomez.</li>
                            <li><strong>Vue Sous-Marin :</strong> Activez cette vue pour une perspective immersive.</li>
                        </ul>
                        
                        <h5 style="margin-top: 10px; text-decoration: underline;">Utilisation sur Mobile et Tablette :</h5>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>Rotation :</strong> Glissez avec un doigt sur l'écran.</li>
                            <li><strong>Zoom :</strong> Pincez avec deux doigts pour zoomer ou dézoomer.</li>
                            <li><strong>Interface :</strong> Les contrôles sont adaptés pour une utilisation tactile.</li>
                        </ul>

                        <h5 style="margin-top: 10px; text-decoration: underline;">Gestion des Espèces :</h5>
                        <p>Cliquez sur le nom d'une espèce pour ajuster ses paramètres comme le <strong>Nombre</strong>, la <strong>Taille</strong>, la <strong>Vitesse</strong>, la <strong>Perception</strong>, la <strong>Peur</strong> et la <strong>Fécondité</strong>.</p>

                        <h5 style="margin-top: 10px; text-decoration: underline;">Paramètres Globaux :</h5>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>Panneau "FORCES" :</strong> Contrôlez l'<strong>Alignement</strong>, la <strong>Cohésion</strong>, et la <strong>Séparation</strong> des bancs de poissons.</li>
                            <li><strong>Panneau "ENVIRONNEMENT" :</strong> Personnalisez le décor en ajustant le nombre de <strong>Rochers</strong> et de <strong>Plantes</strong>.</li>
                        </ul>

                        <h5 style="margin-top: 10px; text-decoration: underline;">Actions Directes :</h5>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>NOURRIR :</strong> Stimule la reproduction des proies.</li>
                            <li><strong>LIBÉRER L'ERPETOICHTHYS :</strong> Introduit un super-prédateur.</li>
                            <li><strong>MODE :</strong> Basculez entre l'affichage "wireframe" et "plein".</li>
                        </ul>

                        <h5 style="margin-top: 10px; text-decoration: underline;">Suivi et Gestion :</h5>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>STATISTIQUES :</strong> Suivez les données détaillées de l'écosystème.</li>
                            <li><strong>SAUVEGARDER / RÉINITIALISER :</strong> Gérez vos configurations.</li>
                        </ul>
                    </div>
                `,
                prey_eaten: "Proies mangées",
                eggs_laid: "Oeufs pondus",
                babies_hatched: "Bébés nés",
                taux_fecondite: "Taux Fécondité",
                count: "Nombre", scale: "Taille", max_speed: "Vitesse Max", perception_radius: "Rayon Perception", fear_radius: "Rayon Fuite", max_hunt_dist: "Distance Chasse Max", max_group_size: "Taille Groupe Max", rock_count: "Nombre Rochers", plant_count: "Nombre Plantes",
                alignment: "Alignement", cohesion: "Cohésion", separation: "Séparation",
                welcome_title: "BIENVENUE DANS AQUARIUM_TERMINAL.EXE",
                welcome_intro: ">>> INITIALISATION DE LA SIMULATION DE VIE ARTIFICIELLE...",
                welcome_description: "Cette simulation interactive présente un écosystème aquatique 3D dynamique. Observez les poissons naître, grandir, se reproduire et mourir, tout en gérant les paramètres de leur environnement.",
                feature_lifecycle: "Cycle de vie complet",
                feature_predation: "Système de prédation",
                feature_controls: "Contrôles avancés",
                feature_multilingual: "Interface multilingüe",
                quick_tips_title: ">>> GUIDE RAPIDE:",
                tip_explore: "• Faites glisser pour explorer l'aquarium 3D",
                tip_fertility: "• Ajustez la 'Fécondité' pour contrôler la population",
                tip_predator: "• Libérez l'Erpetoichthys pour observer le chaos",
                tip_submarine: "• Changez de vue avec la caméra du sous-marin",
                start_simulation: "DÉMARRER LA SIMULATION",
                dont_show_again: "Ne plus afficher",
                save: "SAUVEGARDER",
                reset: "RÉINITIALISER",
                feed: "NOURRIR",
                generation: "Génération Max"
            },
            en: {
                title: "AQUARIUM_TERMINAL.EXE",
                subtitle: "🐠 Artificial life simulation • Drag to explore • Click on species to configure",
                fish_count_label: "Fish",
                predator_count_label: "Predators",
                ropefish_status_label: "Ropefish",
                active: "ACTIVE",
                inactive: "INACTIVE",
                auto_mode: "AUTO MODE",
                random_mode: "RANDOM MODE",
                immortal_mode: "IMMORTAL MODE",
                exjv_credit: "(C) EXJV",
                mode_wireframe: "MODE: WIREFRAME",
                mode_solid: "MODE: SOLID",
                view_sub: "SUBMARINE VIEW",
                view_orbital: "ORBITAL VIEW",
                release_ropefish: "RELEASE THE ROPEFISH",
                forces: "FORCES",
                environment: "ENVIRONMENT",
                statistics: "STATISTICS",
                help_title: "HELP",
                help_content: `<p>Welcome to AQUARIUM_TERMINAL.EXE. Use the buttons to adjust parameters. Click on species names to change their behavior, including their fertility rate. Observe the complete life cycle of the fish, from egg to adult. Release the super-predator to observe chaos. Switch views with the submarine camera.</p>`,
                prey_eaten: "Prey Eaten",
                eggs_laid: "Eggs Laid",
                babies_hatched: "Babies Hatched",
                taux_fecondite: "Fertility Rate",
                count: "Count", scale: "Scale", max_speed: "Max Speed", perception_radius: "Perception Radius", fear_radius: "Fear Radius", max_hunt_dist: "Max Hunt Distance", max_group_size: "Max Group Size", rock_count: "Rock Count", plant_count: "Plant Count",
                alignment: "Alignment", cohesion: "Cohesion", separation: "Separation",
                welcome_title: "WELCOME TO AQUARIUM_TERMINAL.EXE",
                welcome_intro: ">>> INITIALIZING ARTIFICIAL LIFE SIMULATION...",
                welcome_description: "This interactive simulation features a dynamic 3D aquatic ecosystem. Watch fish be born, grow, reproduce, and die, while managing their environmental parameters.",
                feature_lifecycle: "Complete life cycle",
                feature_predation: "Predation system",
                feature_controls: "Advanced controls",
                feature_multilingual: "Multilingual interface",
                quick_tips_title: ">>> QUICK GUIDE:",
                tip_explore: "• Drag to explore the 3D aquarium",
                tip_fertility: "• Adjust 'Fertility' to control population growth",
                tip_predator: "• Release the Erpetoichthys to observe chaos",
                tip_submarine: "• Switch views with submarine camera",
                start_simulation: "START SIMULATION",
                dont_show_again: "Don't show again",
                save: "SAVE",
                reset: "RESET",
                feed: "FEED",
                generation: "Max Generation"
            },
            es: {
                title: "ACUARIO_TERMINAL.EXE",
                subtitle: "🐠 Simulación de vida artificial • Arrastra para explorar • Haz clic en las especies para configurar",
                fish_count_label: "Peces",
                predator_count_label: "Depredadores",
                ropefish_status_label: "Pez Cuerda",
                active: "ACTIVO",
                inactive: "INACTIVO",
                auto_mode: "MODO AUTOMÁTICO",
                random_mode: "MODO ALEATORIO",
                immortal_mode: "MODO INMORTAL",
                exjv_credit: "(C) EXJV",
                mode_wireframe: "MODO: ALAMBRE",
                mode_solid: "MODO: SÓLIDO",
                view_sub: "VISTA SUBMARINO",
                view_orbital: "VISTA ORBITAL",
                release_ropefish: "LIBERAR AL PEZ CUERDA",
                forces: "FUERZAS",
                environment: "ENTORNO",
                statistics: "ESTADÍSTICAS",
                help_title: "AYUDA",
                help_content: `<p>Bienvenido a ACUARIO_TERMINAL.EXE. Usa los botones para ajustar parámetros. Haz clic en los nombres de las especies para cambiar su comportamiento, incluida su tasa de fertilidad. Observa el ciclo de vida completo de los peces, desde el huevo hasta el adulto. Libera al superdepredador para observar el caos. Cambia de vista con la cámara del submarino.</p>`,
                prey_eaten: "Presas comidas",
                eggs_laid: "Huevos puestos",
                babies_hatched: "Bebés nacidos",
                taux_fecondite: "Tasa de Fertilidad",
                count: "Cantidad", scale: "Tamaño", max_speed: "Vel. Máxima", perception_radius: "Radio de Percepción", fear_radius: "Radio de Miedo", max_hunt_dist: "Dist. Caza Máx.", max_group_size: "Tamaño Grupo Máx.", rock_count: "Nº de Rocas", plant_count: "Nº de Plantas",
                alignment: "Alineación", cohesion: "Cohesión", separation: "Separación",
                welcome_title: "BIENVENIDO A ACUARIO_TERMINAL.EXE",
                welcome_intro: ">>> INICIALIZANDO SIMULACIÓN DE VIDA ARTIFICIEL...",
                welcome_description: "Esta simulación interactiva presenta un ecosistema acuático 3D dinámico. Observa a los peces nacer, crecer, reproducirse y morir, mientras gestionas los parámetros de su entorno.",
                feature_lifecycle: "Ciclo de vida completo",
                feature_predation: "Sistema de depredación",
                feature_controls: "Controles avanzados",
                feature_multilingual: "Interfaz multilingüe",
                quick_tips_title: ">>> GUÍA RÁPIDA:",
                tip_explore: "• Arrastra para explorar el acuario 3D",
                tip_fertility: "• Ajusta la 'Fertilidad' para controlar la población",
                tip_predator: "• Libera al Pez Cuerda para observar el caos",
                tip_submarine: "• Cambia de vista con la cámara del submarino",
                start_simulation: "INICIAR SIMULACIÓN",
                dont_show_again: "No mostrar de nuevo",
                save: "GUARDAR",
                reset: "REINICIAR",
                feed: "ALIMENTAR",
                generation: "Generación Máx"
            },
            de: {
                title: "AQUARIUM_TERMINAL.EXE",
                subtitle: "🐠 Simulation künstlichen Lebens • Ziehen zum Erkunden • Auf Arten klicken zum Konfigurieren",
                fish_count_label: "Fische",
                predator_count_label: "Raubtiere",
                ropefish_status_label: "Flösselaal",
                active: "AKTIV",
                inactive: "INAKTIV",
                auto_mode: "AUTO-MODUS",
                random_mode: "ZUFALLSMODUS",
                immortal_mode: "UNSTERBLICHER MODUS",
                exjv_credit: "(C) EXJV",
                mode_wireframe: "MODUS: DRAHTGITTER",
                mode_solid: "MODUS: VOLL",
                view_sub: "U-BOOT-ANSICHT",
                view_orbital: "ORBITALANSICHT",
                release_ropefish: "FLÖSSELAAL FREILASSEN",
                forces: "KRÄFTE",
                environment: "UMGEBUNG",
                statistics: "STATISTIKEN",
                help_title: "HILFE",
                help_content: `<p>Willkommen bei AQUARIUM_TERMINAL.EXE. Verwenden Sie die Schaltflächen, um Parameter anzupassen. Klicken Sie auf die Artnamen, um ihr Verhalten zu ändern, einschließlich ihrer Fruchtbarkeitsrate. Beobachten Sie den gesamten Lebenszyklus der Fische, vom Ei bis zum Erwachsenen. Lassen Sie den Super-Raubfisch frei, um Chaos zu beobachten. Wechseln Sie die Ansicht mit der U-Boot-Kamera.</p>`,
                prey_eaten: "Beute gefressen",
                eggs_laid: "Eier gelegt",
                babies_hatched: "Babys geschlüpft",
                taux_fecondite: "Fruchtbarkeitsrate",
                count: "Anzahl", scale: "Größe", max_speed: "Max. Geschw.", perception_radius: "Wahrnehmungsradius", fear_radius: "Fluchtradius", max_hunt_dist: "Max. Jagddistanz", max_group_size: "Max. Gruppengröße", rock_count: "Anz. Felsen", plant_count: "Anz. Pflanzen",
                alignment: "Ausrichtung", cohesion: "Zusammenhalt", separation: "Trennung",
                welcome_title: "WILLKOMMEN BEI AQUARIUM_TERMINAL.EXE",
                welcome_intro: ">>> INITIALISIERE SIMULATION KÜNSTLICHEN LEBENS...",
                welcome_description: "Diese interaktive Simulation zeigt ein dynamisches 3D-Wasserökosystem. Beobachten Sie, wie Fische geboren werden, wachsen, sich vermehren und sterben, während Sie ihre Umgebungsparameter verwalten.",
                feature_lifecycle: "Vollständiger Lebenszyklus",
                feature_predation: "Raubtiersystem",
                feature_controls: "Erweiterte Steuerung",
                feature_multilingual: "Mehrsprachige Oberfläche",
                quick_tips_title: ">>> KURZANLEITUNG:",
                tip_explore: "• Ziehen, um das 3D-Aquarium zu erkunden",
                tip_fertility: "• Passen Sie die 'Fruchtbarkeit' an, um die Population zu steuern",
                tip_predator: "• Lassen Sie den Flösselaal frei, um Chaos zu beobachten",
                tip_submarine: "• Wechseln Sie die Ansicht mit der U-Boot-Kamera",
                start_simulation: "SIMULATION STARTEN",
                dont_show_again: "Nicht erneut anzeigen",
                save: "SPEICHERN",
                reset: "ZURÜCKSETZEN",
                feed: "FÜTTERN",
                generation: "Max. Generation"
            },
            zh: {
                title: "水族馆终端.EXE",
                subtitle: "🐠 人工生命模拟 • 拖动探索 • 点击物种进行配置",
                fish_count_label: "鱼类",
                predator_count_label: "捕食者",
                ropefish_status_label: "多鳍鱼",
                active: "活动",
                inactive: "不活动",
                auto_mode: "自动模式",
                random_mode: "随机模式",
                immortal_mode: "不朽模式",
                exjv_credit: "(C) EXJV",
                mode_wireframe: "模式：线框",
                mode_solid: "模式：实体",
                view_sub: "潜艇视角",
                view_orbital: "轨道视角",
                release_ropefish: "释放多鳍鱼",
                forces: "力",
                environment: "环境",
                statistics: "统计",
                help_title: "帮助",
                help_content: `<p>欢迎来到 水族馆终端.EXE。使用按钮调整参数。点击物种名称以改变它们的行为，包括它们的繁殖率。观察鱼从卵到成鱼的完整生命周期。释放超级捕食者来观察混乱。使用潜艇摄像头切换视角。</p>`,
                prey_eaten: "被捕食",
                eggs_laid: "产卵数",
                babies_hatched: "孵化数",
                taux_fecondite: "繁殖率",
                count: "数量", scale: "大小", max_speed: "最大速度", perception_radius: "感知半径", fear_radius: "恐惧半径", max_hunt_dist: "最大追捕距离", max_group_size: "最大群体规模", rock_count: "岩石数量", plant_count: "植物数量",
                alignment: "队列", cohesion: "聚集", separation: "分离",
                welcome_title: "欢迎来到 水族馆终端.EXE",
                welcome_intro: ">>> 正在初始化人工生命模拟...",
                welcome_description: "这个互动模拟展示了一个动态的3D水生生态系统。观察鱼类的出生、成长、繁殖和死亡，同时管理它们的环境参数。",
                feature_lifecycle: "完整的生命周期",
                feature_predation: "捕食系统",
                feature_controls: "高级控制",
                feature_multilingual: "多语言界面",
                quick_tips_title: ">>> 快速指南：",
                tip_explore: "• 拖动探索3D水族馆",
                tip_fertility: "• 调整“繁殖率”以控制种群",
                tip_predator: "• 释放多鳍鱼观察混乱",
                tip_submarine: "• 使用潜艇摄像头切换视角",
                start_simulation: "开始模拟",
                dont_show_again: "不再显示",
                save: "保存",
                reset: "重置",
                feed: "喂食",
                generation: "最大代数"
            }
        };

        // Check if modal should be shown
        function shouldShowModal() {
            try {
                return !localStorage.getItem('aquarium-welcome-dismissed');
            } catch (e) {
                console.warn("localStorage is not available. Welcome modal will always show.");
                return true;
            }
        }

        // Modal functionality
        function initModal() {
            const modal = document.getElementById('welcome-modal');
            const startBtn = document.getElementById('start-simulation-btn');
            const dontShowCheckbox = document.getElementById('dont-show-again');
            const welcomeLangSelector = document.getElementById('welcome-lang-selector');

            if (!shouldShowModal()) {
                modal.classList.add('hidden');
                return;
            }

            welcomeLangSelector.addEventListener('click', (e) => {
                if(e.target.tagName === 'BUTTON') {
                    setLanguage(e.target.dataset.lang);
                }
            });

            startBtn.addEventListener('click', () => {
                try {
                    if (dontShowCheckbox.checked) {
                        localStorage.setItem('aquarium-welcome-dismissed', 'true');
                    }
                } catch (e) {
                    console.warn("Could not save preference to localStorage.");
                }
                modal.classList.add('hidden');
            });
        }

        function setLanguage(lang) {
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                if (translations[lang] && translations[lang][key]) {
                    if (key === 'help_content') {
                        el.innerHTML = translations[lang][key];
                    } else {
                        el.textContent = translations[lang][key];
                    }
                }
            });
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === lang);
            });
        }

        // --- Submarine Class ---
        class Submarine {
            constructor() {
                this.mesh = new THREE.Group();
                const material = new THREE.MeshBasicMaterial({ color: 0xcccccc, wireframe: isWireframeMode });

                const body = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 20, 8), material);
                body.rotation.z = Math.PI / 2;
                this.mesh.add(body);

                const cockpit = new THREE.Mesh(new THREE.SphereGeometry(5, 8, 6), material);
                cockpit.position.x = 5;
                this.mesh.add(cockpit);

                const tail = new THREE.Mesh(new THREE.BoxGeometry(1, 8, 8), material);
                tail.position.x = -12;
                this.mesh.add(tail);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(8, 0, 0); 
                this.mesh.add(this.camera);

                this.position = new THREE.Vector3(0, worldSize.height / 2 + 20, 0);
                this.velocity = new THREE.Vector3(0.3, 0, 0);
                this.acceleration = new THREE.Vector3();
                this.mesh.position.copy(this.position);

                this.maxSpeed = 0.4;
                this.maxForce = 0.01;
                this.target = this.getNewTarget();
            }

            getNewTarget() {
                return new THREE.Vector3(
                    (Math.random() - 0.5) * (worldSize.width - 40),
                    Math.random() * (worldSize.height - 40) + 20,
                    (Math.random() - 0.5) * (worldSize.depth - 40)
                );
            }

            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.setLength(this.maxSpeed);
                let steer = new THREE.Vector3().subVectors(desired, this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }

            update() {
                if (this.position.distanceTo(this.target) < 50) {
                    this.target = this.getNewTarget();
                }

                const seekForce = this.seek(this.target);
                this.acceleration.add(seekForce);

                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.multiplyScalar(0);

                this.checkBounds(); 

                this.mesh.position.lerp(this.position, 0.1);
                
                const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), this.velocity.clone().normalize());
                this.mesh.quaternion.slerp(targetQuaternion, 0.05);
            }

            checkBounds() {
                const margin = 20;
                if (this.position.x < -worldSize.width/2+margin || this.position.x > worldSize.width/2-margin ||
                    this.position.y < margin || this.position.y > worldSize.height-margin ||
                    this.position.z < -worldSize.depth/2+margin || this.position.z > worldSize.depth/2-margin) {
                    this.target = new THREE.Vector3(0, worldSize.height / 2, 0);
                }
            }
        }

        // --- SuperPredator Class (Erpetoichthys calabaricus) ---
        class Ropefish {
            constructor() {
                this.segmentCount = 30;
                this.segmentSpacing = 3.5;
                this.speed = 0.9;
                this.turnSpeed = 0.04;
                this.attackRadius = 10;
                this.body = new THREE.Group();
                this.segments = [];
                this.path = [];
                this.pathLength = 120;
                this.target = null;
                this.isActive = false;

                const headMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00, wireframe: isWireframeMode });
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff41, wireframe: isWireframeMode });
                const headGeometry = new THREE.SphereGeometry(4, 6, 4);
                const bodyGeometry = new THREE.SphereGeometry(2.5, 6, 4);

                const head = new THREE.Mesh(headGeometry, headMaterial);
                this.segments.push(head);
                this.body.add(head);

                for (let i = 1; i < this.segmentCount; i++) {
                    const segment = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    this.segments.push(segment);
                    this.body.add(segment);
                }
                
                this.velocity = new THREE.Vector3(Math.random() * 2 - 1, 0, Math.random() * 2 - 1);
                this.velocity.normalize().multiplyScalar(this.speed);
            }

            spawn() {
                if (this.isActive) return;
                this.isActive = true;
                const startPos = new THREE.Vector3((Math.random() - 0.5) * worldSize.width * 0.8, 15, (Math.random() - 0.5) * worldSize.depth * 0.8);
                this.segments.forEach(seg => seg.position.copy(startPos));
                this.path = Array(this.pathLength).fill(startPos);
                scene.add(this.body);
                document.getElementById('ropefish-status').setAttribute('data-lang-key', 'active');
                setLanguage(document.documentElement.lang);
            }

            update(boids) {
                if (!this.isActive) return;
                this.findTarget(boids);
                this.move();
                this.checkBounds();
            }

            findTarget(allBoids) {
                if (this.target && this.target.isEaten) this.target = null;
                if (!this.target || Math.random() < 0.01) {
                    let closestBoid = null;
                    let minDistance = Infinity;
                    const aliveBoids = allBoids.filter(b => !b.isEaten && !b.isPredator);
                    if (aliveBoids.length === 0) {
                        this.target = null;
                        return;
                    }
                    for (const boid of aliveBoids) {
                        const d = this.segments[0].position.distanceTo(boid.position);
                        if (d < minDistance) {
                            minDistance = d;
                            closestBoid = boid;
                        }
                    }
                    this.target = closestBoid;
                }
            }

            move() {
                let desiredVelocity = new THREE.Vector3();
                if (this.target) {
                    desiredVelocity.subVectors(this.target.position, this.segments[0].position);
                } else {
                    desiredVelocity.copy(this.velocity);
                    if (Math.random() < 0.05) {
                        desiredVelocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), (Math.random() - 0.5) * Math.PI / 2);
                    }
                }
                
                desiredVelocity.normalize().multiplyScalar(this.speed);
                this.velocity.lerp(desiredVelocity, this.turnSpeed);

                const newHeadPos = this.segments[0].position.clone().add(this.velocity);
                this.path.unshift(newHeadPos);
                if (this.path.length > this.pathLength) this.path.pop();

                for (let i = 0; i < this.segments.length; i++) {
                    const index = Math.floor(Math.min(i * this.segmentSpacing, this.path.length - 1));
                    const point = this.path[index];
                    if (point) this.segments[i].position.lerp(point, 0.5);
                }

                if (this.target && this.segments[0].position.distanceTo(this.target.position) < this.attackRadius) {
                    if (!isImmortalMode) {
                        createEatEffect(this.target.position, 0xFFFF00);
                        this.target.isEaten = true;
                        simulationStats.preyEaten++;
                    }
                    this.target = null;
                }
            }
            
            checkBounds() {
                const head = this.segments[0];
                const margin = 10;
                if (head.position.x < -worldSize.width/2+margin) { head.position.x = -worldSize.width/2+margin; this.velocity.x *= -1; }
                else if (head.position.x > worldSize.width/2-margin) { head.position.x = worldSize.width/2-margin; this.velocity.x *= -1; }
                if (head.position.y < margin) { head.position.y = margin; this.velocity.y *= -1; }
                else if (head.position.y > worldSize.height-margin) { head.position.y = worldSize.height-margin; this.velocity.y *= -1; }
                if (head.position.z < -worldSize.depth/2+margin) { head.position.z = -worldSize.depth/2+margin; this.velocity.z *= -1; }
                else if (head.position.z > worldSize.depth/2-margin) { head.position.z = worldSize.depth/2-margin; this.velocity.z *= -1; }
            }
        }

        // --- FoodParticle Class ---
        class FoodParticle {
            constructor(position) {
                // Food particle parameters
                this.position = position.clone();
                this.velocity = new THREE.Vector3(0, -0.1, 0); // Sinks slowly
                this.lifetime = 1000 + Math.random() * 500; // ~16-25 seconds before disappearing
                
                // Visual appearance
                const geometry = new THREE.SphereGeometry(1.2, 8, 6);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    wireframe: isWireframeMode, 
                    transparent: true, 
                    opacity: 0.9 
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
                
                // Glow effect
                const glowGeometry = new THREE.SphereGeometry(2, 8, 6);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    transparent: true, 
                    opacity: 0.3, 
                    side: THREE.BackSide 
                });
                this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
                this.mesh.add(this.glow);
            }

            update() {
                // Movement and lifetime logic
                this.position.add(this.velocity);
                this.mesh.position.copy(this.position);
                
                // Add a slight oscillating movement for a realistic effect
                this.mesh.position.x += Math.sin(Date.now() * 0.002) * 0.05;
                this.mesh.position.z += Math.cos(Date.now() * 0.002) * 0.05;
                
                // Vertical bounds check
                if (this.position.y < 1) {
                    this.position.y = 1;
                    this.velocity.y = 0; // Stop at the bottom
                }
                
                // Decrease lifetime
                this.lifetime--;
                
                // Opacity fades out towards the end of life
                if (this.lifetime < 100) {
                    const opacity = this.lifetime / 100;
                    this.mesh.material.opacity = opacity * 0.9;
                    this.glow.material.opacity = opacity * 0.3;
                }
                
                return this.lifetime <= 0;
            }
        }

        // --- Egg Class ---
        class Egg {
            constructor(species, position, color, parentGeneration = 1) {
                this.species = species;
                this.parentGeneration = parentGeneration;
                this.hatchTime = 500 + Math.random() * 200; // ~8-12 seconds
                const geometry = new THREE.SphereGeometry(1.5, 6, 4);
                const material = new THREE.MeshBasicMaterial({ color: color, wireframe: isWireframeMode, transparent: true, opacity: 0.8 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                scene.add(this.mesh);
                simulationStats.eggsLaid[this.species] = (simulationStats.eggsLaid[this.species] || 0) + 1;
            }

            update() {
                this.hatchTime--;
                if (this.hatchTime <= 0) {
                    return this.hatch();
                }
                return null;
            }

            hatch() {
                const baby = new Boid(this.species, true, this.parentGeneration); // Create one baby fish with parent's generation
                baby.position.copy(this.mesh.position);
                simulationStats.babiesHatched[this.species] = (simulationStats.babiesHatched[this.species] || 0) + 1;
                return [baby]; // Return as an array
            }
        }

        // --- Boid Class ---
        class Boid {
            constructor(species, isBaby = false, parentGeneration = 0) {
                this.species = species;
                const config = fishSpecies[species];
                this.isPredator = config.type === 'predator';
                this.maxSpeed = config.maxSpeed;
                this.maxForce = 0.05;
                this.perceptionRadius = config.perceptionRadius;
                this.fearRadius = config.fearRadius || 0;
                this.baseFertility = config.fertility || 0;
                this.fertility = this.baseFertility;
                this.fertilityBoostTimer = 0;
                
                // Generation system
                this.generation = isBaby ? parentGeneration + 1 : 1;
                if (this.generation > (simulationStats.maxGeneration[species] || 0)) {
                    simulationStats.maxGeneration[species] = this.generation;
                }
                
                this.satiation = 0;
                if (this.isPredator) this.satiation = 300;
                this.isEaten = false;

                // Life Cycle properties
                this.adultAge = 800; // ~13 seconds
                this.maxAge = 6000; // ~100 seconds
                this.age = isBaby ? 0 : Math.random() * this.maxAge;
                this.isAdult = this.age >= this.adultAge;
                this.wantsToMate = false;
                this.matingCooldown = Math.random() * 500;
                this.isMating = false;
                this.matingPartner = null;
                this.matingTimer = 0;

                const material = new THREE.MeshBasicMaterial({ color: config.color, wireframe: isWireframeMode, side: THREE.DoubleSide });
                this.mesh = new THREE.Mesh(new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(config.vertices, 3)), material);
                
                const initialScale = isBaby ? config.scale * 0.3 : config.scale;
                this.mesh.scale.set(initialScale, initialScale, initialScale);
                
                if (this.isPredator) {
                    const glowGeometry = new THREE.SphereGeometry(8, 8, 6);
                    const glowMaterial = new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.1, side: THREE.BackSide });
                    this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.mesh.add(this.glow);
                }
                
                this.position = new THREE.Vector3(Math.random()*worldSize.width-worldSize.width/2, Math.random()*(worldSize.height-10)+5, Math.random()*worldSize.depth-worldSize.depth/2);
                this.velocity = new THREE.Vector3(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1);
                this.velocity.setLength(Math.random() * this.maxSpeed * 0.5 + 0.1);
                this.acceleration = new THREE.Vector3();
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            applyForce(force) { this.acceleration.add(force); }
            
            // Finds the nearest food particle
            findNearestFood() {
                if (this.isPredator) return null; // Predators are not interested in food pellets
                
                let closestFood = null;
                let minDistance = Infinity;
                
                for (const particle of food) {
                    const distance = this.position.distanceTo(particle.position);
                    
                    // Check if food is within perception radius
                    if (distance < this.perceptionRadius && distance < minDistance) {
                        minDistance = distance;
                        closestFood = particle;
                    }
                }
                
                return closestFood;
            }

            update(allBoids) {
                if (this.isEaten) return;

                if (this.fertilityBoostTimer > 0) {
                    this.fertilityBoostTimer--;
                    if (this.fertilityBoostTimer === 0) {
                        this.fertility = this.baseFertility;
                    }
                }

                this.age++;
                if (!this.isAdult && this.age > this.adultAge) {
                    this.isAdult = true;
                }
                if (!this.isAdult) {
                    const scale = fishSpecies[this.species].scale * (0.3 + 0.7 * (this.age / this.adultAge));
                    this.mesh.scale.set(scale, scale, scale);
                }

                if (!isImmortalMode && this.age > this.maxAge) {
                    this.isEaten = true; // Die of old age
                    return;
                }

                if (this.matingCooldown > 0) {
                    this.matingCooldown--;
                } else if (this.isAdult && !this.isMating && !this.isPredator && !this.wantsToMate) {
                    let mateChance = this.fertility;
                    if (this.fertilityBoostTimer > 0) {
                        mateChance = 0.25; // 25% chance when boost is active
                    }
                    if (Math.random() < mateChance) {
                        this.wantsToMate = true;
                    } else {
                        this.matingCooldown = 200 + Math.random() * 200; // Wait a bit before trying again
                    }
                }

                if (this.isMating) {
                    this.mate();
                } else {
                    // Search for food for non-predator fish that are not fleeing
                    const nearestFood = this.findNearestFood();
                    
                    if (nearestFood) {
                        // Calculate a direction vector towards the food
                        const foodDirection = new THREE.Vector3().subVectors(nearestFood.position, this.position);
                        
                        // Check if the fish is close enough to eat
                        if (foodDirection.length() < 5) {
                            // Eat the food
                            const foodIndex = food.indexOf(nearestFood);
                            if (foodIndex !== -1) {
                                scene.remove(nearestFood.mesh);
                                food.splice(foodIndex, 1);
                                
                                this.matingCooldown = 0;

                                // Apply fertility boost
                                const boost = 2; // 100% boost
                                this.fertility = Math.min(1.0, this.baseFertility * boost); // Cap at max fertility
                                this.fertilityBoostTimer = 500; // Boost lasts for ~8 seconds

                                // Increase max age by 20%
                                this.maxAge *= 1.2;

                                // Temporary visual effect (glow)
                                const currentColor = this.mesh.material.color.clone();
                                this.mesh.material.color.set(0xffff00);
                                
                                setTimeout(() => {
                                    this.mesh.material.color.copy(currentColor);
                                }, 300);
                            }
                        } else {
                            // Steer towards the food
                            const steerForce = this.seek(nearestFood.position);
                            steerForce.multiplyScalar(1.5); // Prioritize food
                            this.applyForce(steerForce);
                        }
                    } else {
                        // Normal behavior if no food is nearby
                        if (this.wantsToMate) {
                            this.findPartner(allBoids);
                        }
                        if (this.isPredator) this.hunt(allBoids);
                        else this.schoolAndFlee(allBoids);
                    }
                }

                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.multiplyScalar(0);

                this.checkBounds();
                this.mesh.position.copy(this.position);
                
                if (this.velocity.lengthSq() > 0.0001) {
                    const lookAtPoint = new THREE.Vector3().addVectors(this.position, this.velocity);
                    this.mesh.lookAt(lookAtPoint);
                    this.mesh.rotateY(-Math.PI / 2);
                }
            }

            findPartner(allBoids) {
                for (const other of allBoids) {
                    if (other !== this && !other.isPredator && other.species === this.species && other.wantsToMate && !other.isMating) {
                        const d = this.position.distanceTo(other.position);
                        if (d < this.perceptionRadius) {
                            this.isMating = true;
                            this.wantsToMate = false;
                            this.matingPartner = other;
                            this.matingTimer = 300; // 5 seconds

                            other.isMating = true;
                            other.wantsToMate = false;
                            other.matingPartner = this;
                            other.matingTimer = 300;
                            return;
                        }
                    }
                }
            }

            mate() {
                this.matingTimer--;

                if (this.matingTimer <= 0 || this.matingPartner.isEaten || !this.matingPartner) {
                    if (this.matingPartner) {
                        this.matingPartner.isMating = false;
                        this.matingPartner.matingCooldown = 1500 + Math.random() * 500;
                    }
                    this.isMating = false;
                    this.matingPartner = null;
                    this.matingCooldown = 1500 + Math.random() * 500;
                    return;
                }
                
                const directionToPartner = new THREE.Vector3().subVectors(this.matingPartner.position, this.position);
                const distance = directionToPartner.length();
                directionToPartner.normalize();

                const tangent = new THREE.Vector3(-directionToPartner.z, 0, directionToPartner.x);
                
                let steerForce = new THREE.Vector3();
                if (distance > 20) {
                    steerForce.add(this.seek(this.matingPartner.position));
                } else {
                    steerForce.add(tangent);
                }
                
                this.applyForce(steerForce.multiplyScalar(0.5));

                if (this.matingTimer === 1) {
                    const eggPosition = new THREE.Vector3().addVectors(this.position, this.matingPartner.position).multiplyScalar(0.5);
                    eggPosition.y = 2;
                    // Use the maximum generation between the two parents
                    const parentGeneration = Math.max(this.generation, this.matingPartner.generation);
                    eggs.push(new Egg(this.species, eggPosition, fishSpecies[this.species].color, parentGeneration));
                }
            }


            hunt(allBoids) {
                if (this.schoolAndFlee(allBoids, true)) return;
                if (this.satiation > 0) {
                    this.satiation--;
                    this.schoolAndFlee(allBoids, true);
                    return;
                }

                let bestTarget = null;
                let minDistance = Infinity;
                const preyBoids = allBoids.filter(b => !b.isPredator && !b.isEaten);
                const riskConfig = fishSpecies[this.species].riskAssessment;

                for (const potentialTarget of preyBoids) {
                    const d = this.position.distanceTo(potentialTarget.position);
                    if (d > riskConfig.maxDistance || d > minDistance) continue;
                    let groupSize = 0;
                    for (const otherPrey of preyBoids) {
                        if (potentialTarget.position.distanceTo(otherPrey.position) < 25) groupSize++;
                    }
                    if (groupSize > riskConfig.maxGroupSize) continue;
                    minDistance = d;
                    bestTarget = potentialTarget;
                }

                if (bestTarget) {
                    let pursuitForce = this.seek(bestTarget.position);
                    this.applyForce(pursuitForce);
                    if (this.position.distanceTo(bestTarget.position) < 5) {
                        if (!isImmortalMode) {
                            createEatEffect(bestTarget.position, fishSpecies[this.species].color);
                            bestTarget.isEaten = true;
                            simulationStats.preyEaten++;
                        }
                        this.satiation = 300;
                    }
                } else {
                    this.schoolAndFlee(allBoids, true);
                }
            }

            schoolAndFlee(allBoids, ignorePredators = false) {
                if (superPredator && superPredator.isActive) {
                    const d = this.position.distanceTo(superPredator.segments[0].position);
                    const superFearRadius = 200;
                    if (d < superFearRadius) {
                        let diff = new THREE.Vector3().subVectors(this.position, superPredator.segments[0].position);
                        diff.normalize().divideScalar(d);
                        let steer = this.seek(this.position.clone().add(diff));
                        steer.multiplyScalar(5.0);
                        this.applyForce(steer);
                        return true;
                    }
                }
                
                if (!this.isPredator && !ignorePredators) {
                    let fleeVector = new THREE.Vector3();
                    let predatorCount = 0;
                    for (const other of allBoids) {
                        if (other.isPredator) {
                            const d = this.position.distanceTo(other.position);
                            if (d > 0 && d < this.fearRadius) {
                                let diff = new THREE.Vector3().subVectors(this.position, other.position);
                                diff.normalize().divideScalar(d);
                                fleeVector.add(diff);
                                predatorCount++;
                            }
                        }
                    }
                    if (predatorCount > 0) {
                        fleeVector.divideScalar(predatorCount);
                        let steer = this.seek(this.position.clone().add(fleeVector));
                        steer.multiplyScalar(2.5);
                        this.applyForce(steer);
                        return true;
                    }
                }
                
                let separation = this.separate(allBoids);
                let alignment = this.align(allBoids);
                let cohesion = this.cohere(allBoids);

                separation.multiplyScalar(flockingForces.separation);
                alignment.multiplyScalar(flockingForces.alignment);
                cohesion.multiplyScalar(flockingForces.cohesion);

                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
                return false;
            }
            
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.setLength(this.maxSpeed);
                let steer = new THREE.Vector3().subVectors(desired, this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }

            separate(boids) {
                let desiredSeparation = 15.0;
                let steer = new THREE.Vector3();
                let count = 0;
                for (let other of boids) {
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < desiredSeparation)) {
                        let diff = new THREE.Vector3().subVectors(this.position, other.position);
                        diff.normalize();
                        diff.divideScalar(d);
                        steer.add(diff);
                        count++;
                    }
                }
                if (count > 0) steer.divideScalar(count);
                if (steer.length() > 0) {
                    steer.setLength(this.maxSpeed);
                    steer.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                }
                return steer;
            }

            align(boids) {
                let sum = new THREE.Vector3();
                let count = 0;
                for (let other of boids) {
                    if (other.species !== this.species) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < this.perceptionRadius)) {
                        sum.add(other.velocity);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.divideScalar(count);
                    sum.setLength(this.maxSpeed);
                    let steer = new THREE.Vector3().subVectors(sum, this.velocity);
                    steer.clampLength(0, this.maxForce);
                    return steer;
                } else {
                    return new THREE.Vector3();
                }
            }

            cohere(boids) {
                let sum = new THREE.Vector3();
                let count = 0;
                for (let other of boids) {
                    if (other.species !== this.species) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < this.perceptionRadius)) {
                        sum.add(other.position);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.divideScalar(count);
                    return this.seek(sum);
                } else {
                    return new THREE.Vector3();
                }
            }

            checkBounds() {
                const margin = 2;
                if (this.position.x < -worldSize.width/2+margin) { this.position.x = -worldSize.width/2+margin; this.velocity.x *= -1; }
                else if (this.position.x > worldSize.width/2-margin) { this.position.x = worldSize.width/2-margin; this.velocity.x *= -1; }
                if (this.position.y < margin) { this.position.y = margin; this.velocity.y *= -1; }
                else if (this.position.y > worldSize.height-margin) { this.position.y = worldSize.height-margin; this.velocity.y *= -1; }
                if (this.position.z < -worldSize.depth/2+margin) { this.position.z = -worldSize.depth/2+margin; this.velocity.z *= -1; }
                else if (this.position.z > worldSize.depth/2-margin) { this.position.z = worldSize.depth/2-margin; this.velocity.z *= -1; }
            }
        }

        // --- Auto Mode Manager ---
        class AutoModeManager {
            constructor() {
                this.updateInterval = 3000; // Check every 3 seconds
                this.lastUpdateTime = 0;
                this.targets = {
                    minPrey: 80,
                    maxPrey: 150,
                    superPredatorThreshold: 180,
                };
                this.startTime = 0;
                this.timerInterval = null;
                this.timerDisplayElement = document.getElementById('auto-mode-timer');
                this.lastPreyCount = 0;
            }

            start() {
                this.startTime = performance.now();
                this.timerDisplayElement.style.display = 'inline';
                if (this.timerInterval) clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    const elapsedTime = Math.floor((performance.now() - this.startTime) / 1000);
                    const minutes = String(Math.floor(elapsedTime / 60)).padStart(2, '0');
                    const seconds = String(elapsedTime % 60).padStart(2, '0');
                    this.timerDisplayElement.textContent = ` | Survie: ${minutes}:${seconds}`;
                }, 1000);
                const prey = boids.filter(b => !b.isEaten && !b.isPredator);
                this.lastPreyCount = prey.length;
            }

            stop(freeze = false) {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
                if (!freeze) {
                    this.timerDisplayElement.style.display = 'none';
                    this.timerDisplayElement.textContent = '';
                }
            }

            update() {
                const now = performance.now();
                if (now - this.lastUpdateTime < this.updateInterval) {
                    return;
                }
                this.lastUpdateTime = now;

                const aliveBoids = boids.filter(b => !b.isEaten);
                const prey = aliveBoids.filter(b => !b.isPredator);
                const predators = aliveBoids.filter(b => b.isPredator);
                const totalFish = prey.length + predators.length;

                if (totalFish === 0 && this.startTime > 0) {
                    this.stop(true); // Stop and freeze the timer
                    return;
                }

                const populationChangeRate = (this.lastPreyCount > 0) ? (prey.length - this.lastPreyCount) / this.lastPreyCount : 0;
                if (populationChangeRate < -0.10) { // More than 10% drop
                    generateFood(); // Emergency feeding
                    generateFood(); // Double dose
                }
                
                // Manage prey population based on thresholds
                if (prey.length < this.targets.minPrey) {
                    this.increaseFertility();
                    if (prey.length < this.targets.minPrey / 2) {
                        generateFood();
                    }
                } else if (prey.length > this.targets.maxPrey) {
                    this.decreaseFertility();
                }

                // Manage super predator
                if (prey.length > this.targets.superPredatorThreshold && !superPredator.isActive) {
                    superPredator.spawn();
                } else if (prey.length < this.targets.maxPrey && superPredator.isActive) {
                    scene.remove(superPredator.body);
                    superPredator.isActive = false;
                    document.getElementById('ropefish-status').setAttribute('data-lang-key', 'inactive');
                    setLanguage(document.documentElement.lang);
                }

                // Update the count for the next cycle
                this.lastPreyCount = prey.length;
            }

            increaseFertility() {
                for (const species in fishSpecies) {
                    if (fishSpecies[species].type === 'prey') {
                        fishSpecies[species].fertility = Math.min(0.1, fishSpecies[species].fertility + 0.002);
                        this.updateSlider(`${species}-fertility`, fishSpecies[species].fertility);
                    }
                }
            }

            decreaseFertility() {
                for (const species in fishSpecies) {
                    if (fishSpecies[species].type === 'prey') {
                        fishSpecies[species].fertility = Math.max(0.001, fishSpecies[species].fertility - 0.002);
                        this.updateSlider(`${species}-fertility`, fishSpecies[species].fertility);
                    }
                }
            }
            
            updateSlider(sliderId, value) {
                const slider = document.getElementById(sliderId);
                if (slider) {
                    slider.value = value;
                    const valueSpan = document.getElementById(`${sliderId}-value`);
                    if (valueSpan) {
                       valueSpan.textContent = value.toFixed(3);
                    }
                }
            }
        }

        function toggleAutoModeUI(isActive) {
            const statusEl = document.getElementById('auto-mode-status');
            const statusValueEl = document.getElementById('auto-mode-status-value');
            if (isActive) {
                statusEl.style.display = 'inline';
                statusValueEl.textContent = translations[document.documentElement.lang].active;
                autoModeManager.start();
            } else {
                statusEl.style.display = 'none';
                autoModeManager.stop();
            }

            document.querySelectorAll('.settings-panel fieldset').forEach(fieldset => {
                fieldset.disabled = isActive;
            });
        }
        
        function randomizeSettings() {
            // Randomize flocking forces
            flockingForces.alignment = (Math.random() * 2).toFixed(1);
            flockingForces.cohesion = (Math.random() * 2).toFixed(1);
            flockingForces.separation = (Math.random() * 2).toFixed(1);

            // Randomize environment
            environmentSettings.rockCount = Math.floor(Math.random() * 50);
            environmentSettings.plantCount = Math.floor(Math.random() * 100);

            // Randomize species parameters
            for (const species in fishSpecies) {
                const config = fishSpecies[species];
                config.count = Math.floor(Math.random() * 100) + 10; // 10 to 110 fish
                config.scale = (Math.random() * 1.5 + 0.2).toFixed(1);
                config.maxSpeed = (Math.random() * 1.5 + 0.2).toFixed(1);
                config.perceptionRadius = Math.floor(Math.random() * 150) + 20;

                if (config.type === 'prey') {
                    config.fearRadius = Math.floor(Math.random() * 150) + 30;
                    config.fertility = (Math.random() * 0.05).toFixed(3);
                }
                if (config.type === 'predator') {
                    config.riskAssessment.maxDistance = Math.floor(Math.random() * 200) + 50;
                    config.riskAssessment.maxGroupSize = Math.floor(Math.random() * 15) + 1;
                }
            }

            // Update UI sliders to reflect new values
            document.querySelectorAll('input[type=range]').forEach(slider => {
                const { category, species, property } = slider.dataset;
                let newValue;
                if (category === 'species') {
                    if (property.includes('.')) {
                        const [prop, subProp] = property.split('.');
                        newValue = fishSpecies[species][prop][subProp];
                    } else {
                        newValue = fishSpecies[species][property];
                    }
                } else if (category === 'flocking') {
                    newValue = flockingForces[property];
                } else if (category === 'environment') {
                    newValue = environmentSettings[property];
                }
                
                if (newValue !== undefined) {
                    slider.value = newValue;
                    const valueSpan = document.getElementById(`${slider.id}-value`);
                    if (valueSpan) {
                        valueSpan.textContent = newValue;
                    }
                }
            });

            // Re-initialize decor and simulation
            createDecor();
            createPlants();
            resetSimulation();
        }

        function startChaseAnimation() {
            const canvas = document.getElementById('chase-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            let leonceX = -200;
            let equityX = -350;
            const y = canvas.height / 2;
            
            function drawLightning(ctx, x1, y1, x2, y2) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                let lastX = x1;
                let lastY = y1;
                for(let i=1; i<10; i++) {
                    const newX = x1 + (x2 - x1) * (i / 10);
                    const newY = y1 + (y2 - y1) * (i / 10) + (Math.random() - 0.5) * 20;
                    ctx.lineTo(newX, newY);
                }
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = `rgba(0, 255, 255, ${Math.random() * 0.5 + 0.5})`;
                ctx.lineWidth = Math.random() * 2 + 1;
                ctx.stroke();
            }

            function animateChase() {
                chaseAnimationId = requestAnimationFrame(animateChase);
                
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                leonceX += 3;
                equityX += 3.2;

                if (equityX > canvas.width + 150) {
                    leonceX = -200;
                    equityX = -350;
                }

                ctx.font = 'bold 30px "Courier New", Courier, monospace';
                ctx.fillStyle = '#00ff41';
                ctx.shadowColor = '#00ff41';
                ctx.shadowBlur = 10;
                ctx.fillText("LEONCE", leonceX, y);
                ctx.fillText("EQUITY", equityX, y);
                ctx.shadowBlur = 0;

                if (Math.random() < 0.1) {
                    drawLightning(ctx, Math.random() * canvas.width, 0, Math.random() * canvas.width, canvas.height);
                }
            }
            animateChase();
        }

        function stopChaseAnimation() {
            cancelAnimationFrame(chaseAnimationId);
        }

        // --- Initialization ---
        init();
        loadSettings();
        setupUI();
        initModal();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020308);
            
            const ambientLight = new THREE.AmbientLight(0x001122, 0.3);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0x004488, 0.5);
            directionalLight.position.set(0, worldSize.height, worldSize.depth/2);
            scene.add(directionalLight);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 100, 600);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 1500;
            controls.target.set(0, worldSize.height / 2, 0);

            createAquariumBox();
            createFloorGrid();
            createDecor();
            createPlants();
            superPredator = new Ropefish();
            submarine = new Submarine();
            scene.add(submarine.mesh);
            autoModeManager = new AutoModeManager();
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('visibilitychange', handleVisibilityChange, false);
            document.getElementById('exit-btn').addEventListener('click', () => {
                document.querySelectorAll('.settings-panel').forEach(p => p.classList.add('hidden'));
                document.querySelectorAll('.control-group').forEach(g => {
                    g.classList.remove('active');
                    g.querySelector('.control-group-content').style.maxHeight = null;
                });
            });
        }

        // --- Scene Element Creation ---
        function createEatEffect(position, color) {
            const particleCount = 20;
            const material = new THREE.LineBasicMaterial({ color: color });
            for (let i = 0; i < particleCount; i++) {
                const vertices = [0,0,0, (Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)];
                const geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const particle = new THREE.Line(geometry, material);
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2),
                    life: 1.0
                };
                particles.push(particle);
                scene.add(particle);
            }
        }

        function createAquariumBox() {
            const geometry = new THREE.BoxGeometry(worldSize.width, worldSize.height, worldSize.depth);
            const wireMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff41, wireframe: true, transparent: true, opacity: 0.4 });
            const solidMaterial = new THREE.MeshBasicMaterial({ color: 0x004488, transparent: true, opacity: 0.1, side: THREE.BackSide });
            aquariumBox = new THREE.Mesh(geometry, wireMaterial);
            aquariumBox.userData.materials = [wireMaterial, solidMaterial];
            aquariumBox.position.set(0, worldSize.height / 2, 0);
            scene.add(aquariumBox);
            createBubbles();
        }
        function createFloorGrid() {
            const gridHelper = new THREE.GridHelper(worldSize.width, 15, 0x00ff41, 0x004411);
            gridHelper.material.opacity = 0.4;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            const topGrid = new THREE.GridHelper(worldSize.width, 15, 0x0088ff, 0x002244);
            topGrid.position.y = worldSize.height;
            topGrid.material.opacity = 0.2;
            topGrid.material.transparent = true;
            scene.add(topGrid);
        }
        function createDecor() {
            while(rocks.length) {
                const rock = rocks.pop();
                scene.remove(rock);
                rock.geometry.dispose();
            }
            const rockMaterial = new THREE.MeshBasicMaterial({ color: 0x00aa33, wireframe: isWireframeMode, transparent: true, opacity: 0.7 });
            for(let i=0; i < environmentSettings.rockCount; i++) {
                const size = Math.random() * 35 + 15;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(size, 1), rockMaterial);
                rock.position.set((Math.random() - 0.5) * (worldSize.width - size * 2), size / 2, (Math.random() - 0.5) * (worldSize.depth - size * 2));
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                scene.add(rock);
                rocks.push(rock);
            }
        }
        function createPlants() {
            while(plants.length) {
                const plant = plants.pop();
                scene.remove(plant);
                plant.geometry.dispose();
            }
            const material = new THREE.LineBasicMaterial({ color: 0x00dd44, transparent: true, opacity: 0.8, linewidth: 2 });
            for (let i = 0; i < environmentSettings.plantCount; i++) {
                const vertices = [];
                const height = Math.random() * 80 + 30;
                vertices.push(0, 0, 0, 0, height, 0);
                for (let j = 0; j < Math.floor(Math.random() * 6) + 4; j++) {
                    const leafH = Math.random() * height * 0.8 + height * 0.2;
                    const leafL = Math.random() * 25 + 15;
                    const angle = Math.random() * Math.PI * 2;
                    const wave = Math.sin(leafH * 0.1) * 5;
                    vertices.push(0, leafH, 0, Math.cos(angle) * leafL + wave, leafH + (Math.random() - 0.5) * 8, Math.sin(angle) * leafL);
                }
                const geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const plant = new THREE.LineSegments(geometry, material);
                plant.position.set((Math.random() - 0.5) * worldSize.width * 0.9, 0, (Math.random() - 0.5) * worldSize.depth * 0.9);
                scene.add(plant);
                plants.push(plant);
            }
        }
        function createBubbles() {
            const bubbleGeometry = new THREE.SphereGeometry(2, 6, 4);
            const bubbleMaterial = new THREE.MeshBasicMaterial({ color: 0x88ddff, transparent: true, opacity: 0.3, wireframe: isWireframeMode });
            for (let i = 0; i < 20; i++) {
                const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                bubble.position.set((Math.random() - 0.5) * worldSize.width * 0.8, Math.random() * worldSize.height * 0.3, (Math.random() - 0.5) * worldSize.depth * 0.8);
                bubble.userData = { velocity: Math.random() * 0.5 + 0.2, oscillation: Math.random() * 0.02 + 0.01 };
                scene.add(bubble);
            }
        }
        function createBoids() {
            while(boids.length) {
                const boid = boids.pop();
                scene.remove(boid.mesh);
            }
            boids = [];
            for (const species in fishSpecies) {
                for (let i = 0; i < fishSpecies[species].count; i++) {
                    boids.push(new Boid(species));
                }
            }
        }
        function updateStats() {
            const aliveBoids = boids.filter(b => !b.isEaten);
            const predators = aliveBoids.filter(b => b.isPredator);
            const prey = aliveBoids.filter(b => !b.isPredator);
            document.getElementById('fish-count').textContent = prey.length;
            document.getElementById('predator-count').textContent = predators.length;
            updateStatsPanel();
        }

        function updateStatsPanel() {
            const preyEatenEl = document.getElementById('stats-prey-eaten');
            if (preyEatenEl) preyEatenEl.textContent = simulationStats.preyEaten;

            for (const species in fishSpecies) {
                const countEl = document.getElementById(`stats-${species}-count`);
                if (countEl) countEl.textContent = boids.filter(b => b.species === species && !b.isEaten).length;
                
                const eggsEl = document.getElementById(`stats-${species}-eggs`);
                if (eggsEl) eggsEl.textContent = simulationStats.eggsLaid[species] || 0;

                const babiesEl = document.getElementById(`stats-${species}-babies`);
                if (babiesEl) babiesEl.textContent = simulationStats.babiesHatched[species] || 0;
                
                const generationEl = document.getElementById(`stats-${species}-generation`);
                if (generationEl) generationEl.textContent = simulationStats.maxGeneration[species] || 1;
            }
        }
        
        function resetSimulation() {
            simulationStats.preyEaten = 0;
            for(const species in fishSpecies) {
                simulationStats.eggsLaid[species] = 0;
                simulationStats.babiesHatched[species] = 0;
            }

            if(superPredator) {
                scene.remove(superPredator.body);
                superPredator.isActive = false;
                document.getElementById('ropefish-status').setAttribute('data-lang-key', 'inactive');
            }
            
            // Remove existing food particles
            for (const particle of food) {
                scene.remove(particle.mesh);
            }
            food = [];
            
            createBoids();
            setLanguage(document.documentElement.lang);
        }

        // --- Save/Load/Reset Settings ---
        function saveSettings() {
            const settings = {
                fishSpecies: fishSpecies,
                flockingForces: flockingForces,
                environmentSettings: environmentSettings
            };
            try {
                localStorage.setItem('aquarium-settings', JSON.stringify(settings));
                const saveBtn = document.getElementById('save-btn');
                if (saveBtn) {
                    saveBtn.style.backgroundColor = '#ff4141';
                    saveBtn.style.borderColor = '#ff4141';
                    setTimeout(() => {
                        saveBtn.style.backgroundColor = ''; // Revert to CSS default
                        saveBtn.style.borderColor = ''; // Revert to CSS default
                    }, 1000);
                }
            } catch(e) {
                console.error("Failed to save settings to localStorage", e);
            }
        }

        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('aquarium-settings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    // Deep merge utility
                    const isObject = (item) => (item && typeof item === 'object' && !Array.isArray(item));
                    const mergeDeep = (target, source) => {
                        if (isObject(target) && isObject(source)) {
                            for (const key in source) {
                                if (isObject(source[key])) {
                                    if (!target[key]) Object.assign(target, { [key]: {} });
                                    mergeDeep(target[key], source[key]);
                                } else {
                                    Object.assign(target, { [key]: source[key] });
                                }
                            }
                        }
                        return target;
                    }

                    mergeDeep(fishSpecies, settings.fishSpecies);
                    mergeDeep(flockingForces, settings.flockingForces);
                    mergeDeep(environmentSettings, settings.environmentSettings);
                }
            } catch(e) {
                console.error("Failed to load settings from localStorage", e);
            }
        }

        function resetSettings() {
            try {
                localStorage.removeItem('aquarium-settings');
                location.reload();
            } catch(e) {
                console.error("Failed to reset settings", e);
            }
        }

        // --- UI & Settings ---
        function updateSliderColor(slider, color) {
            const sliderId = slider.id;
            let styleTag = document.getElementById(`style-${sliderId}`);
            if (!styleTag) {
                styleTag = document.createElement('style');
                styleTag.id = `style-${sliderId}`;
                document.head.appendChild(styleTag);
            }
            styleTag.innerHTML = `
                #${sliderId}::-webkit-slider-thumb { background: ${color}; border-color: ${color}; }
                #${sliderId}::-moz-range-thumb { background: ${color}; border-color: ${color}; }
                #${sliderId}::-webkit-slider-runnable-track { background: ${color}; }
                #${sliderId}::-moz-range-track { background: ${color}; }
            `;
        }
        
        function createSlider(id, labelKey, min, max, step, value, dataAttributes) {
            const valueId = `${id}-value`;
            const lang = document.documentElement.lang || 'en';
            const labelText = (translations[lang] && translations[lang][labelKey]) ? translations[lang][labelKey] : labelKey.replace(/_/g, ' ');
            const dataAttrString = Object.entries(dataAttributes).map(([key, val]) => `data-${key}="${val}"`).join(' ');
            return `
                <label for="${id}" data-lang-key="${labelKey}">${labelText}: <span id="${valueId}">${value}</span></label>
                <input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${value}" ${dataAttrString}>
            `;
        }

        function setupUI() {
            const mainControlsContainer = document.getElementById('main-controls-container');
            const settingsContainer = document.getElementById('settings-container');
            mainControlsContainer.innerHTML = '';
            settingsContainer.innerHTML = '';

            const icons = {
                species: `<svg class="btn-icon" viewBox="0 0 24 24"><path d="M14.2,18.5L12.9,19.8L12.2,19.1L12.5,17.8L11.5,17.2L10.5,17.8L10.2,19.1L9.5,19.8L8.2,18.5L8.5,17.2L7.5,16.5L8.2,15.2L9.5,15.5L10.2,14.2L10.5,15.5L11.5,16.2L12.5,15.5L12.2,14.2L12.9,15.2L14.2,16.5L13.5,17.2L14.2,18.5M19.1,12.2L17.8,12.5L17.2,11.5L17.8,10.5L19.1,10.2L19.8,9.5L18.5,8.2L17.2,8.5L16.5,7.5L15.2,8.2L15.5,9.5L14.2,10.2L15.2,10.5L15.5,11.5L16.2,12.2L17.2,12.9L18.5,14.2L19.1,12.9L19.8,12.2M19.8,4.3L19.1,5L18.5,4.3L17.2,5L17.8,3.5L17.2,2.9L18.5,2.2L19.1,3.5L19.8,2.9L20.5,3.5L19.8,4.3M9.5,5L8.2,4.3L7.5,5L8.5,3.5L8.2,2.9L9.5,2.2L10.2,3.5L10.5,2.9L11.2,3.5L10.5,4.3L11.2,5L9.5,5M5,10.2L4.3,9.5L3.5,10.2L2.9,9.5L3.5,8.2L2.9,7.5L4.3,8.2L5,7.5L5.7,8.2L5,10.2M22,22V2L2,22H22Z" /></svg>`,
                params: `<svg class="btn-icon" viewBox="0 0 24 24"><path d="M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z" /></svg>`,
                actions: `<svg class="btn-icon" viewBox="0 0 24 24"><path d="M13,2.05V5.08C16.39,5.57 19,8.47 19,12C19,15.53 16.39,18.43 13,18.92V21.95C18,21.45 22,17.15 22,12C22,6.85 18,2.55 13,2.05M11,2.05C6,2.55 2,6.85 2,12C2,17.15 6,21.45 11,21.95V18.92C7.61,18.43 5,15.53 5,12C5,8.47 7.61,5.57 11,5.08V2.05Z" /></svg>`,
                system: `<svg class="btn-icon" viewBox="0 0 24 24"><path d="M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19A7,7 0 0,1 5,12A7,7 0 0,1 12,5M12,6A6,6 0 0,0 6,12A6,6 0 0,0 12,18A6,6 0 0,0 18,12A6,6 0 0,0 12,6M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16A4,4 0 0,1 8,12A4,4 0 0,1 12,8Z" /></svg>`
            };
            
            const controlGroups = {
                species: { label: 'Espèces', icon: icons.species, buttons: [] },
                params: { label: 'Paramètres', icon: icons.params, buttons: [] },
                actions: { label: 'Actions', icon: icons.actions, buttons: [] },
                system: { label: 'Système', icon: icons.system, buttons: [] }
            };

            for (const species in fishSpecies) {
                controlGroups.species.buttons.push({
                    id: `btn-${species}`,
                    text: species.toUpperCase(),
                    color: `#${fishSpecies[species].color.toString(16).padStart(6, '0')}`,
                    panelId: `${species}-panel`,
                    tooltip: `Ouvre le panneau de ${species}`
                });
            }

            ['forces', 'environment'].forEach(key => {
                controlGroups.params.buttons.push({
                    id: `btn-${key}`,
                    text: key.toUpperCase(),
                    panelId: `${key}-panel`,
                    tooltip: `Ouvre le panneau ${key}`
                });
            });

            ['feed', 'release_ropefish', 'random_mode', 'immortal_mode', 'auto_mode', 'mode_wireframe', 'view_orbital'].forEach(key => {
                controlGroups.actions.buttons.push({
                    id: `btn-${key}`,
                    text: translations.fr[key],
                    key: key,
                    tooltip: `Action: ${translations.fr[key]}`
                });
            });
            
            ['statistics', 'help_title', 'save', 'reset', 'exjv_credit'].forEach(key => {
                 controlGroups.system.buttons.push({
                    id: `btn-${key}`,
                    text: translations.fr[key] || key.replace('_', ' ').toUpperCase(),
                    key: key,
                    tooltip: `Ouvre ${translations.fr[key] || key}`
                });
            });

            for (const groupKey in controlGroups) {
                const group = controlGroups[groupKey];
                const groupDiv = document.createElement('div');
                groupDiv.className = 'control-group';
                groupDiv.innerHTML = `
                    <div class="control-group-header">
                        ${group.icon}
                        <span>${group.label}</span>
                        <span class="caret">▶</span>
                    </div>
                    <div class="control-group-content"></div>
                `;
                mainControlsContainer.appendChild(groupDiv);
                
                const contentDiv = groupDiv.querySelector('.control-group-content');
                group.buttons.forEach(btnData => {
                    const btn = document.createElement('button');
                    btn.id = btnData.id;
                    btn.className = 'settings-btn';
                    btn.innerHTML = `<span>${btnData.text}</span>`;
                    if (btnData.color) {
                        btn.style.color = btnData.color;
                        btn.style.borderColor = btnData.color;
                    }
                    btn.setAttribute('data-tooltip', btnData.tooltip);
                    contentDiv.appendChild(btn);
                });
            }
            
            mainControlsContainer.addEventListener('click', e => {
                const header = e.target.closest('.control-group-header');
                if (header) {
                    const group = header.parentElement;
                    group.classList.toggle('active');
                    const content = group.querySelector('.control-group-content');
                    if (group.classList.contains('active')) {
                        content.style.maxHeight = content.scrollHeight + "px";
                    } else {
                        content.style.maxHeight = null;
                    }
                }
            });


            function makeDraggable(panel) {
                const header = panel.querySelector('.panel-header');
                if (!header) return;
                let isDragging = false;
                let offset = { x: 0, y: 0 };
                
                const onMouseDown = (e) => {
                    panel.style.zIndex = ++highestZIndex;
                    isDragging = true;
                    let event = e.touches ? e.touches[0] : e;
                    offset.x = event.clientX - panel.offsetLeft;
                    offset.y = event.clientY - panel.offsetTop;
                    panel.style.cursor = 'grabbing';
                    document.body.style.userSelect = 'none';
                };

                const onMouseMove = (e) => {
                    if (!isDragging) return;
                    let event = e.touches ? e.touches[0] : e;
                    panel.style.left = `${event.clientX - offset.x}px`;
                    panel.style.top = `${event.clientY - offset.y}px`;
                };

                const onMouseUp = () => {
                    isDragging = false;
                    panel.style.cursor = 'default';
                    document.body.style.userSelect = '';
                };

                header.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                header.addEventListener('touchstart', onMouseDown);
                document.addEventListener('touchmove', onMouseMove);
                document.addEventListener('touchend', onMouseUp);
            }

            function createPanel(id, titleKey, contentHtml, position, color) {
                const panel = document.createElement('div');
                panel.id = id;
                panel.className = 'settings-panel hidden';
                panel.style.left = `${position.x}px`;
                panel.style.top = `${position.y}px`;
                const lang = document.documentElement.lang || 'en';
                const titleText = (translations[lang] && translations[lang][titleKey]) ? translations[lang][titleKey] : titleKey;
                
                const headerStyle = color ? `style="color: ${color}; text-shadow: 0 0 5px ${color};"` : '';

                panel.innerHTML = `
                    <div class="panel-header">
                        <span data-lang-key="${titleKey}" ${headerStyle}>${titleText}</span>
                        <span class="close-btn">[X]</span>
                    </div>
                    <div class="panel-content">${contentHtml}</div>
                `;
                settingsContainer.appendChild(panel);
                panel.addEventListener('mousedown', () => {
                    panel.style.zIndex = ++highestZIndex;
                });
                panel.querySelector('.close-btn').addEventListener('click', () => panel.classList.add('hidden'));
                makeDraggable(panel);
                return panel;
            }
            
            let panelY = 100;
            let panelX = 230;

            for (const species in fishSpecies) {
                const config = fishSpecies[species];
                const colorString = `#${config.color.toString(16).padStart(6, '0')}`;
                
                let content = '<fieldset>';
                content += createSlider(`${species}-count`, 'count', 0, 150, 1, config.count, { category: 'species', species: species, property: 'count', reset: 'true' });
                content += createSlider(`${species}-scale`, 'scale', 0.1, 3, 0.1, config.scale, { category: 'species', species: species, property: 'scale', reset: 'true' });
                content += createSlider(`${species}-maxSpeed`, 'max_speed', 0.1, 2, 0.1, config.maxSpeed, { category: 'species', species: species, property: 'maxSpeed' });
                content += createSlider(`${species}-perceptionRadius`, 'perception_radius', 10, 200, 1, config.perceptionRadius, { category: 'species', species: species, property: 'perceptionRadius' });
                if (config.type === 'prey') {
                    content += createSlider(`${species}-fertility`, 'taux_fecondite', 0, 0.1, 0.001, config.fertility, { category: 'species', species: species, property: 'fertility' });
                }
                if (config.type === 'predator') {
                    content += createSlider(`${species}-maxHuntDist`, 'max_hunt_dist', 50, 300, 5, config.riskAssessment.maxDistance, { category: 'species', species: species, property: 'riskAssessment.maxDistance' });
                    content += createSlider(`${species}-maxGroupSize`, 'max_group_size', 1, 20, 1, config.riskAssessment.maxGroupSize, { category: 'species', species: species, property: 'riskAssessment.maxGroupSize' });
                }
                content += '</fieldset>';

                const panel = createPanel(`${species}-panel`, species, content, { x: panelX, y: panelY }, colorString);
                panel.querySelector('.panel-header > span').textContent = species.toUpperCase();
                panel.querySelectorAll('input[type=range]').forEach(slider => {
                    updateSliderColor(slider, colorString);
                });
                document.getElementById(`btn-${species}`).addEventListener('click', () => {
                    panel.classList.toggle('hidden');
                    panel.style.zIndex = ++highestZIndex;
                });
            }
            
            const generalPanels = ['forces', 'environment', 'statistics', 'help_title'];
            generalPanels.forEach(key => {
                let content = '';
                if(key === 'forces') {
                    content += '<fieldset>';
                    content += createSlider('alignment', 'alignment', 0, 2, 0.1, flockingForces.alignment, { category: 'flocking', property: 'alignment' });
                    content += createSlider('cohesion', 'cohesion', 0, 2, 0.1, flockingForces.cohesion, { category: 'flocking', property: 'cohesion' });
                    content += createSlider('separation', 'separation', 0, 2, 0.1, flockingForces.separation, { category: 'flocking', property: 'separation' });
                    content += '</fieldset>';
                } else if (key === 'environment') {
                    content += '<fieldset>';
                    content += createSlider('rockCount', 'rock_count', 0, 50, 1, environmentSettings.rockCount, { category: 'environment', property: 'rockCount', reset: 'decor' });
                    content += createSlider('plantCount', 'plant_count', 0, 100, 1, environmentSettings.plantCount, { category: 'environment', property: 'plantCount', reset: 'plants' });
                    content += '</fieldset>';
                } else if (key === 'statistics') {
                    let speciesStatsHtml = '';
                    for (const s in fishSpecies) {
                        if (fishSpecies[s].type === 'prey') {
                            const color = '#' + fishSpecies[s].color.toString(16).padStart(6, '0');
                            speciesStatsHtml += `
                                <fieldset style="border-color: ${color};">
                                    <legend style="color: ${color};">${s.toUpperCase()}</legend>
                                    <p>Population: <span id="stats-${s}-count">0</span></p>
                                    <p><span data-lang-key="eggs_laid">Oeufs</span>: <span id="stats-${s}-eggs">0</span></p>
                                    <p><span data-lang-key="babies_hatched">Bébés</span>: <span id="stats-${s}-babies">0</span></p>
                                    <p><span data-lang-key="generation">Génération Max</span>: <span id="stats-${s}-generation">1</span></p>
                                </fieldset>
                            `;
                        }
                    }
                    content = `<div id="stats-panel-content">
                        <p><span data-lang-key="prey_eaten">Proies mangées</span>: <span id="stats-prey-eaten">0</span></p>
                        <hr>
                        ${speciesStatsHtml}
                    </div>`;
                } else if (key === 'help_title') {
                    content = `<div data-lang-key="help_content"></div>`;
                }

                const panel = createPanel(`${key}-panel`, key, content, { x: panelX, y: panelY });
                document.getElementById(`btn-${key}`).addEventListener('click', () => {
                    panel.classList.toggle('hidden');
                    panel.style.zIndex = ++highestZIndex;
                });
            });
            
            const otherControlActions = {
                'auto_mode': (event) => {
                    isAutoModeActive = !isAutoModeActive;
                    toggleAutoModeUI(isAutoModeActive);
                    event.currentTarget.style.borderColor = isAutoModeActive ? '#ff4141' : '';
                },
                'random_mode': () => {
                    randomizeSettings();
                },
                'immortal_mode': (event) => {
                    isImmortalMode = !isImmortalMode;
                    event.currentTarget.style.borderColor = isImmortalMode ? '#00ffff' : '';
                    event.currentTarget.style.color = isImmortalMode ? '#00ffff' : '';
                },
                'mode_wireframe': (event) => {
                    isWireframeMode = !isWireframeMode;
                    const materials = [
                        ...boids.map(b => b.mesh.material),
                        ...rocks.map(r => r.material),
                        superPredator.segments[0].material,
                        ...superPredator.segments.slice(1).map(s => s.material),
                        ...scene.children.filter(c => c.userData.velocity && !c.userData.life).map(b => b.material)
                    ];
                    materials.forEach(m => { if(m) m.wireframe = isWireframeMode; });
                    aquariumBox.material = isWireframeMode ? aquariumBox.userData.materials[0] : aquariumBox.userData.materials[1];
                    event.currentTarget.setAttribute('data-lang-key', isWireframeMode ? 'mode_wireframe' : 'mode_solid');
                    setLanguage(document.documentElement.lang);
                },
                'view_orbital': (event) => {
                    isSubmarineViewActive = !isSubmarineViewActive;
                    submarine.mesh.visible = !isSubmarineViewActive;
                    event.currentTarget.setAttribute('data-lang-key', isSubmarineViewActive ? 'view_sub' : 'view_orbital');
                    setLanguage(document.documentElement.lang);
                },
                'release_ropefish': () => superPredator.spawn(),
                'feed': () => generateFood(),
                'save': saveSettings,
                'reset': resetSettings,
                'exjv_credit': () => {
                    const modal = document.getElementById('exjv-modal');
                    modal.classList.remove('hidden');
                    startChaseAnimation();
                    modal.addEventListener('click', (e) => {
                        if (e.target.classList.contains('modal-overlay') || e.target.classList.contains('close-btn')) {
                            modal.classList.add('hidden');
                            stopChaseAnimation();
                        }
                    });
                }
            };

            for (const key in otherControlActions) {
                 const btn = document.getElementById(`btn-${key}`);
                 if(btn) btn.addEventListener('click', otherControlActions[key]);
            }
            
            settingsContainer.addEventListener('input', (e) => {
                if (e.target.type !== 'range') return;
                const target = e.target;
                const value = parseFloat(target.value);
                const valueSpan = document.getElementById(`${target.id}-value`);
                if (valueSpan) {
                    valueSpan.textContent = value.toFixed(target.id.includes('fertility') ? 3 : (target.step < 1 ? 1 : 0));
                }
                const { category, species, property, reset } = target.dataset;
                if (category === 'species') {
                    if (property.includes('.')) {
                        const [prop, subProp] = property.split('.');
                        fishSpecies[species][prop][subProp] = value;
                    } else {
                        fishSpecies[species][property] = value;
                    }
                } else if (category === 'flocking') {
                    flockingForces[property] = value;
                } else if (category === 'environment') {
                    environmentSettings[property] = value;
                }
                if (reset === 'true') {
                    resetSimulation();
                } else if (reset === 'decor') {
                    createDecor();
                } else if (reset === 'plants') {
                    createPlants();
                }
            });

            setLanguage('en');
            resetSimulation(); // Now call resetSimulation to populate with correct (potentially loaded) settings
        }

        // --- Animation loop and other functions ---
        // Function to generate food
        function generateFood() {
            // Generate 15-25 food particles
            const count = Math.floor(Math.random() * 10) + 15;
            
            for (let i = 0; i < count; i++) {
                // Position particles randomly in the upper part of the aquarium
                const position = new THREE.Vector3(
                    (Math.random() - 0.5) * worldSize.width * 0.8,
                    worldSize.height * (0.8 + Math.random() * 0.15),
                    (Math.random() - 0.5) * worldSize.depth * 0.8
                );
                
                // Create and add the food particle
                food.push(new FoodParticle(position));
            }
            
            // Visual effect - small animation for the "FEED" button
            const feedBtn = document.querySelector('[data-lang-key="feed"]');
            if (feedBtn) {
                feedBtn.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    feedBtn.style.transform = '';
                }, 300);
            }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            
            if (lastFrameTime > 0) {
                const deltaTime = time - lastFrameTime;
                const fps = Math.round(1000 / deltaTime);
                if (isFinite(fps)) {
                    document.getElementById('fps').textContent = `FPS: ${fps}`;
                }
            }
            lastFrameTime = time;

            if (isAutoModeActive) {
                autoModeManager.update();
            }

            // Update eggs and hatch new boids
            let newBoids = [];
            for (let i = eggs.length - 1; i >= 0; i--) {
                const egg = eggs[i];
                const hatchedBoids = egg.update();
                if (hatchedBoids) {
                    newBoids.push(...hatchedBoids);
                    scene.remove(egg.mesh);
                    eggs.splice(i, 1);
                }
            }
            if (newBoids.length > 0) {
                boids.push(...newBoids);
            }
            
            // Update food particles
            for (let i = food.length - 1; i >= 0; i--) {
                const particle = food[i];
                const isDead = particle.update();
                
                if (isDead) {
                    scene.remove(particle.mesh);
                    food.splice(i, 1);
                }
            }

            scene.children.forEach(child => {
                if (child.userData && child.userData.velocity && !child.userData.life) { // Bubbles
                    child.position.y += child.userData.velocity;
                    child.position.x += Math.sin(Date.now() * child.userData.oscillation) * 0.1;
                    if (child.position.y > worldSize.height) {
                        child.position.y = 0;
                        child.position.x = (Math.random() - 0.5) * worldSize.width * 0.8;
                        child.position.z = (Math.random() - 0.5) * worldSize.depth * 0.8;
                    }
                }
            });

            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.position.add(particle.userData.velocity);
                particle.userData.life -= 0.05;
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            }
            
            if (superPredator) superPredator.update(boids);
            if (submarine) submarine.update();
            boids.forEach(boid => boid.update(boids));

            for (let i = boids.length - 1; i >= 0; i--) {
                if (boids[i].isEaten) {
                    scene.remove(boids[i].mesh);
                    boids[i].mesh.geometry.dispose();
                    if(boids[i].mesh.material.dispose) boids[i].mesh.material.dispose();
                    boids.splice(i, 1);
                }
            }

            if (Math.random() < 0.05) {
                updateStats();
            }

            if (!isSubmarineViewActive) {
                controls.update();
            }
            
            const activeCamera = isSubmarineViewActive ? submarine.camera : camera;
            renderer.render(scene, activeCamera);
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            if (submarine) {
                submarine.camera.aspect = window.innerWidth / window.innerHeight;
                submarine.camera.updateProjectionMatrix();
            }
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function catchUpSimulation(seconds) {
            const missedFrames = Math.round(seconds * 60); // Assuming 60fps
            if (missedFrames <= 0) return;

            console.log(`Catching up ${missedFrames} frames...`);

            // Fast-forward life cycle aspects
            boids.forEach(boid => {
                boid.age += missedFrames;
                boid.matingCooldown = Math.max(0, boid.matingCooldown - missedFrames);
                // Approximate movement
                boid.position.addScaledVector(boid.velocity, seconds);
                boid.checkBounds(); // Simple boundary check
            });

            let newBoidsFromHatching = [];
            for (let i = eggs.length - 1; i >= 0; i--) {
                const egg = eggs[i];
                egg.hatchTime -= missedFrames;
                if (egg.hatchTime <= 0) {
                    const hatched = egg.hatch();
                    if(hatched) newBoidsFromHatching.push(...hatched);
                    scene.remove(egg.mesh);
                    eggs.splice(i, 1);
                }
            }
            if(newBoidsFromHatching.length > 0) {
                boids.push(...newBoidsFromHatching);
            }
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                lastHiddenTime = performance.now();
            } else {
                if (lastHiddenTime > 0) {
                    const elapsedTime = (performance.now() - lastHiddenTime) / 1000;
                    catchUpSimulation(elapsedTime);
                }
                lastHiddenTime = 0;
            }
        }
    </script>
</body>
</html>
