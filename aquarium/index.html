<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aquarium Rétro 3D - Simulation de Vie Artificielle</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Explorez un aquarium 3D interactif de style terminal rétro des années 80. Observez des bancs de poissons colorés, gérez l'écosystème et introduisez des prédateurs dans cette simulation de vie artificielle.">
    <meta name="keywords" content="simulation 3d, aquarium, boids, vie artificielle, three.js, webgl, retro, terminal, poisson, prédateur, cichla, erpetoichthys, sous-marin, interactif">
    <meta name="author" content="Simulation Interactive">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://youware.com/aquarium/">
    <meta property="og:title" content="Aquarium Rétro 3D - Simulation de Vie Artificielle">
    <meta property="og:description" content="Plongez dans un écosystème numérique et contrôlez la vie de poissons virtuels dans un style wireframe unique.">
    <meta property="og:image" content="https://placehold.co/1200x630/000000/00ff41?text=Aquarium+3D">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://youware.com/aquarium/">
    <meta property="twitter:title" content="Aquarium Rétro 3D - Simulation de Vie Artificielle">
    <meta property="twitter:description" content="Plongez dans un écosystème numérique et contrôlez la vie de poissons virtuels dans un style wireframe unique.">
    <meta property="twitter:image" content="https://placehold.co/1200x630/000000/00ff41?text=Aquarium+3D">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #0a0a0a 0%, #000000 100%);
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            text-align: center;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            padding: 15px;
            box-sizing: border-box;
            z-index: 100;
            display: block;
            text-shadow: 0 0 5px #00ff41, 0 0 10px #00ff41, 0 0 15px #00ff41;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 65, 0.3);
            border-radius: 4px;
        }
        canvas {
            display: block;
        }
        #exit-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 104;
            cursor: pointer;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff41;
            color: #00ff41;
        }
        #exit-btn:hover {
            color: #ff4141;
        }
        #main-controls-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 101;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-width: 180px;
        }
        .settings-btn {
            cursor: pointer;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 10px 12px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            text-shadow: 0 0 5px #00ff41;
            transition: all 0.3s ease;
            width: 100%;
            text-align: center;
            border-radius: 2px;
            box-shadow: 0 0 0 rgba(0, 255, 65, 0);
        }
        .settings-btn:hover {
            background: rgba(0, 255, 65, 0.15);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.6);
            transform: translateY(-1px);
        }
        .settings-btn:disabled {
            cursor: not-allowed;
            background: rgba(50, 50, 50, 0.5);
            color: #555;
            text-shadow: none;
            border-color: #555;
        }
        .settings-panel {
            position: absolute;
            width: 320px;
            background: linear-gradient(145deg, rgba(0, 20, 0, 0.95), rgba(0, 10, 0, 0.95));
            border: 2px solid #00ff41;
            box-shadow: 0 0 25px rgba(0, 255, 65, 0.4), inset 0 0 20px rgba(0, 255, 65, 0.05);
            z-index: 102;
            border-radius: 4px;
            backdrop-filter: blur(10px);
        }
        .settings-panel.hidden {
            display: none;
        }
        .panel-header {
            color: #00ff41;
            padding: 8px 10px;
            cursor: move;
            font-weight: bold;
            border-bottom: 1px solid #00ff41;
            text-shadow: 0 0 5px #00ff41;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-header .close-btn {
            cursor: pointer;
            font-weight: bold;
        }
        .panel-header .close-btn:hover {
            color: #ff4141;
        }
        .panel-content {
            padding: 15px;
        }
        .panel-content fieldset {
            border: 1px dashed #00ff41;
            padding: 10px;
            margin: 0;
            margin-bottom: 10px;
        }
        .panel-content label {
            display: block;
            margin-bottom: 5px;
            margin-top: 10px;
        }
        #stats-panel-content p {
            margin: 4px 0;
            text-align: left;
        }
        #lang-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        .lang-btn {
            flex-grow: 1;
            font-size: 0.8em;
            padding: 4px;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #00ff41;
            color: #00ff41;
            cursor: pointer;
        }
        .lang-btn.active {
            background: #00ff41;
            color: #000;
            text-shadow: none;
        }
        /* Style de base des curseurs */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: #00ff41;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: 1px solid #00ff41;
            height: 16px;
            width: 16px;
            background: #00ff41;
            cursor: pointer;
            margin-top: -7px;
        }
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: #00ff41;
        }
        input[type=range]::-moz-range-thumb {
            border: 1px solid #00ff41;
            height: 16px;
            width: 16px;
            background: #00ff41;
            cursor: pointer;
        }

        /* Responsive Design for Mobile */
        @media (max-width: 768px) {
            #info {
                padding: 10px;
                font-size: 0.9em;
            }
            #info h1 {
                font-size: 1.3em;
                margin: 0 0 8px 0;
            }
            #info p {
                margin: 0 0 5px 0;
            }
            #stats {
                font-size: 0.75em !important;
            }
            #main-controls-container {
                top: auto;
                bottom: 15px;
                left: 15px;
                flex-direction: row;
                flex-wrap: wrap;
                max-width: calc(100vw - 30px);
                gap: 5px;
            }
            .settings-btn {
                font-size: 0.7em;
                padding: 6px 10px;
                width: auto;
                min-width: 80px;
            }
            .settings-panel {
                width: 95vw;
                max-width: 400px;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%);
                max-height: 80vh;
                overflow-y: auto;
            }
            .panel-content {
                padding: 10px;
            }
            .panel-content label {
                font-size: 0.85em;
            }
        }

        /* Accessibility improvements */
        .settings-btn:focus,
        .settings-panel:focus-within {
            outline: 2px solid #00ff41;
            outline-offset: 2px;
        }
        
        input[type=range]:focus {
            outline: 2px solid #00ff41;
            outline-offset: 2px;
        }
        
        /* Amélioration du contraste pour l'accessibilité */
        .panel-content fieldset legend {
            color: #00ff41;
            font-weight: bold;
        }

        /* Welcome Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        .modal-overlay.hidden {
            display: none;
        }
        .modal-content {
            background: linear-gradient(145deg, rgba(0, 20, 0, 0.95), rgba(0, 10, 0, 0.95));
            border: 2px solid #00ff41;
            border-radius: 8px;
            padding: 0;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 255, 65, 0.6), inset 0 0 30px rgba(0, 255, 65, 0.1);
            animation: modalSlideIn 0.8s ease-out;
        }
        @keyframes modalSlideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .modal-header {
            padding: 20px 25px 15px;
            border-bottom: 1px solid #00ff41;
            position: relative;
        }
        .modal-header h2 {
            color: #00ff41;
            margin: 0;
            font-size: 1.4em;
            text-shadow: 0 0 10px #00ff41;
            font-family: 'Courier New', Courier, monospace;
        }
        .typing-indicator {
            color: #00ff41;
            animation: blink 1s infinite;
            font-size: 1.2em;
            position: absolute;
            right: 25px;
            top: 22px;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        .modal-body {
            padding: 20px 25px;
        }
        .terminal-text {
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.6;
        }
        .terminal-text p {
            margin: 10px 0;
            animation: typeIn 0.5s ease-out;
        }
        @keyframes typeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
            padding: 15px;
            border: 1px dashed #00ff41;
            border-radius: 4px;
            background: rgba(0, 255, 65, 0.05);
        }
        .feature-item {
            display: flex;
            align-items: center;
            gap: 10px;
            animation: fadeInUp 0.6s ease-out;
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .feature-icon {
            font-size: 1.2em;
            filter: hue-rotate(120deg);
        }
        .quick-tips {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #00ff41;
            border-radius: 4px;
            background: rgba(0, 255, 65, 0.08);
        }
        .quick-tips h3 {
            color: #00ff41;
            margin: 0 0 10px 0;
            font-size: 1.1em;
            text-shadow: 0 0 5px #00ff41;
        }
        .quick-tips ul {
            margin: 0;
            padding-left: 0;
            list-style: none;
        }
        .quick-tips li {
            margin: 8px 0;
            animation: slideInLeft 0.4s ease-out;
        }
        @keyframes slideInLeft {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        .modal-footer {
            padding: 15px 25px 20px;
            border-top: 1px solid #00ff41;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        .start-btn {
            background: linear-gradient(145deg, #00ff41, #00cc33);
            border: none;
            color: #000;
            padding: 12px 25px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            font-size: 1em;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: none;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
        }
        .start-btn:hover {
            background: linear-gradient(145deg, #00cc33, #009925);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 65, 0.7);
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            cursor: pointer;
        }
        .checkbox-container input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #00ff41;
        }
        @media (max-width: 768px) {
            .modal-content {
                margin: 10px;
                max-height: 95vh;
            }
            .modal-header, .modal-body, .modal-footer {
                padding: 15px 20px;
            }
            .features-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            .modal-footer {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Welcome Modal -->
    <div id="welcome-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 data-lang-key="welcome_title">BIENVENUE DANS AQUARIUM_TERMINAL.EXE</h2>
                <div class="typing-indicator">_</div>
            </div>
            <div class="modal-body">
                <div class="terminal-text">
                    <p data-lang-key="welcome_intro">>>> INITIALISATION DE LA SIMULATION DE VIE ARTIFICIELLE...</p>
                    <p data-lang-key="welcome_description">Cette simulation interactive présente un écosystème aquatique 3D dynamique. Observez les poissons naître, grandir, se reproduire et mourir, tout en gérant les paramètres de leur environnement.</p>
                    
                    <div class="features-grid">
                        <div class="feature-item">
                            <span class="feature-icon">🌿</span>
                            <span data-lang-key="feature_lifecycle">Cycle de vie complet</span>
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">🎯</span>
                            <span data-lang-key="feature_predation">Système de prédation</span>
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">⚙️</span>
                            <span data-lang-key="feature_controls">Contrôles avancés</span>
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">🌐</span>
                            <span data-lang-key="feature_multilingual">Interface multilingue</span>
                        </div>
                    </div>

                    <div class="quick-tips">
                        <h3 data-lang-key="quick_tips_title">>>> GUIDE RAPIDE:</h3>
                        <ul>
                            <li data-lang-key="tip_explore">• Faites glisser pour explorer l'aquarium 3D</li>
                            <li data-lang-key="tip_fertility">• Ajustez la 'Fécondité' pour contrôler la population</li>
                            <li data-lang-key="tip_predator">• Libérez l'Erpetoichthys pour observer le chaos</li>
                            <li data-lang-key="tip_submarine">• Changez de vue avec la caméra du sous-marin</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button id="start-simulation-btn" class="start-btn" data-lang-key="start_simulation">DÉMARRER LA SIMULATION</button>
                <label class="checkbox-container">
                    <input type="checkbox" id="dont-show-again">
                    <span data-lang-key="dont_show_again">Ne plus afficher</span>
                </label>
            </div>
        </div>
    </div>

    <div id="info">
        <h1 data-lang-key="title">AQUARIUM_TERMINAL.EXE</h1>
        <p data-lang-key="subtitle">🐠 Simulation de vie artificielle • Glissez pour explorer • Cliquez sur les espèces pour configurer</p>
        <div id="stats" style="font-size: 0.9em; margin-top: 8px; opacity: 0.8;">
            <span id="fish-count-label" data-lang-key="fish_count_label">Poissons</span>: <span id="fish-count">0</span> | 
            <span id="predator-count-label" data-lang-key="predator_count_label">Prédateurs</span>: <span id="predator-count">0</span> | 
            <span id="ropefish-status-label" data-lang-key="ropefish_status_label">Erpetoichthys</span>: <span id="ropefish-status" data-lang-key="inactive">INACTIF</span> |
            <span id="fps">FPS: 60</span>
        </div>
    </div>

    <div id="exit-btn" title="Retourner au répertoire parent">[X]</div>
    <div id="main-controls-container"></div>
    <div id="settings-container"></div>

    <script type="module">
        // Importation des modules nécessaires de Three.js
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        // --- Variables globales ---
        let scene, camera, renderer, controls, superPredator, submarine, isSubmarineViewActive = false, isWireframeMode = true;
        let boids = [];
        let eggs = [];
        const rocks = [];
        const plants = [];
        let particles = [];
        const worldSize = { width: 500, height: 250, depth: 350 };
        let aquariumBox;
        let lastFrameTime = 0;
        let highestZIndex = 102; // Pour la gestion des panneaux
        let lastHiddenTime = 0; // Pour la simulation en arrière-plan

        // --- Statistiques ---
        const simulationStats = {
            preyEaten: 0,
            eggsLaid: {},
            babiesHatched: {}
        };

        // --- Paramètres de comportement globaux ---
        const flockingForces = {
            alignment: 0.4,
            cohesion: 0.3,
            separation: 1.2
        };
        
        const environmentSettings = {
            rockCount: 15,
            plantCount: 60
        };

        // --- Configuration des espèces de poissons ---
        const fishSpecies = {
            'cichla': {
                type: 'predator',
                count: 2, color: 0xff4444, scale: 1.4, maxSpeed: 0.7, perceptionRadius: 120,
                riskAssessment: { maxDistance: 150, maxGroupSize: 5 },
                vertices: new Float32Array([0,0,0, -18,0,0, -5,4,0, -5,-4,0, -18,0,0, -25,2,0, -25,-2,0])
            },
            'tetra': {
                type: 'prey',
                count: 50, color: 0xff69b4, scale: 0.45, maxSpeed: 0.4, perceptionRadius: 35, fearRadius: 80, fertility: 0.01,
                vertices: new Float32Array([0,0,0, -6,2.5,0, -12,0,0, 0,0,0, -12,0,0, -6,-2.5,0, -12,0,0, -16,4,0, -16,-4,0])
            },
            'guppy': {
                type: 'prey',
                count: 65, color: 0x00ddff, scale: 0.4, maxSpeed: 0.45, perceptionRadius: 40, fearRadius: 85, fertility: 0.01,
                vertices: new Float32Array([0,0,0, -5,2,0, -10,0,0, 0,0,0, -10,0,0, -5,-2,0, -10,0,0, -14,5,0, -14,-5,0])
            },
            'puffer': {
                type: 'prey',
                count: 30, color: 0xffaa00, scale: 0.5, maxSpeed: 0.3, perceptionRadius: 30, fearRadius: 70, fertility: 0.005,
                vertices: new Float32Array([3,0,0, 0,3,0, -6,0,0, 3,0,0, -6,0,0, 0,-3,0, -6,0,0, -9,0,0, -4,3,0, -6,0,0, -4,-3,0])
            },
            'angel': {
                type: 'prey',
                count: 25, color: 0xaa44ff, scale: 0.6, maxSpeed: 0.35, perceptionRadius: 35, fearRadius: 75, fertility: 0.008,
                vertices: new Float32Array([0,0,0, -5,5,0, -10,0,0, 0,0,0, -10,0,0, -5,-5,0, -10,0,0, -13,3,0, -10,0,0, -13,-3,0])
            }
        };
        
        // --- Internationalisation ---
        const translations = {
            fr: {
                title: "AQUARIUM_TERMINAL.EXE",
                subtitle: "🐠 Simulation de vie artificielle • Glissez pour explorer • Cliquez sur les espèces pour configurer",
                fish_count_label: "Poissons",
                predator_count_label: "Prédateurs",
                ropefish_status_label: "Erpetoichthys",
                active: "ACTIF",
                inactive: "INACTIF",
                mode_wireframe: "MODE: WIREFRAME",
                mode_solid: "MODE: PLEIN",
                view_sub: "VUE SOUS-MARIN",
                view_orbital: "VUE ORBITALE",
                release_ropefish: "LIBÉRER L'ERPETOICHTHYS",
                forces: "FORCES",
                environment: "ENVIRONNEMENT",
                statistics: "STATISTIQUES",
                help_title: "AIDE",
                help_content: "Bienvenue sur AQUARIUM_TERMINAL.EXE. Utilisez les boutons pour ajuster les paramètres. Cliquez sur les noms des espèces pour modifier leur comportement, y compris leur taux de fécondité. Observez le cycle de vie complet des poissons, de l'œuf à l'adulte. Libérez le super-prédateur pour observer le chaos. Changez de vue avec la caméra du sous-marin.",
                prey_eaten: "Proies mangées",
                eggs_laid: "Oeufs pondus",
                babies_hatched: "Bébés nés",
                taux_fecondite: "Taux Fécondité",
                count: "Nombre", scale: "Taille", max_speed: "Vitesse Max", perception_radius: "Rayon Perception", fear_radius: "Rayon Fuite", max_hunt_dist: "Distance Chasse Max", max_group_size: "Taille Groupe Max", rock_count: "Nombre Rochers", plant_count: "Nombre Plantes",
                alignment: "Alignement", cohesion: "Cohésion", separation: "Séparation",
                welcome_title: "BIENVENUE DANS AQUARIUM_TERMINAL.EXE",
                welcome_intro: ">>> INITIALISATION DE LA SIMULATION DE VIE ARTIFICIELLE...",
                welcome_description: "Cette simulation interactive présente un écosystème aquatique 3D dynamique. Observez les poissons naître, grandir, se reproduire et mourir, tout en gérant les paramètres de leur environnement.",
                feature_lifecycle: "Cycle de vie complet",
                feature_predation: "Système de prédation",
                feature_controls: "Contrôles avancés",
                feature_multilingual: "Interface multilingue",
                quick_tips_title: ">>> GUIDE RAPIDE:",
                tip_explore: "• Faites glisser pour explorer l'aquarium 3D",
                tip_fertility: "• Ajustez la 'Fécondité' pour contrôler la population",
                tip_predator: "• Libérez l'Erpetoichthys pour observer le chaos",
                tip_submarine: "• Changez de vue avec la caméra du sous-marin",
                start_simulation: "DÉMARRER LA SIMULATION",
                dont_show_again: "Ne plus afficher"
            },
            en: {
                title: "AQUARIUM_TERMINAL.EXE",
                subtitle: "🐠 Artificial life simulation • Drag to explore • Click on species to configure",
                fish_count_label: "Fish",
                predator_count_label: "Predators",
                ropefish_status_label: "Ropefish",
                active: "ACTIVE",
                inactive: "INACTIVE",
                mode_wireframe: "MODE: WIREFRAME",
                mode_solid: "MODE: SOLID",
                view_sub: "SUBMARINE VIEW",
                view_orbital: "ORBITAL VIEW",
                release_ropefish: "RELEASE THE ROPEFISH",
                forces: "FORCES",
                environment: "ENVIRONMENT",
                statistics: "STATISTICS",
                help_title: "HELP",
                help_content: "Welcome to AQUARIUM_TERMINAL.EXE. Use the buttons to adjust parameters. Click on species names to change their behavior, including their fertility rate. Observe the complete life cycle of the fish, from egg to adult. Release the super-predator to observe chaos. Switch views with the submarine camera.",
                prey_eaten: "Prey Eaten",
                eggs_laid: "Eggs Laid",
                babies_hatched: "Babies Hatched",
                taux_fecondite: "Fertility Rate",
                count: "Count", scale: "Scale", max_speed: "Max Speed", perception_radius: "Perception Radius", fear_radius: "Fear Radius", max_hunt_dist: "Max Hunt Distance", max_group_size: "Max Group Size", rock_count: "Rock Count", plant_count: "Plant Count",
                alignment: "Alignment", cohesion: "Cohesion", separation: "Separation",
                welcome_title: "WELCOME TO AQUARIUM_TERMINAL.EXE",
                welcome_intro: ">>> INITIALIZING ARTIFICIAL LIFE SIMULATION...",
                welcome_description: "This interactive simulation features a dynamic 3D aquatic ecosystem. Watch fish be born, grow, reproduce, and die, while managing their environmental parameters.",
                feature_lifecycle: "Complete life cycle",
                feature_predation: "Predation system",
                feature_controls: "Advanced controls",
                feature_multilingual: "Multilingual interface",
                quick_tips_title: ">>> QUICK GUIDE:",
                tip_explore: "• Drag to explore the 3D aquarium",
                tip_fertility: "• Adjust 'Fertility' to control population growth",
                tip_predator: "• Release the Erpetoichthys to observe chaos",
                tip_submarine: "• Switch views with submarine camera",
                start_simulation: "START SIMULATION",
                dont_show_again: "Don't show again"
            }
        };

        // Check if modal should be shown
        function shouldShowModal() {
            try {
                return !localStorage.getItem('aquarium-welcome-dismissed');
            } catch (e) {
                console.warn("localStorage is not available. Welcome modal will always show.");
                return true;
            }
        }

        // Modal functionality
        function initModal() {
            const modal = document.getElementById('welcome-modal');
            const startBtn = document.getElementById('start-simulation-btn');
            const dontShowCheckbox = document.getElementById('dont-show-again');

            if (!shouldShowModal()) {
                modal.classList.add('hidden');
                return;
            }

            startBtn.addEventListener('click', () => {
                try {
                    if (dontShowCheckbox.checked) {
                        localStorage.setItem('aquarium-welcome-dismissed', 'true');
                    }
                } catch (e) {
                    console.warn("Could not save preference to localStorage.");
                }
                modal.classList.add('hidden');
            });
        }

        function setLanguage(lang) {
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                if (translations[lang] && translations[lang][key]) {
                    el.textContent = translations[lang][key];
                }
            });
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === lang);
            });
        }

        // --- Classe Sous-marin ---
        class Submarine {
            constructor() {
                this.mesh = new THREE.Group();
                const material = new THREE.MeshBasicMaterial({ color: 0xcccccc, wireframe: isWireframeMode });

                const body = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 20, 8), material);
                body.rotation.z = Math.PI / 2;
                this.mesh.add(body);

                const cockpit = new THREE.Mesh(new THREE.SphereGeometry(5, 8, 6), material);
                cockpit.position.x = 5;
                this.mesh.add(cockpit);

                const tail = new THREE.Mesh(new THREE.BoxGeometry(1, 8, 8), material);
                tail.position.x = -12;
                this.mesh.add(tail);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(8, 0, 0); 
                this.mesh.add(this.camera);

                this.position = new THREE.Vector3(0, worldSize.height / 2 + 20, 0);
                this.velocity = new THREE.Vector3(0.3, 0, 0);
                this.acceleration = new THREE.Vector3();
                this.mesh.position.copy(this.position);

                this.maxSpeed = 0.4;
                this.maxForce = 0.01;
                this.target = this.getNewTarget();
            }

            getNewTarget() {
                return new THREE.Vector3(
                    (Math.random() - 0.5) * (worldSize.width - 40),
                    Math.random() * (worldSize.height - 40) + 20,
                    (Math.random() - 0.5) * (worldSize.depth - 40)
                );
            }

            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.setLength(this.maxSpeed);
                let steer = new THREE.Vector3().subVectors(desired, this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }

            update() {
                if (this.position.distanceTo(this.target) < 50) {
                    this.target = this.getNewTarget();
                }

                const seekForce = this.seek(this.target);
                this.acceleration.add(seekForce);

                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.multiplyScalar(0);

                this.checkBounds(); 

                this.mesh.position.lerp(this.position, 0.1);
                
                const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), this.velocity.clone().normalize());
                this.mesh.quaternion.slerp(targetQuaternion, 0.05);
            }

            checkBounds() {
                const margin = 20;
                if (this.position.x < -worldSize.width/2+margin || this.position.x > worldSize.width/2-margin ||
                    this.position.y < margin || this.position.y > worldSize.height-margin ||
                    this.position.z < -worldSize.depth/2+margin || this.position.z > worldSize.depth/2-margin) {
                    this.target = new THREE.Vector3(0, worldSize.height / 2, 0);
                }
            }
        }

        // --- Classe SuperPredator (Erpetoichthys calabaricus) ---
        class Ropefish {
            constructor() {
                this.segmentCount = 30;
                this.segmentSpacing = 3.5;
                this.speed = 0.9;
                this.turnSpeed = 0.04;
                this.attackRadius = 10;
                this.body = new THREE.Group();
                this.segments = [];
                this.path = [];
                this.pathLength = 120;
                this.target = null;
                this.isActive = false;

                const headMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00, wireframe: isWireframeMode });
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff41, wireframe: isWireframeMode });
                const headGeometry = new THREE.SphereGeometry(4, 6, 4);
                const bodyGeometry = new THREE.SphereGeometry(2.5, 6, 4);

                const head = new THREE.Mesh(headGeometry, headMaterial);
                this.segments.push(head);
                this.body.add(head);

                for (let i = 1; i < this.segmentCount; i++) {
                    const segment = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    this.segments.push(segment);
                    this.body.add(segment);
                }
                
                this.velocity = new THREE.Vector3(Math.random() * 2 - 1, 0, Math.random() * 2 - 1);
                this.velocity.normalize().multiplyScalar(this.speed);
            }

            spawn() {
                if (this.isActive) return;
                this.isActive = true;
                const startPos = new THREE.Vector3((Math.random() - 0.5) * worldSize.width * 0.8, 15, (Math.random() - 0.5) * worldSize.depth * 0.8);
                this.segments.forEach(seg => seg.position.copy(startPos));
                this.path = Array(this.pathLength).fill(startPos);
                scene.add(this.body);
                document.getElementById('ropefish-status').setAttribute('data-lang-key', 'active');
                setLanguage(document.documentElement.lang);
            }

            update(boids) {
                if (!this.isActive) return;
                this.findTarget(boids);
                this.move();
                this.checkBounds();
            }

            findTarget(allBoids) {
                if (this.target && this.target.isEaten) this.target = null;
                if (!this.target || Math.random() < 0.01) {
                    let closestBoid = null;
                    let minDistance = Infinity;
                    const aliveBoids = allBoids.filter(b => !b.isEaten && !b.isPredator);
                    if (aliveBoids.length === 0) {
                        this.target = null;
                        return;
                    }
                    for (const boid of aliveBoids) {
                        const d = this.segments[0].position.distanceTo(boid.position);
                        if (d < minDistance) {
                            minDistance = d;
                            closestBoid = boid;
                        }
                    }
                    this.target = closestBoid;
                }
            }

            move() {
                let desiredVelocity = new THREE.Vector3();
                if (this.target) {
                    desiredVelocity.subVectors(this.target.position, this.segments[0].position);
                } else {
                    desiredVelocity.copy(this.velocity);
                    if (Math.random() < 0.05) {
                        desiredVelocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), (Math.random() - 0.5) * Math.PI / 2);
                    }
                }
                
                desiredVelocity.normalize().multiplyScalar(this.speed);
                this.velocity.lerp(desiredVelocity, this.turnSpeed);

                const newHeadPos = this.segments[0].position.clone().add(this.velocity);
                this.path.unshift(newHeadPos);
                if (this.path.length > this.pathLength) this.path.pop();

                for (let i = 0; i < this.segments.length; i++) {
                    const index = Math.floor(Math.min(i * this.segmentSpacing, this.path.length - 1));
                    const point = this.path[index];
                    if (point) this.segments[i].position.lerp(point, 0.5);
                }

                if (this.target && this.segments[0].position.distanceTo(this.target.position) < this.attackRadius) {
                    createEatEffect(this.target.position, 0xFFFF00);
                    this.target.isEaten = true;
                    simulationStats.preyEaten++;
                    this.target = null;
                }
            }
            
            checkBounds() {
                const head = this.segments[0];
                const margin = 10;
                if (head.position.x < -worldSize.width/2+margin) { head.position.x = -worldSize.width/2+margin; this.velocity.x *= -1; }
                else if (head.position.x > worldSize.width/2-margin) { head.position.x = worldSize.width/2-margin; this.velocity.x *= -1; }
                if (head.position.y < margin) { head.position.y = margin; this.velocity.y *= -1; }
                else if (head.position.y > worldSize.height-margin) { head.position.y = worldSize.height-margin; this.velocity.y *= -1; }
                if (head.position.z < -worldSize.depth/2+margin) { head.position.z = -worldSize.depth/2+margin; this.velocity.z *= -1; }
                else if (head.position.z > worldSize.depth/2-margin) { head.position.z = worldSize.depth/2-margin; this.velocity.z *= -1; }
            }
        }

        // --- Classe Egg ---
        class Egg {
            constructor(species, position, color) {
                this.species = species;
                this.hatchTime = 500 + Math.random() * 200; // ~8-12 seconds
                const geometry = new THREE.SphereGeometry(1.5, 6, 4);
                const material = new THREE.MeshBasicMaterial({ color: color, wireframe: isWireframeMode, transparent: true, opacity: 0.8 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                scene.add(this.mesh);
                simulationStats.eggsLaid[this.species]++;
            }

            update() {
                this.hatchTime--;
                if (this.hatchTime <= 0) {
                    return this.hatch();
                }
                return null;
            }

            hatch() {
                const baby = new Boid(this.species, true); // Create one baby fish
                baby.position.copy(this.mesh.position);
                simulationStats.babiesHatched[this.species]++;
                return [baby]; // Return as an array
            }
        }

        // --- Classe Boid ---
        class Boid {
            constructor(species, isBaby = false) {
                this.species = species;
                const config = fishSpecies[species];
                this.isPredator = config.type === 'predator';
                this.maxSpeed = config.maxSpeed;
                this.maxForce = 0.05;
                this.perceptionRadius = config.perceptionRadius;
                this.fearRadius = config.fearRadius || 0;
                
                this.satiation = 0;
                if (this.isPredator) this.satiation = 300;
                this.isEaten = false;

                // Life Cycle properties
                this.adultAge = 800; // ~13 seconds
                this.maxAge = 6000; // ~100 seconds
                this.age = isBaby ? 0 : this.adultAge + 1;
                this.isAdult = !isBaby;
                this.wantsToMate = false;
                this.matingCooldown = Math.random() * 500;
                this.isMating = false;
                this.matingPartner = null;
                this.matingTimer = 0;

                const material = new THREE.MeshBasicMaterial({ color: config.color, wireframe: isWireframeMode, side: THREE.DoubleSide });
                this.mesh = new THREE.Mesh(new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(config.vertices, 3)), material);
                
                const initialScale = isBaby ? config.scale * 0.3 : config.scale;
                this.mesh.scale.set(initialScale, initialScale, initialScale);
                
                if (this.isPredator) {
                    const glowGeometry = new THREE.SphereGeometry(8, 8, 6);
                    const glowMaterial = new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.1, side: THREE.BackSide });
                    this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.mesh.add(this.glow);
                }
                
                this.position = new THREE.Vector3(Math.random()*worldSize.width-worldSize.width/2, Math.random()*(worldSize.height-10)+5, Math.random()*worldSize.depth-worldSize.depth/2);
                this.velocity = new THREE.Vector3(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1);
                this.velocity.setLength(Math.random() * this.maxSpeed * 0.5 + 0.1);
                this.acceleration = new THREE.Vector3();
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            applyForce(force) { this.acceleration.add(force); }
            
            update(allBoids) {
                if (this.isEaten) return;

                this.age++;
                if (!this.isAdult && this.age > this.adultAge) {
                    this.isAdult = true;
                }
                if (!this.isAdult) {
                    const scale = fishSpecies[this.species].scale * (0.3 + 0.7 * (this.age / this.adultAge));
                    this.mesh.scale.set(scale, scale, scale);
                }

                if (this.age > this.maxAge) {
                    this.isEaten = true; // Die of old age
                    return;
                }

                if (this.matingCooldown > 0) {
                    this.matingCooldown--;
                } else if (this.isAdult && !this.isMating && !this.isPredator && !this.wantsToMate) {
                    if (Math.random() < fishSpecies[this.species].fertility) {
                        this.wantsToMate = true;
                    } else {
                        this.matingCooldown = 200 + Math.random() * 200; // Wait a bit before trying again
                    }
                }

                if (this.isMating) {
                    this.mate();
                } else {
                    if (this.wantsToMate) {
                        this.findPartner(allBoids);
                    }
                    if (this.isPredator) this.hunt(allBoids);
                    else this.schoolAndFlee(allBoids);
                }

                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.multiplyScalar(0);

                this.checkBounds();
                this.mesh.position.copy(this.position);
                
                if (this.velocity.lengthSq() > 0.0001) {
                    const lookAtPoint = new THREE.Vector3().addVectors(this.position, this.velocity);
                    this.mesh.lookAt(lookAtPoint);
                    this.mesh.rotateY(-Math.PI / 2);
                }
            }

            findPartner(allBoids) {
                for (const other of allBoids) {
                    if (other !== this && !other.isPredator && other.species === this.species && other.wantsToMate && !other.isMating) {
                        const d = this.position.distanceTo(other.position);
                        if (d < this.perceptionRadius) {
                            this.isMating = true;
                            this.wantsToMate = false;
                            this.matingPartner = other;
                            this.matingTimer = 300; // 5 seconds

                            other.isMating = true;
                            other.wantsToMate = false;
                            other.matingPartner = this;
                            other.matingTimer = 300;
                            return;
                        }
                    }
                }
            }

            mate() {
                this.matingTimer--;

                if (this.matingTimer <= 0 || this.matingPartner.isEaten || !this.matingPartner) {
                    if (this.matingPartner) {
                        this.matingPartner.isMating = false;
                        this.matingPartner.matingCooldown = 1500 + Math.random() * 500;
                    }
                    this.isMating = false;
                    this.matingPartner = null;
                    this.matingCooldown = 1500 + Math.random() * 500;
                    return;
                }
                
                const directionToPartner = new THREE.Vector3().subVectors(this.matingPartner.position, this.position);
                const distance = directionToPartner.length();
                directionToPartner.normalize();

                const tangent = new THREE.Vector3(-directionToPartner.z, 0, directionToPartner.x);
                
                let steerForce = new THREE.Vector3();
                if (distance > 20) {
                    steerForce.add(this.seek(this.matingPartner.position));
                } else {
                    steerForce.add(tangent);
                }
                
                this.applyForce(steerForce.multiplyScalar(0.5));

                if (this.matingTimer === 1) {
                    const eggPosition = new THREE.Vector3().addVectors(this.position, this.matingPartner.position).multiplyScalar(0.5);
                    eggPosition.y = 2;
                    eggs.push(new Egg(this.species, eggPosition, fishSpecies[this.species].color));
                }
            }


            hunt(allBoids) {
                if (this.schoolAndFlee(allBoids, true)) return;
                if (this.satiation > 0) {
                    this.satiation--;
                    this.schoolAndFlee(allBoids, true);
                    return;
                }

                let bestTarget = null;
                let minDistance = Infinity;
                const preyBoids = allBoids.filter(b => !b.isPredator && !b.isEaten);
                const riskConfig = fishSpecies[this.species].riskAssessment;

                for (const potentialTarget of preyBoids) {
                    const d = this.position.distanceTo(potentialTarget.position);
                    if (d > riskConfig.maxDistance || d > minDistance) continue;
                    let groupSize = 0;
                    for (const otherPrey of preyBoids) {
                        if (potentialTarget.position.distanceTo(otherPrey.position) < 25) groupSize++;
                    }
                    if (groupSize > riskConfig.maxGroupSize) continue;
                    minDistance = d;
                    bestTarget = potentialTarget;
                }

                if (bestTarget) {
                    let pursuitForce = this.seek(bestTarget.position);
                    this.applyForce(pursuitForce);
                    if (this.position.distanceTo(bestTarget.position) < 5) {
                        createEatEffect(bestTarget.position, fishSpecies[this.species].color);
                        bestTarget.isEaten = true;
                        simulationStats.preyEaten++;
                        this.satiation = 300;
                    }
                } else {
                    this.schoolAndFlee(allBoids, true);
                }
            }

            schoolAndFlee(allBoids, ignorePredators = false) {
                if (superPredator && superPredator.isActive) {
                    const d = this.position.distanceTo(superPredator.segments[0].position);
                    const superFearRadius = 200;
                    if (d < superFearRadius) {
                        let diff = new THREE.Vector3().subVectors(this.position, superPredator.segments[0].position);
                        diff.normalize().divideScalar(d);
                        let steer = this.seek(this.position.clone().add(diff));
                        steer.multiplyScalar(5.0);
                        this.applyForce(steer);
                        return true;
                    }
                }
                
                if (!this.isPredator && !ignorePredators) {
                    let fleeVector = new THREE.Vector3();
                    let predatorCount = 0;
                    for (const other of allBoids) {
                        if (other.isPredator) {
                            const d = this.position.distanceTo(other.position);
                            if (d > 0 && d < this.fearRadius) {
                                let diff = new THREE.Vector3().subVectors(this.position, other.position);
                                diff.normalize().divideScalar(d);
                                fleeVector.add(diff);
                                predatorCount++;
                            }
                        }
                    }
                    if (predatorCount > 0) {
                        fleeVector.divideScalar(predatorCount);
                        let steer = this.seek(this.position.clone().add(fleeVector));
                        steer.multiplyScalar(2.5);
                        this.applyForce(steer);
                        return true;
                    }
                }
                
                let separation = this.separate(allBoids);
                let alignment = this.align(allBoids);
                let cohesion = this.cohere(allBoids);

                separation.multiplyScalar(flockingForces.separation);
                alignment.multiplyScalar(flockingForces.alignment);
                cohesion.multiplyScalar(flockingForces.cohesion);

                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
                return false;
            }
            
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.setLength(this.maxSpeed);
                let steer = new THREE.Vector3().subVectors(desired, this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }

            separate(boids) {
                let desiredSeparation = 15.0;
                let steer = new THREE.Vector3();
                let count = 0;
                for (let other of boids) {
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < desiredSeparation)) {
                        let diff = new THREE.Vector3().subVectors(this.position, other.position);
                        diff.normalize();
                        diff.divideScalar(d);
                        steer.add(diff);
                        count++;
                    }
                }
                if (count > 0) steer.divideScalar(count);
                if (steer.length() > 0) {
                    steer.setLength(this.maxSpeed);
                    steer.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                }
                return steer;
            }

            align(boids) {
                let sum = new THREE.Vector3();
                let count = 0;
                for (let other of boids) {
                    if (other.species !== this.species) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < this.perceptionRadius)) {
                        sum.add(other.velocity);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.divideScalar(count);
                    sum.setLength(this.maxSpeed);
                    let steer = new THREE.Vector3().subVectors(sum, this.velocity);
                    steer.clampLength(0, this.maxForce);
                    return steer;
                } else {
                    return new THREE.Vector3();
                }
            }

            cohere(boids) {
                let sum = new THREE.Vector3();
                let count = 0;
                for (let other of boids) {
                    if (other.species !== this.species) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < this.perceptionRadius)) {
                        sum.add(other.position);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.divideScalar(count);
                    return this.seek(sum);
                } else {
                    return new THREE.Vector3();
                }
            }

            checkBounds() {
                const margin = 2;
                if (this.position.x < -worldSize.width/2+margin) { this.position.x = -worldSize.width/2+margin; this.velocity.x *= -1; }
                else if (this.position.x > worldSize.width/2-margin) { this.position.x = worldSize.width/2-margin; this.velocity.x *= -1; }
                if (this.position.y < margin) { this.position.y = margin; this.velocity.y *= -1; }
                else if (this.position.y > worldSize.height-margin) { this.position.y = worldSize.height-margin; this.velocity.y *= -1; }
                if (this.position.z < -worldSize.depth/2+margin) { this.position.z = -worldSize.depth/2+margin; this.velocity.z *= -1; }
                else if (this.position.z > worldSize.depth/2-margin) { this.position.z = worldSize.depth/2-margin; this.velocity.z *= -1; }
            }
        }

        // --- Initialisation ---
        init();
        setupUI();
        initModal();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020308);
            
            const ambientLight = new THREE.AmbientLight(0x001122, 0.3);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0x004488, 0.5);
            directionalLight.position.set(0, worldSize.height, worldSize.depth/2);
            scene.add(directionalLight);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 100, 600);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 1500;
            controls.target.set(0, worldSize.height / 2, 0);

            createAquariumBox();
            createFloorGrid();
            createBoids();
            createDecor();
            createPlants();
            superPredator = new Ropefish();
            submarine = new Submarine();
            scene.add(submarine.mesh);
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('visibilitychange', handleVisibilityChange, false);
        }

        // --- Création des éléments de la scène ---
        function createEatEffect(position, color) {
            const particleCount = 20;
            const material = new THREE.LineBasicMaterial({ color: color });
            for (let i = 0; i < particleCount; i++) {
                const vertices = [0,0,0, (Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)];
                const geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const particle = new THREE.Line(geometry, material);
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2),
                    life: 1.0
                };
                particles.push(particle);
                scene.add(particle);
            }
        }

        function createAquariumBox() {
            const geometry = new THREE.BoxGeometry(worldSize.width, worldSize.height, worldSize.depth);
            const wireMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff41, wireframe: true, transparent: true, opacity: 0.4 });
            const solidMaterial = new THREE.MeshBasicMaterial({ color: 0x004488, transparent: true, opacity: 0.1, side: THREE.BackSide });
            aquariumBox = new THREE.Mesh(geometry, wireMaterial);
            aquariumBox.userData.materials = [wireMaterial, solidMaterial];
            aquariumBox.position.set(0, worldSize.height / 2, 0);
            scene.add(aquariumBox);
            createBubbles();
        }
        function createFloorGrid() {
            const gridHelper = new THREE.GridHelper(worldSize.width, 15, 0x00ff41, 0x004411);
            gridHelper.material.opacity = 0.4;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            const topGrid = new THREE.GridHelper(worldSize.width, 15, 0x0088ff, 0x002244);
            topGrid.position.y = worldSize.height;
            topGrid.material.opacity = 0.2;
            topGrid.material.transparent = true;
            scene.add(topGrid);
        }
        function createDecor() {
            while(rocks.length) {
                const rock = rocks.pop();
                scene.remove(rock);
                rock.geometry.dispose();
            }
            const rockMaterial = new THREE.MeshBasicMaterial({ color: 0x00aa33, wireframe: isWireframeMode, transparent: true, opacity: 0.7 });
            for(let i=0; i < environmentSettings.rockCount; i++) {
                const size = Math.random() * 35 + 15;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(size, 1), rockMaterial);
                rock.position.set((Math.random() - 0.5) * (worldSize.width - size * 2), size / 2, (Math.random() - 0.5) * (worldSize.depth - size * 2));
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                scene.add(rock);
                rocks.push(rock);
            }
        }
        function createPlants() {
            while(plants.length) {
                const plant = plants.pop();
                scene.remove(plant);
                plant.geometry.dispose();
            }
            const material = new THREE.LineBasicMaterial({ color: 0x00dd44, transparent: true, opacity: 0.8, linewidth: 2 });
            for (let i = 0; i < environmentSettings.plantCount; i++) {
                const vertices = [];
                const height = Math.random() * 80 + 30;
                vertices.push(0, 0, 0, 0, height, 0);
                for (let j = 0; j < Math.floor(Math.random() * 6) + 4; j++) {
                    const leafH = Math.random() * height * 0.8 + height * 0.2;
                    const leafL = Math.random() * 25 + 15;
                    const angle = Math.random() * Math.PI * 2;
                    const wave = Math.sin(leafH * 0.1) * 5;
                    vertices.push(0, leafH, 0, Math.cos(angle) * leafL + wave, leafH + (Math.random() - 0.5) * 8, Math.sin(angle) * leafL);
                }
                const geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const plant = new THREE.LineSegments(geometry, material);
                plant.position.set((Math.random() - 0.5) * worldSize.width * 0.9, 0, (Math.random() - 0.5) * worldSize.depth * 0.9);
                scene.add(plant);
                plants.push(plant);
            }
        }
        function createBubbles() {
            const bubbleGeometry = new THREE.SphereGeometry(2, 6, 4);
            const bubbleMaterial = new THREE.MeshBasicMaterial({ color: 0x88ddff, transparent: true, opacity: 0.3, wireframe: isWireframeMode });
            for (let i = 0; i < 20; i++) {
                const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                bubble.position.set((Math.random() - 0.5) * worldSize.width * 0.8, Math.random() * worldSize.height * 0.3, (Math.random() - 0.5) * worldSize.depth * 0.8);
                bubble.userData = { velocity: Math.random() * 0.5 + 0.2, oscillation: Math.random() * 0.02 + 0.01 };
                scene.add(bubble);
            }
        }
        function createBoids() {
            while(boids.length) {
                const boid = boids.pop();
                scene.remove(boid.mesh);
            }
            boids = [];
            for (const species in fishSpecies) {
                for (let i = 0; i < fishSpecies[species].count; i++) {
                    boids.push(new Boid(species));
                }
            }
        }
        function updateStats() {
            const aliveBoids = boids.filter(b => !b.isEaten);
            const predators = aliveBoids.filter(b => b.isPredator);
            const prey = aliveBoids.filter(b => !b.isPredator);
            document.getElementById('fish-count').textContent = prey.length;
            document.getElementById('predator-count').textContent = predators.length;
            updateStatsPanel();
        }

        function updateStatsPanel() {
            const preyEatenEl = document.getElementById('stats-prey-eaten');
            if (preyEatenEl) preyEatenEl.textContent = simulationStats.preyEaten;

            for (const species in fishSpecies) {
                const countEl = document.getElementById(`stats-${species}-count`);
                if (countEl) countEl.textContent = boids.filter(b => b.species === species && !b.isEaten).length;
                
                const eggsEl = document.getElementById(`stats-${species}-eggs`);
                if (eggsEl) eggsEl.textContent = simulationStats.eggsLaid[species] || 0;

                const babiesEl = document.getElementById(`stats-${species}-babies`);
                if (babiesEl) babiesEl.textContent = simulationStats.babiesHatched[species] || 0;
            }
        }
        
        function resetSimulation() {
            simulationStats.preyEaten = 0;
            for(const species in fishSpecies) {
                simulationStats.eggsLaid[species] = 0;
                simulationStats.babiesHatched[species] = 0;
            }

            if(superPredator) {
                scene.remove(superPredator.body);
                superPredator.isActive = false;
                document.getElementById('ropefish-status').setAttribute('data-lang-key', 'inactive');
            }
            createBoids();
            setLanguage(document.documentElement.lang);
        }

        // --- UI & Réglages ---
        function createSlider(id, labelKey, min, max, step, value, dataAttributes) {
            const valueId = `${id}-value`;
            const lang = document.documentElement.lang || 'fr';
            const labelText = (translations[lang] && translations[lang][labelKey]) ? translations[lang][labelKey] : labelKey.replace(/_/g, ' ');
            const dataAttrString = Object.entries(dataAttributes).map(([key, val]) => `data-${key}="${val}"`).join(' ');
            return `
                <label for="${id}" data-lang-key="${labelKey}">${labelText}: <span id="${valueId}">${value}</span></label>
                <input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${value}" ${dataAttrString}>
            `;
        }

        function setupUI() {
            const mainControlsContainer = document.getElementById('main-controls-container');
            const settingsContainer = document.getElementById('settings-container');
            mainControlsContainer.innerHTML = '';
            settingsContainer.innerHTML = '';
            resetSimulation(); // Initialize stats objects

            function makeDraggable(panel) {
                const header = panel.querySelector('.panel-header');
                if (!header) return;
                let isDragging = false;
                let offset = { x: 0, y: 0 };
                
                const onMouseDown = (e) => {
                    panel.style.zIndex = ++highestZIndex;
                    isDragging = true;
                    let event = e.touches ? e.touches[0] : e;
                    offset.x = event.clientX - panel.offsetLeft;
                    offset.y = event.clientY - panel.offsetTop;
                    panel.style.cursor = 'grabbing';
                    document.body.style.userSelect = 'none';
                };

                const onMouseMove = (e) => {
                    if (!isDragging) return;
                    let event = e.touches ? e.touches[0] : e;
                    panel.style.left = `${event.clientX - offset.x}px`;
                    panel.style.top = `${event.clientY - offset.y}px`;
                };

                const onMouseUp = () => {
                    isDragging = false;
                    panel.style.cursor = 'default';
                    document.body.style.userSelect = '';
                };

                header.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                header.addEventListener('touchstart', onMouseDown);
                document.addEventListener('touchmove', onMouseMove);
                document.addEventListener('touchend', onMouseUp);
            }

            function createPanel(id, titleKey, contentHtml, position, color) {
                const panel = document.createElement('div');
                panel.id = id;
                panel.className = 'settings-panel hidden';
                panel.style.left = `${position.x}px`;
                panel.style.top = `${position.y}px`;
                const lang = document.documentElement.lang || 'fr';
                const titleText = (translations[lang] && translations[lang][titleKey]) ? translations[lang][titleKey] : titleKey;
                
                const headerStyle = color ? `style="color: ${color}; text-shadow: 0 0 5px ${color};"` : '';

                panel.innerHTML = `
                    <div class="panel-header">
                        <span data-lang-key="${titleKey}" ${headerStyle}>${titleText}</span>
                        <span class="close-btn">[X]</span>
                    </div>
                    <div class="panel-content">${contentHtml}</div>
                `;
                settingsContainer.appendChild(panel);
                panel.addEventListener('mousedown', () => {
                    panel.style.zIndex = ++highestZIndex;
                });
                panel.querySelector('.close-btn').addEventListener('click', () => panel.classList.add('hidden'));
                makeDraggable(panel);
                return panel;
            }
            
            let panelY = 100;
            for (const species in fishSpecies) {
                const config = fishSpecies[species];
                const colorString = `#${config.color.toString(16).padStart(6, '0')}`;
                const btn = document.createElement('button');
                btn.className = 'settings-btn';
                btn.textContent = species.toUpperCase();
                btn.style.color = colorString;
                btn.style.borderColor = colorString;
                btn.style.textShadow = `0 0 8px ${colorString}`;
                
                let content = '<fieldset>';
                content += createSlider(`${species}-count`, 'count', 0, 150, 1, config.count, { category: 'species', species: species, property: 'count', reset: 'true' });
                content += createSlider(`${species}-scale`, 'scale', 0.1, 3, 0.1, config.scale, { category: 'species', species: species, property: 'scale', reset: 'true' });
                content += createSlider(`${species}-maxSpeed`, 'max_speed', 0.1, 2, 0.1, config.maxSpeed, { category: 'species', species: species, property: 'maxSpeed' });
                content += createSlider(`${species}-perceptionRadius`, 'perception_radius', 10, 200, 1, config.perceptionRadius, { category: 'species', species: species, property: 'perceptionRadius' });
                if (config.type === 'prey') {
                    content += createSlider(`${species}-fearRadius`, 'fear_radius', 10, 200, 1, config.fearRadius, { category: 'species', species: species, property: 'fearRadius' });
                    content += createSlider(`${species}-fertility`, 'taux_fecondite', 0, 0.1, 0.001, config.fertility, { category: 'species', species: species, property: 'fertility' });
                }
                if (config.type === 'predator') {
                    content += createSlider(`${species}-maxHuntDist`, 'max_hunt_dist', 50, 300, 5, config.riskAssessment.maxDistance, { category: 'species', species: species, property: 'riskAssessment.maxDistance' });
                    content += createSlider(`${species}-maxGroupSize`, 'max_group_size', 1, 20, 1, config.riskAssessment.maxGroupSize, { category: 'species', species: species, property: 'riskAssessment.maxGroupSize' });
                }
                content += '</fieldset>';

                const panel = createPanel(`${species}-panel`, species, content, { x: 210, y: panelY }, colorString);
                panel.querySelector('.panel-header > span').textContent = species.toUpperCase();
                panelY += 40;

                btn.addEventListener('click', () => {
                    panel.classList.toggle('hidden');
                    panel.style.zIndex = ++highestZIndex;
                });
                mainControlsContainer.appendChild(btn);
            }
            
            const generalButtons = ['forces', 'environment', 'statistics', 'help_title'];
            generalButtons.forEach(key => {
                const btn = document.createElement('button');
                btn.className = 'settings-btn';
                btn.setAttribute('data-lang-key', key);
                mainControlsContainer.appendChild(btn);
                
                let content = '';
                if(key === 'forces') {
                    content += createSlider('alignment', 'alignment', 0, 2, 0.1, flockingForces.alignment, { category: 'flocking', property: 'alignment' });
                    content += createSlider('cohesion', 'cohesion', 0, 2, 0.1, flockingForces.cohesion, { category: 'flocking', property: 'cohesion' });
                    content += createSlider('separation', 'separation', 0, 2, 0.1, flockingForces.separation, { category: 'flocking', property: 'separation' });
                } else if (key === 'environment') {
                    content += createSlider('rockCount', 'rock_count', 0, 50, 1, environmentSettings.rockCount, { category: 'environment', property: 'rockCount', reset: 'decor' });
                    content += createSlider('plantCount', 'plant_count', 0, 100, 1, environmentSettings.plantCount, { category: 'environment', property: 'plantCount', reset: 'plants' });
                } else if (key === 'statistics') {
                    let speciesStatsHtml = '';
                    for (const s in fishSpecies) {
                        if (fishSpecies[s].type === 'prey') {
                            const color = '#' + fishSpecies[s].color.toString(16).padStart(6, '0');
                            speciesStatsHtml += `
                                <fieldset style="border-color: ${color};">
                                    <legend style="color: ${color};">${s.toUpperCase()}</legend>
                                    <p>Population: <span id="stats-${s}-count">0</span></p>
                                    <p><span data-lang-key="eggs_laid">Oeufs</span>: <span id="stats-${s}-eggs">0</span></p>
                                    <p><span data-lang-key="babies_hatched">Bébés</span>: <span id="stats-${s}-babies">0</span></p>
                                </fieldset>
                            `;
                        }
                    }
                    content = `<div id="stats-panel-content">
                        <p><span data-lang-key="prey_eaten">Proies mangées</span>: <span id="stats-prey-eaten">0</span></p>
                        <hr>
                        ${speciesStatsHtml}
                    </div>`;
                } else if (key === 'help_title') {
                    content = `<p data-lang-key="help_content"></p>`;
                }

                const panel = createPanel(`${key}-panel`, key, content, { x: 210, y: panelY });
                panelY += 40;
                btn.addEventListener('click', () => {
                    panel.classList.toggle('hidden');
                    panel.style.zIndex = ++highestZIndex;
                });
            });
            
            const otherControls = [
                { key: 'mode_wireframe', action: (event) => {
                    isWireframeMode = !isWireframeMode;
                    const materials = [
                        ...boids.map(b => b.mesh.material),
                        ...rocks.map(r => r.material),
                        superPredator.segments[0].material,
                        ...superPredator.segments.slice(1).map(s => s.material),
                        ...scene.children.filter(c => c.userData.velocity && !c.userData.life).map(b => b.material)
                    ];
                    materials.forEach(m => { if(m) m.wireframe = isWireframeMode; });
                    aquariumBox.material = isWireframeMode ? aquariumBox.userData.materials[0] : aquariumBox.userData.materials[1];
                    event.target.setAttribute('data-lang-key', isWireframeMode ? 'mode_wireframe' : 'mode_solid');
                    setLanguage(document.documentElement.lang);
                }},
                { key: 'view_orbital', action: (event) => {
                    isSubmarineViewActive = !isSubmarineViewActive;
                    submarine.mesh.visible = !isSubmarineViewActive;
                    event.target.setAttribute('data-lang-key', isSubmarineViewActive ? 'view_sub' : 'view_orbital');
                    setLanguage(document.documentElement.lang);
                }},
                { key: 'release_ropefish', action: () => superPredator.spawn() }
            ];
            otherControls.forEach(ctrl => {
                const btn = document.createElement('button');
                btn.className = 'settings-btn';
                btn.setAttribute('data-lang-key', ctrl.key);
                btn.addEventListener('click', ctrl.action);
                mainControlsContainer.appendChild(btn);
            });
            
            const langSelector = document.createElement('div');
            langSelector.id = 'lang-selector';
            langSelector.innerHTML = `
                <button class="lang-btn active" data-lang="fr">FR</button>
                <button class="lang-btn" data-lang="en">EN</button>
            `;
            mainControlsContainer.appendChild(langSelector);
            langSelector.addEventListener('click', (e) => {
                if(e.target.tagName === 'BUTTON') {
                    setLanguage(e.target.dataset.lang);
                }
            });
            
            settingsContainer.addEventListener('input', (e) => {
                if (e.target.type !== 'range') return;
                const target = e.target;
                const value = parseFloat(target.value);
                const valueSpan = document.getElementById(`${target.id}-value`);
                if (valueSpan) {
                    valueSpan.textContent = value.toFixed(target.id.includes('fertility') ? 3 : (target.step < 1 ? 1 : 0));
                }
                const { category, species, property, reset } = target.dataset;
                if (category === 'species') {
                    if (property.includes('.')) {
                        const [prop, subProp] = property.split('.');
                        fishSpecies[species][prop][subProp] = value;
                    } else {
                        fishSpecies[species][property] = value;
                    }
                } else if (category === 'flocking') {
                    flockingForces[property] = value;
                } else if (category === 'environment') {
                    environmentSettings[property] = value;
                }
                if (reset === 'true') {
                    resetSimulation();
                } else if (reset === 'decor') {
                    createDecor();
                } else if (reset === 'plants') {
                    createPlants();
                }
            });

            setLanguage('fr');
        }

        // --- Animation loop and other functions ---
        function animate(time) {
            requestAnimationFrame(animate);
            
            if (lastFrameTime > 0) {
                const deltaTime = time - lastFrameTime;
                const fps = Math.round(1000 / deltaTime);
                if (isFinite(fps)) {
                    document.getElementById('fps').textContent = `FPS: ${fps}`;
                }
            }
            lastFrameTime = time;

            // Update eggs and hatch new boids
            let newBoids = [];
            for (let i = eggs.length - 1; i >= 0; i--) {
                const egg = eggs[i];
                const hatchedBoids = egg.update();
                if (hatchedBoids) {
                    newBoids.push(...hatchedBoids);
                    scene.remove(egg.mesh);
                    eggs.splice(i, 1);
                }
            }
            if (newBoids.length > 0) {
                boids.push(...newBoids);
            }

            scene.children.forEach(child => {
                if (child.userData && child.userData.velocity && !child.userData.life) { // Bubbles
                    child.position.y += child.userData.velocity;
                    child.position.x += Math.sin(Date.now() * child.userData.oscillation) * 0.1;
                    if (child.position.y > worldSize.height) {
                        child.position.y = 0;
                        child.position.x = (Math.random() - 0.5) * worldSize.width * 0.8;
                        child.position.z = (Math.random() - 0.5) * worldSize.depth * 0.8;
                    }
                }
            });

            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.position.add(particle.userData.velocity);
                particle.userData.life -= 0.05;
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            }
            
            if (superPredator) superPredator.update(boids);
            if (submarine) submarine.update();
            boids.forEach(boid => boid.update(boids));

            for (let i = boids.length - 1; i >= 0; i--) {
                if (boids[i].isEaten) {
                    scene.remove(boids[i].mesh);
                    boids[i].mesh.geometry.dispose();
                    if(boids[i].mesh.material.dispose) boids[i].mesh.material.dispose();
                    boids.splice(i, 1);
                }
            }

            if (Math.random() < 0.05) {
                updateStats();
            }

            if (!isSubmarineViewActive) {
                controls.update();
            }
            
            const activeCamera = isSubmarineViewActive ? submarine.camera : camera;
            renderer.render(scene, activeCamera);
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            if (submarine) {
                submarine.camera.aspect = window.innerWidth / window.innerHeight;
                submarine.camera.updateProjectionMatrix();
            }
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function catchUpSimulation(seconds) {
            const missedFrames = Math.round(seconds * 60); // Assuming 60fps
            if (missedFrames <= 0) return;

            console.log(`Catching up ${missedFrames} frames...`);

            // Fast-forward life cycle aspects
            boids.forEach(boid => {
                boid.age += missedFrames;
                boid.matingCooldown = Math.max(0, boid.matingCooldown - missedFrames);
                // Approximate movement
                boid.position.addScaledVector(boid.velocity, seconds);
                boid.checkBounds(); // Simple boundary check
            });

            let newBoidsFromHatching = [];
            for (let i = eggs.length - 1; i >= 0; i--) {
                const egg = eggs[i];
                egg.hatchTime -= missedFrames;
                if (egg.hatchTime <= 0) {
                    const hatched = egg.hatch();
                    if(hatched) newBoidsFromHatching.push(...hatched);
                    scene.remove(egg.mesh);
                    eggs.splice(i, 1);
                }
            }
            if(newBoidsFromHatching.length > 0) {
                boids.push(...newBoidsFromHatching);
            }
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                lastHiddenTime = performance.now();
            } else {
                if (lastHiddenTime > 0) {
                    const elapsedTime = (performance.now() - lastHiddenTime) / 1000;
                    catchUpSimulation(elapsedTime);
                }
                lastHiddenTime = 0;
            }
        }
    </script>
</body>
</html>
