<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPPD Neuro-Rehab | Global Edition</title>
    <style>
        :root {
            --bg-color: #050505;
            --panel-bg: rgba(18, 18, 18, 0.98);
            --text-main: #e0e0e0;
            --text-muted: #888;
            --accent: #2ecc71;     /* Green */
            --danger: #e74c3c;     /* Red */
            --warning: #f1c40f;    /* Yellow */
            --border: #333;
            --input-bg: #252525;
        }

        * { box-sizing: border-box; user-select: none; }

        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Inter, system-ui, sans-serif;
            color: var(--text-main);
        }

        /* --- CANVAS --- */
        #canvas-wrapper { position: absolute; inset: 0; z-index: 1; }
        canvas { display: block; }

        /* --- COGNITIVE OVERLAY --- */
        #cognitive-overlay {
            position: absolute; top: 15%; left: 50%;
            transform: translateX(-50%);
            font-size: 3rem; font-weight: 700;
            color: rgba(255, 255, 255, 0.4);
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            z-index: 5; pointer-events: none; display: none;
            font-variant-numeric: tabular-nums;
        }

        /* --- UI PANEL --- */
        #ui-panel {
            position: absolute; top: 20px; left: 20px;
            width: 380px; height: calc(100vh - 40px);
            background: var(--panel-bg);
            border: 1px solid var(--border);
            border-radius: 12px; z-index: 100;
            display: flex; flex-direction: column;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.3s;
            /* CRITICAL FIX: Overflow hidden prevents children from bleeding out of rounded corners */
            overflow: hidden; 
        }
        #ui-panel.collapsed { transform: translateX(-400px); }
        #ui-panel.hidden { display: none; } /* Used in VR mode */

        .panel-header {
            padding: 20px; border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
            flex-shrink: 0; /* Header size fixed */
        }
        .timer { font-family: monospace; font-size: 1.8rem; color: var(--accent); font-weight: bold; }
        .toggle-handle {
            position: absolute; right: -30px; top: 20px;
            width: 30px; height: 40px;
            background: var(--panel-bg);
            border: 1px solid var(--border); border-left: none;
            border-radius: 0 8px 8px 0;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; color: var(--text-muted);
            /* Handle must be outside the overflow:hidden panel, so we might need a wrapper or absolute positioning tweaks if we strictly clip panel.
               Actually, overflow:hidden cuts the handle if it's a child. 
               Correction: We apply overflow:hidden to content areas or use border-radius on children.
               Let's keep overflow hidden on panel but move handle outside via JS or CSS trick?
               Simpler: Let's apply border-radius to footer and header instead of overflow hidden on parent if handle breaks.
               BUT handle is absolute right: -30px. Overflow hidden WILL hide it.
               Revert overflow:hidden on parent. Apply distinct border-radius to footer.
            */
            z-index: 101;
        }

        /* Re-applying border radius logic to children to allow handle to stick out */
        .panel-header { border-radius: 12px 12px 0 0; }
        
        .panel-content { flex: 1; overflow-y: auto; padding: 20px; }
        
        .panel-footer {
            padding: 15px; /* Reduced padding for better fit */
            border-top: 1px solid var(--border);
            background: rgba(0,0,0,0.3);
            flex-shrink: 0; /* Footer size fixed */
            border-radius: 0 0 12px 12px;
        }

        .control-section { margin-bottom: 20px; border-bottom: 1px solid #222; padding-bottom: 15px; }
        .section-title { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px; color: var(--accent); margin-bottom: 12px; display: block; font-weight: bold; }
        label { display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 6px; color: #bbb; }
        .val-display { color: var(--accent); font-family: monospace; }
        input[type="range"] { width: 100%; margin-bottom: 10px; accent-color: var(--accent); }
        select { width: 100%; background: var(--input-bg); color: white; border: 1px solid #444; padding: 8px; border-radius: 6px; outline: none; font-size: 0.85rem; }
        
        .btn-group { display: flex; gap: 8px; /* Tighter gap */ }
        .btn { 
            flex: 1; 
            padding: 10px 4px; /* Reduced horizontal padding */
            border: none; border-radius: 6px; 
            font-weight: 700; cursor: pointer; text-transform: uppercase; 
            font-size: 0.75rem; /* Slightly smaller text to prevent overflow */
            transition: filter 0.2s; 
            white-space: nowrap; 
            overflow: hidden; text-overflow: ellipsis; /* Safety against text overflow */
        }
        .btn:hover { filter: brightness(1.2); }
        .btn-start { background: var(--accent); color: #000; }
        .btn-stop { background: var(--danger); color: white; }
        .btn-vr { background: #9b59b6; color: white; } /* Purple for VR */
        .btn-secondary { background: #333; color: white; font-size: 0.75rem; padding: 8px; }

        /* --- HISTORY --- */
        #history-container { font-size: 0.75rem; color: #888; max-height: 150px; overflow-y: auto; margin-top: 10px; }
        .log-entry { display: flex; justify-content: space-between; padding: 6px; border-bottom: 1px solid #222; }
        .score-bad { color: var(--accent); } 
        .score-good { color: var(--warning); }
        .score-danger { color: var(--danger); font-weight: bold; }

        /* --- MODALS --- */
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.95);
            z-index: 2000; display: none; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
        }
        .modal-overlay.active { display: flex; }
        .modal-box {
            background: #111; border: 1px solid var(--border); padding: 30px;
            border-radius: 16px; max-width: 500px; width: 90%; text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .modal-warning { border-color: var(--danger); }
        .warning-title { color: var(--danger); font-size: 1.5rem; margin-top: 0; }
        
        /* Language Selector */
        .lang-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 20px; }
        .lang-btn {
            background: #222; border: 1px solid #444; color: #888; padding: 8px;
            border-radius: 4px; cursor: pointer; font-weight: bold;
        }
        .lang-btn.active { background: var(--accent); color: #000; border-color: var(--accent); }

        .borg-grid { display: grid; grid-template-columns: repeat(11, 1fr); gap: 4px; margin: 20px 0; }
        .borg-btn {
            background: #222; border: 1px solid #444; color: #fff; padding: 10px 0;
            border-radius: 4px; cursor: pointer; transition: all 0.2s;
        }
        .borg-btn:hover { background: var(--accent); color: #000; transform: scale(1.1); }
        
        .advice-text { margin-top: 15px; padding: 10px; background: rgba(241, 196, 15, 0.1); border-left: 3px solid var(--warning); color: #ddd; font-size: 0.9rem; text-align: left; }

        /* VR Overlay Instruction */
        #vr-instruction {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.5rem; text-align: center;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
            display: none; z-index: 3000; pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- OVERLAY: AVERTISSEMENT / LANGUE -->
    <div id="modal-warning" class="modal-overlay active modal-warning">
        <div class="modal-box">
            <div class="lang-grid">
                <button class="lang-btn active" onclick="setLang('en')">EN</button>
                <button class="lang-btn" onclick="setLang('fr')">FR</button>
                <button class="lang-btn" onclick="setLang('es')">ES</button>
                <button class="lang-btn" onclick="setLang('de')">DE</button>
            </div>

            <h2 class="warning-title" data-i18n="warn_title">⚠️ IMPORTANT DISCLAIMER</h2>
            <p style="color: #bbb; line-height: 1.6; text-align: left;" id="warn-text">
                <!-- Content injected via JS -->
            </p>
            <div style="margin-top: 20px; font-size: 0.8rem; color: #666;" data-i18n="warn_ack">
                By clicking below, you accept full responsibility for using this tool.
            </div>
            <button id="btn-accept" class="btn btn-start" style="margin-top: 20px; width: 100%;" data-i18n="btn_enter">ACCEPT & ENTER</button>
        </div>
    </div>

    <!-- OVERLAY: FIN DE SESSION (BORG) -->
    <div id="modal-borg" class="modal-overlay">
        <div class="modal-box" style="border-color: var(--accent);">
            <h3 style="color: var(--accent); margin-top:0;" data-i18n="session_end">SESSION COMPLETE</h3>
            <p style="color: #ccc;" data-i18n="rate_dizziness">Rate your dizziness / discomfort</p>
            <div class="borg-grid" id="borg-container"></div>
            <div id="progression-feedback" class="advice-text" style="display:none;"></div>
        </div>
    </div>

    <div id="cognitive-overlay"></div>
    <div id="vr-instruction">TAP SCREEN TO EXIT VR</div>

    <!-- UI PANEL -->
    <div id="ui-panel">
        <div class="toggle-handle" id="ui-toggle">⚙️</div>
        <div class="panel-header">
            <div style="font-size: 0.8rem; font-weight: 700; color:#fff;">PPPD REHAB <span style="color:var(--accent)">PRO</span></div>
            <div class="timer" id="timer-display">00:00</div>
        </div>

        <div class="panel-content">
            <!-- 1. Protocols -->
            <div class="control-section">
                <span class="section-title" data-i18n="sec_protocols">1. Protocols & Safety</span>
                <select id="preset-select"></select>
                <!-- Buttons moved to footer -->
            </div>

            <!-- 2. Visual -->
            <div class="control-section">
                <span class="section-title" data-i18n="sec_visual">2. Optokinetic Stimulus</span>
                <label><span data-i18n="lbl_speed">Speed</span> <span class="val-display" id="val-speed">20</span></label>
                <input type="range" id="inp-speed" min="0" max="120" value="20">
                
                <label data-i18n="lbl_flow">Flow Type</label>
                <select id="inp-flow"></select>

                <label data-i18n="lbl_bg">Background</label>
                <select id="inp-bg"></select>
            </div>

            <!-- 3. Perturbations -->
            <div class="control-section">
                <span class="section-title" data-i18n="sec_perturb">3. Vestibular Perturbations</span>
                <label><span data-i18n="lbl_tilt">Horizon Tilt</span> <span class="val-display" id="val-tilt">0°</span></label>
                <input type="range" id="inp-tilt" min="0" max="20" value="0">
                <label><span data-i18n="lbl_drift">Drift</span> <span class="val-display" id="val-drift">0%</span></label>
                <input type="range" id="inp-drift" min="0" max="100" value="0">
                <label><span data-i18n="lbl_asym">Asymmetry L/R</span> <span class="val-display" id="val-asym">0</span></label>
                <input type="range" id="inp-asym" min="-50" max="50" value="0">
                <label><span data-i18n="lbl_flicker">Flicker</span> <span class="val-display" id="val-flicker">OFF</span></label>
                <input type="range" id="inp-flicker" min="0" max="30" value="0">
            </div>

            <!-- 4. Cognition -->
            <div class="control-section">
                <span class="section-title" data-i18n="sec_anchors">4. Foveal & Cognitive</span>
                <label data-i18n="lbl_target">Target / Fixation</label>
                <select id="inp-target"></select>
                <label data-i18n="lbl_dual">Dual Task</label>
                <select id="inp-cognitive"></select>
            </div>

            <!-- 5. History -->
            <div class="control-section">
                <span class="section-title" data-i18n="sec_history">5. Logbook</span>
                <div class="btn-group">
                    <button id="btn-export" class="btn btn-secondary" data-i18n="btn_csv">Export CSV</button>
                    <button id="btn-clear" class="btn btn-secondary" style="color:var(--danger)" data-i18n="btn_reset">Reset</button>
                </div>
                <div id="history-container"></div>
            </div>
        </div>

        <!-- FIXED FOOTER -->
        <div class="panel-footer">
            <div class="btn-group">
                <button id="btn-start" class="btn btn-start" data-i18n="btn_start">START</button>
                <button id="btn-vr" class="btn btn-vr" data-i18n="btn_vr">VR (CARDBOARD)</button>
                <button id="btn-stop" class="btn btn-stop" data-i18n="btn_stop">STOP</button>
            </div>
            <div class="key-hint" style="text-align:center; margin-top:10px; font-size:0.7rem; color:#666;" data-i18n="hint_space">SPACEBAR = EMERGENCY STOP</div>
        </div>
    </div>

    <div id="canvas-wrapper"><canvas id="app-canvas"></canvas></div>

    <script>
        const API_KEY = ""; 

        // --- I18N SYSTEM ---
        const I18N = {
            en: {
                warn_title: "⚠️ IMPORTANT DISCLAIMER",
                warn_text: "<strong>This is NOT medical advice.</strong> Consult a doctor for any health issues. This is a wellness tool.<br><br><strong>THE STRATEGY:</strong> You must trigger <em>slight discomfort</em> to progress.<br>• <strong>Too easy:</strong> No brain learning.<br>• <strong>Too hard:</strong> Panic & relapse.<br>• <strong>Goal:</strong> Tolerable dizziness (3-4/10).",
                warn_ack: "By entering, you accept full responsibility.",
                btn_enter: "I UNDERSTAND & ACCEPT",
                session_end: "SESSION COMPLETE",
                rate_dizziness: "Rate your dizziness / discomfort",
                sec_protocols: "1. Protocols & Safety",
                sec_visual: "2. Optokinetic Stimulus",
                sec_perturb: "3. Vestibular Perturbations",
                sec_anchors: "4. Foveal & Cognitive",
                sec_history: "5. Logbook",
                btn_start: "START",
                btn_stop: "STOP",
                btn_vr: "VR (CARDBOARD)",
                btn_csv: "Export CSV",
                btn_reset: "Reset",
                hint_space: "SPACEBAR = EMERGENCY STOP",
                lbl_speed: "Global Speed",
                lbl_flow: "Flow Type",
                lbl_bg: "Background",
                lbl_tilt: "Horizon Tilt",
                lbl_drift: "Drift",
                lbl_asym: "Asymmetry L/R",
                lbl_flicker: "Flicker",
                lbl_target: "Target / Fixation",
                lbl_dual: "Dual Task",
                // Select Options
                opt_manual: "-- Manual Settings --",
                opt_p1: "Lvl 1: Stabilize (Soft)",
                opt_p2: "Lvl 2: Integrate (Active)",
                opt_p3: "Lvl 3: Chaos (Challenge)",
                opt_p4: "Test: Max Provocation",
                opt_flow_h: "Horizontal Translation",
                opt_flow_v: "Vertical Translation",
                opt_flow_r: "Rotation (Roll)",
                opt_flow_e: "Expansion (Tunnel)",
                opt_flow_mix_hr: "Mix: H + Rotation",
                opt_flow_mix_er: "Mix: Exp + Rotation",
                opt_bg_black: "Black (Neutral)",
                opt_bg_noise: "Snow (Noise)",
                opt_bg_grid: "Grid (Perspective)",
                opt_bg_checker: "Checkerboard (Provocation)",
                opt_bg_moire: "Moire (Interference)",
                opt_tgt_static: "Static Red Dot",
                opt_tgt_dynamic: "Dynamic (Color/Shape)",
                opt_tgt_pursuit: "Pursuit (Moving)",
                opt_tgt_saccade: "Saccades (Jumps)",
                opt_tgt_anti: "Anti-Flow (Opposition)",
                opt_tgt_mask_c: "Center Mask (Force Periph)",
                opt_tgt_mask_p: "Peripheral Mask (Tunnel)",
                opt_cog_off: "None",
                opt_cog_math: "Visual Math",
                opt_cog_audio: "Audio (TTS)",
                // Advice
                adv_low: "<strong>ADVICE:</strong> Too easy. Increase speed or drift.",
                adv_high: "<strong>ADVICE:</strong> Too intense. Reduce flicker or speed.",
                adv_ok: "<strong>PERFECT:</strong> You are in the plasticity zone.",
                tts_prompt: "Say clearly"
            },
            fr: {
                warn_title: "⚠️ AVERTISSEMENT IMPORTANT",
                warn_text: "<strong>Ceci n'est PAS un acte médical.</strong> Outil de bien-être uniquement. Consultez un médecin si besoin.<br><br><strong>LA MÉTHODE :</strong> Vous devez provoquer un <em>léger inconfort</em> pour progresser.<br>• <strong>Trop facile :</strong> Inutile, le cerveau n'apprend pas.<br>• <strong>Trop fort :</strong> Nuisible, risque de rechute.<br>• <strong>Objectif :</strong> Inconfort tolérable (3-4/10).",
                warn_ack: "En entrant, vous acceptez la responsabilité.",
                btn_enter: "J'AI COMPRIS & J'ACCEPTE",
                session_end: "SESSION TERMINÉE",
                rate_dizziness: "Notez votre vertige / inconfort",
                sec_protocols: "1. Protocoles & Sécurité",
                sec_visual: "2. Stimulus Optocinétique",
                sec_perturb: "3. Perturbations Vestibulaires",
                sec_anchors: "4. Ancrage & Cognition",
                sec_history: "5. Journal de Bord",
                btn_start: "DÉMARRER",
                btn_stop: "ARRÊT",
                btn_vr: "VR (CARDBOARD)",
                btn_csv: "Export CSV",
                btn_reset: "RAZ",
                hint_space: "ESPACE = ARRÊT D'URGENCE",
                lbl_speed: "Vitesse Globale",
                lbl_flow: "Type de Flux",
                lbl_bg: "Fond Complexe",
                lbl_tilt: "Inclinaison",
                lbl_drift: "Dérive",
                lbl_asym: "Asymétrie G/D",
                lbl_flicker: "Scintillement",
                lbl_target: "Cible / Fixation",
                lbl_dual: "Double Tâche",
                opt_manual: "-- Manuel --",
                opt_p1: "Niv 1: Stabilisation (Douce)",
                opt_p2: "Niv 2: Intégration (Active)",
                opt_p3: "Niv 3: Chaos (Défi)",
                opt_p4: "Test: Provocation Max",
                opt_flow_h: "Translation Horizontale",
                opt_flow_v: "Translation Verticale",
                opt_flow_r: "Rotation (Roulis)",
                opt_flow_e: "Expansion (Tunnel)",
                opt_flow_mix_hr: "Mix: H + Rotation",
                opt_flow_mix_er: "Mix: Exp + Rotation",
                opt_bg_black: "Noir (Neutre)",
                opt_bg_noise: "Neige (Grain)",
                opt_bg_grid: "Grille (Perspective)",
                opt_bg_checker: "Damier (Provocation)",
                opt_bg_moire: "Moiré (Interférence)",
                opt_tgt_static: "Point Rouge Fixe",
                opt_tgt_dynamic: "Dynamique (Couleur/Forme)",
                opt_tgt_pursuit: "Poursuite (Mobile)",
                opt_tgt_saccade: "Saccades (Sauts)",
                opt_tgt_anti: "Anti-Flux (Opposition)",
                opt_tgt_mask_c: "Masque Central (Force Périph)",
                opt_tgt_mask_p: "Masque Périph (Tunnel)",
                opt_cog_off: "Aucune",
                opt_cog_math: "Calcul Visuel",
                opt_cog_audio: "Audio (Synthèse)",
                adv_low: "<strong>CONSEIL:</strong> Trop facile. Augmentez la vitesse.",
                adv_high: "<strong>CONSEIL:</strong> Trop intense. Réduisez la charge.",
                adv_ok: "<strong>PARFAIT:</strong> Zone de plasticité optimale.",
                tts_prompt: "Dites clairement"
            },
            es: {
                warn_title: "⚠️ AVISO IMPORTANTE",
                warn_text: "<strong>Esto NO es consejo médico.</strong> Consulte a un médico. Es una herramienta de bienestar.<br><br><strong>EL MÉTODO:</strong> Debe provocar una <em>ligera incomodidad</em> para progresar.<br>• <strong>Muy fácil:</strong> Inútil, el cerebro no aprende.<br>• <strong>Muy fuerte:</strong> Dañino, riesgo de recaída.<br>• <strong>Objetivo:</strong> Incomodidad tolerable (3-4/10).",
                warn_ack: "Al entrar, acepta la responsabilidad.",
                btn_enter: "ENTIENDO Y ACEPTO",
                session_end: "SESIÓN COMPLETADA",
                rate_dizziness: "Evalúe su mareo / incomodidad",
                sec_protocols: "1. Protocolos y Seguridad",
                sec_visual: "2. Estímulo Optocinético",
                sec_perturb: "3. Perturbaciones Vestibulares",
                sec_anchors: "4. Anclaje y Cognición",
                sec_history: "5. Diario",
                btn_start: "INICIAR",
                btn_stop: "PARAR",
                btn_vr: "VR (CARDBOARD)",
                btn_csv: "Exportar CSV",
                btn_reset: "Reiniciar",
                hint_space: "ESPACIO = PARADA EMERGENCIA",
                lbl_speed: "Velocidad",
                lbl_flow: "Tipo de Flujo",
                lbl_bg: "Fondo",
                lbl_tilt: "Inclinación",
                lbl_drift: "Deriva",
                lbl_asym: "Asimetría I/D",
                lbl_flicker: "Parpadeo",
                lbl_target: "Objetivo / Fijación",
                lbl_dual: "Doble Tarea",
                opt_manual: "-- Manual --",
                opt_p1: "Niv 1: Estabilizar (Suave)",
                opt_p2: "Niv 2: Integrar (Activo)",
                opt_p3: "Niv 3: Caos (Desafío)",
                opt_p4: "Test: Provocación Max",
                opt_flow_h: "Traslación Horizontal",
                opt_flow_v: "Traslación Vertical",
                opt_flow_r: "Rotación (Roll)",
                opt_flow_e: "Expansión (Túnel)",
                opt_flow_mix_hr: "Mix: H + Rotación",
                opt_flow_mix_er: "Mix: Exp + Rotación",
                opt_bg_black: "Negro (Neutro)",
                opt_bg_noise: "Nieve (Ruido)",
                opt_bg_grid: "Rejilla",
                opt_bg_checker: "Tablero (Provocación)",
                opt_bg_moire: "Moiré (Interferencia)",
                opt_tgt_static: "Punto Rojo Fijo",
                opt_tgt_dynamic: "Dinámico (Color/Forma)",
                opt_tgt_pursuit: "Persecución (Móvil)",
                opt_tgt_saccade: "Sacadas (Saltos)",
                opt_tgt_anti: "Anti-Flujo (Oposición)",
                opt_tgt_mask_c: "Máscara Central",
                opt_tgt_mask_p: "Máscara Periférica",
                opt_cog_off: "Ninguna",
                opt_cog_math: "Cálculo Visual",
                opt_cog_audio: "Audio (TTS)",
                adv_low: "<strong>CONSEJO:</strong> Muy fácil. Aumente la velocidad.",
                adv_high: "<strong>CONSEJO:</strong> Muy intenso. Reduzca la carga.",
                adv_ok: "<strong>PERFECTO:</strong> Zona de plasticidad óptima.",
                tts_prompt: "Diga claramente"
            },
            de: {
                warn_title: "⚠️ WICHTIGER HINWEIS",
                warn_text: "<strong>Dies ist KEIN medizinischer Rat.</strong> Wellness-Tool. Bei Problemen Arzt aufsuchen.<br><br><strong>DIE METHODE:</strong> Sie müssen <em>leichtes Unbehagen</em> auslösen, um Fortschritte zu machen.<br>• <strong>Zu einfach:</strong> Nutzlos.<br>• <strong>Zu stark:</strong> Schädlich (Rückfall).<br>• <strong>Ziel:</strong> Tolerierbarer Schwindel (3-4/10).",
                warn_ack: "Mit dem Eintreten übernehmen Sie die Verantwortung.",
                btn_enter: "VERSTANDEN & AKZEPTIEREN",
                session_end: "SITZUNG BEENDET",
                rate_dizziness: "Bewerten Sie Ihren Schwindel",
                sec_protocols: "1. Protokolle & Sicherheit",
                sec_visual: "2. Optokinetischer Reiz",
                sec_perturb: "3. Vestibuläre Störungen",
                sec_anchors: "4. Verankerung & Kognition",
                sec_history: "5. Logbuch",
                btn_start: "START",
                btn_stop: "STOPP",
                btn_vr: "VR (CARDBOARD)",
                btn_csv: "CSV Export",
                btn_reset: "Reset",
                hint_space: "LEERTASTE = NOT-AUS",
                lbl_speed: "Geschwindigkeit",
                lbl_flow: "Flussart",
                lbl_bg: "Hintergrund",
                lbl_tilt: "Neigung",
                lbl_drift: "Drift",
                lbl_asym: "Asymmetrie L/R",
                lbl_flicker: "Flimmern",
                lbl_target: "Ziel / Fixierung",
                lbl_dual: "Doppelaufgabe",
                opt_manual: "-- Manuell --",
                opt_p1: "Lvl 1: Stabilisieren",
                opt_p2: "Lvl 2: Integrieren",
                opt_p3: "Lvl 3: Chaos",
                opt_p4: "Test: Max Provokation",
                opt_flow_h: "Horizontale Verschiebung",
                opt_flow_v: "Vertikale Verschiebung",
                opt_flow_r: "Rotation (Roll)",
                opt_flow_e: "Expansion (Tunnel)",
                opt_flow_mix_hr: "Mix: H + Rotation",
                opt_flow_mix_er: "Mix: Exp + Rotation",
                opt_bg_black: "Schwarz (Neutral)",
                opt_bg_noise: "Schnee (Rauschen)",
                opt_bg_grid: "Gitter",
                opt_bg_checker: "Schachbrett",
                opt_bg_moire: "Moiré",
                opt_tgt_static: "Roter Punkt",
                opt_tgt_dynamic: "Dynamisch",
                opt_tgt_pursuit: "Verfolgung",
                opt_tgt_saccade: "Sakkaden",
                opt_tgt_anti: "Gegenbewegung",
                opt_tgt_mask_c: "Zentralmaske",
                opt_tgt_mask_p: "Peripheriemaske",
                opt_cog_off: "Keine",
                opt_cog_math: "Rechnen (Visuell)",
                opt_cog_audio: "Audio (TTS)",
                adv_low: "<strong>RAT:</strong> Zu einfach. Geschwindigkeit erhöhen.",
                adv_high: "<strong>RAT:</strong> Zu intensiv. Belastung reduzieren.",
                adv_ok: "<strong>PERFEKT:</strong> Optimale Zone.",
                tts_prompt: "Sag deutlich"
            }
        };

        let CUR_LANG = 'en';

        // --- CORE STATE ---
        const PROTOCOLS = {
            manual: {},
            p1: { speed: 15, flow: 'h', bg: 'black', tilt: 0, drift: 0, flicker: 0, target: 'static', cog: 'off' },
            p2: { speed: 30, flow: 'mix_hr', bg: 'noise', tilt: 5, drift: 20, flicker: 0, target: 'dynamic', cog: 'math' },
            p3: { speed: 50, flow: 'e', bg: 'checker', tilt: 10, drift: 60, flicker: 12, target: 'anti', cog: 'audio' },
            p4: { speed: 80, flow: 'mix_er', bg: 'moire', tilt: 15, drift: 90, flicker: 18, target: 'mask_center', cog: 'math' }
        };

        const STATE = {
            isRunning: false,
            isVR: false,
            config: {
                speed: 20, flow: 'h', bg: 'black', tilt: 0, drift: 0, asym: 0, flicker: 0,
                targetMode: 'static', cogMode: 'off', duration: 60
            },
            runtime: {
                startTime: 0, elapsed: 0, particles: [],
                target: { x: 0, y: 0, angle: 0, type: 0, lastChange: 0 },
                driftAngle: 0, flickerState: true, cogInterval: null
            }
        };

        // --- TTS & AUDIO ---
        const AudioManager = {
            async speak(text) {
                if (!text) return;
                try {
                    const prompt = `${I18N[CUR_LANG].tts_prompt}: ${text}`;
                    
                    if (!API_KEY) {
                        const u = new SpeechSynthesisUtterance(text);
                        // Map lang codes
                        const map = { en:'en-US', fr:'fr-FR', es:'es-ES', de:'de-DE' };
                        u.lang = map[CUR_LANG];
                        window.speechSynthesis.speak(u);
                        return;
                    }

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            generationConfig: { 
                                responseModalities: ["AUDIO"],
                                speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Fenrir" } } }
                            }
                        })
                    });
                    const res = await response.json();
                    const b64 = res.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                    if (b64) {
                        const blob = this.b64toBlob(b64);
                        new Audio(URL.createObjectURL(blob)).play();
                    }
                } catch (e) { console.warn("TTS Error", e); }
            },
            b64toBlob(b64) {
                const byteCharacters = atob(b64);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) byteNumbers[i] = byteCharacters.charCodeAt(i);
                const byteArray = new Uint8Array(byteNumbers);
                const buffer = new ArrayBuffer(44 + byteArray.length);
                const view = new DataView(buffer);
                const writeString = (offset, string) => { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); };
                writeString(0, 'RIFF'); view.setUint32(4, 32 + byteArray.length, true); writeString(8, 'WAVE');
                writeString(12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true);
                view.setUint32(24, 24000, true); view.setUint32(28, 48000, true); view.setUint16(32, 2, true);
                view.setUint16(34, 16, true); writeString(36, 'data'); view.setUint32(40, byteArray.length, true);
                new Uint8Array(buffer, 44).set(byteArray);
                return new Blob([buffer], { type: 'audio/wav' }); 
            }
        };

        // --- RENDER ENGINE (Canvas) ---
        class RenderEngine {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.initParticles();
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                // Default centers (overridden in VR)
                this.cx = this.canvas.width / 2;
                this.cy = this.canvas.height / 2;
                if(STATE.runtime.particles.length === 0) this.initParticles();
            }

            initParticles() {
                STATE.runtime.particles = [];
                for (let i = 0; i < 300; i++) {
                    STATE.runtime.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        z: Math.random() * 2 + 0.5,
                        angle: Math.random() * Math.PI * 2,
                        radius: Math.random() * Math.max(this.canvas.width, this.canvas.height),
                        size: 1 + Math.random() * 3
                    });
                }
            }

            tick() {
                if (!STATE.isRunning) return;
                this.updatePhysics();
                this.draw();
                requestAnimationFrame(() => this.tick());
            }

            updatePhysics() {
                const now = Date.now();
                STATE.runtime.elapsed = now - STATE.runtime.startTime;
                const ramp = Math.min(1, STATE.runtime.elapsed / 3000);
                const driftRad = (STATE.config.drift / 100) * 0.02; 
                STATE.runtime.driftAngle += driftRad * Math.sin(now / 1000);
                let baseSpeed = (STATE.config.speed / 5) * ramp; 
                
                // Physics update uses FULL SCREEN coords.
                // In VR we just view this world from two viewports.
                // For a more correct VR we'd render two particle sets or offset them, 
                // but for optical flow therapy, viewing the same chaotic field is sufficient.
                
                const width = this.canvas.width;
                const height = this.canvas.height;
                const centerX = width/2;

                STATE.runtime.particles.forEach(p => {
                    let sideMod = 1;
                    if (STATE.config.asym !== 0) {
                        const isLeft = p.x < centerX;
                        const factor = 1 + (STATE.config.asym / 50);
                        if (isLeft) sideMod = factor; else sideMod = 2 - factor; 
                    }
                    const speed = baseSpeed * sideMod * p.z;
                    const flow = STATE.config.flow;
                    
                    if (flow.includes('h') || flow === 'mix_hr') {
                        p.x += speed * Math.cos(STATE.runtime.driftAngle);
                        p.y += speed * Math.sin(STATE.runtime.driftAngle);
                        if (p.x > width) p.x = 0; if (p.x < 0) p.x = width;
                        if (p.y > height) p.y = 0; if (p.y < 0) p.y = height;
                    }
                    if (flow.includes('v')) {
                        p.y += speed; if (p.y > height) p.y = 0;
                    }
                    if (flow.includes('r') || flow === 'mix_hr' || flow === 'mix_er') p.angle += (speed * 0.005); 
                    if (flow === 'e' || flow === 'mix_er') {
                        p.radius += speed * 5;
                        if (p.radius > Math.max(width, height)) p.radius = 0;
                    }
                });
                
                // Target Logic needs to handle VR split inside updateTarget? 
                // No, updateTarget calculates "Virtual World" position.
                // renderView will shift it.
                this.updateTarget(now, baseSpeed, centerX, height/2);
            }

            updateTarget(now, speed, cx, cy) {
                const mode = STATE.config.targetMode;
                const rt = STATE.runtime.target;
                
                // In Normal mode: cx, cy are screen center.
                // In VR mode: calculations should probably remain relative to "world center" 
                // and we shift the camera.
                
                if (mode === 'static' || mode === 'mask_center' || mode === 'mask_periph') {
                    rt.x = cx; rt.y = cy;
                } else if (mode === 'dynamic') {
                    if (now - rt.lastChange > 2000) { rt.type = Math.floor(Math.random() * 3); rt.lastChange = now; }
                    rt.x = cx; rt.y = cy;
                } else if (mode === 'pursuit') {
                    rt.angle += 0.02;
                    rt.x = cx + Math.cos(rt.angle) * 200;
                    rt.y = cy + Math.sin(rt.angle * 0.7) * 100;
                } else if (mode === 'saccade') {
                    if (now - rt.lastChange > 1500) {
                        rt.x = cx + (Math.random()-0.5) * 600;
                        rt.y = cy + (Math.random()-0.5) * 400;
                        rt.lastChange = now;
                    }
                } else if (mode === 'anti') {
                    rt.x = cx - Math.sin(Date.now()/1000) * (speed * 100);
                    rt.y = cy;
                }
            }

            draw() {
                // FLICKER (Global)
                if (STATE.config.flicker > 0) {
                    const interval = 1000 / STATE.config.flicker;
                    if (Math.floor(Date.now() / interval) % 2 === 0) {
                        this.ctx.fillStyle = '#000';
                        this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);
                        return;
                    }
                }

                // Clear
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);

                if (STATE.isVR) {
                    const hw = this.canvas.width / 2;
                    const hh = this.canvas.height;
                    
                    // Left Eye
                    this.renderView(0, 0, hw, hh, -10); // Slight offset for stereo parallax?
                    
                    // Right Eye
                    this.renderView(hw, 0, hw, hh, 10);
                    
                    // Separator
                    this.ctx.fillStyle = '#111';
                    this.ctx.fillRect(hw - 2, 0, 4, hh);
                } else {
                    this.renderView(0, 0, this.canvas.width, this.canvas.height, 0);
                }
            }

            renderView(x, y, w, h, offset) {
                this.ctx.save();
                
                // Clip region
                this.ctx.beginPath();
                this.ctx.rect(x, y, w, h);
                this.ctx.clip();

                // Translate to center of this viewport
                const vx = x + w/2;
                const vy = y + h/2;
                this.ctx.translate(vx, vy);

                // Global Tilt
                const tiltRad = (STATE.config.tilt * Math.PI / 180) * Math.sin(Date.now()/2500);
                this.ctx.rotate(tiltRad);

                // Draw Background (relative to center 0,0)
                this.drawBackground(w, h); // pass viewport size for optimization?

                // Draw Particles
                // Note: Particles are in "Screen Space" (0 to ScreenWidth). 
                // We need to map them to Viewport Space relative to center.
                // In standard mode: particle at 500 is 500.
                // In VR mode: we see the same field? 
                // Yes, simpler to view the same chaos field. 
                // Shift by -ScreenWidth/2 + offset to center them.
                
                const contrastVal = 200;
                this.ctx.fillStyle = `rgb(${contrastVal}, ${contrastVal}, ${contrastVal})`;
                
                // Global center for particle coordinate system
                const worldCx = this.canvas.width / 2;
                const worldCy = this.canvas.height / 2;

                STATE.runtime.particles.forEach(p => {
                    let drawX, drawY;
                    const flow = STATE.config.flow;

                    // Polar coords relative to World Center
                    if (flow.includes('r') || flow === 'e' || flow === 'mix_er') {
                        // For polar, we calculate position relative to world center
                        // then just draw it relative to local center
                        const r = p.radius;
                        const ang = p.angle;
                        drawX = Math.cos(ang) * r;
                        drawY = Math.sin(ang) * r;
                    } else {
                        // Cartesian: Particle X is 0..ScreenW. 
                        // Convert to relative:
                        drawX = p.x - worldCx;
                        drawY = p.y - worldCy;
                    }
                    
                    // Stereo Offset (Parallax) applied to X
                    drawX += offset; 

                    this.ctx.beginPath(); 
                    this.ctx.arc(drawX, drawY, p.size, 0, Math.PI * 2); 
                    this.ctx.fill();
                });

                // Draw Target
                const t = STATE.runtime.target;
                // Target is also in world coords. Convert to relative.
                const tx = t.x - worldCx + offset; // Apply offset for depth
                const ty = t.y - worldCy;
                
                this.drawTargetRelative(tx, ty, w, h);

                this.ctx.restore();
            }

            drawBackground(vpW, vpH) {
                // FIXED: Clear an oversized area to prevent rotation artifacts (black trailing corners)
                const oversize = Math.max(this.canvas.width, this.canvas.height) * 2;
                // No fillRect needed here, main draw cleared it.
                
                const bg = STATE.config.bg;
                this.ctx.fillStyle = 'rgba(255,255,255,0.08)';
                
                if (bg === 'noise') {
                    for(let i=0; i<300; i++) {
                         this.ctx.fillRect(
                             (Math.random() - 0.5) * oversize, 
                             (Math.random() - 0.5) * oversize, 
                             2, 2
                         );
                    }
                } else if (bg === 'grid') {
                    this.ctx.strokeStyle = 'rgba(255,255,255,0.08)'; 
                    this.ctx.lineWidth = 1;
                    const step = 80; 
                    const limit = oversize / 2;
                    this.ctx.beginPath();
                    for(let x = -limit; x < limit; x+=step) { this.ctx.moveTo(x,-limit); this.ctx.lineTo(x,limit); }
                    for(let y = -limit; y < limit; y+=step) { this.ctx.moveTo(-limit,y); this.ctx.lineTo(limit,y); }
                    this.ctx.stroke();
                } else if (bg === 'checker') {
                    const s = 60;
                    // Optimization: Draw roughly enough to cover viewport
                    const limX = vpW; // Enough for rotation?
                    const limY = vpH;
                    for(let y = -oversize/2; y < oversize/2; y+=s) {
                        for(let x = -oversize/2; x < oversize/2; x+=s) {
                             if ((Math.floor(x/s) + Math.floor(y/s)) % 2 === 0) this.ctx.fillRect(x,y,s,s);
                        }
                    }
                } else if (bg === 'moire') {
                    this.ctx.strokeStyle = 'rgba(255,255,255,0.05)'; 
                    this.ctx.lineWidth = 2; 
                    const limit = Math.max(vpW, vpH) * 1.5;
                    for(let r=0; r<limit; r+=15) { 
                        this.ctx.beginPath(); this.ctx.arc(0, 0, r, 0, Math.PI*2); this.ctx.stroke(); 
                    }
                    this.ctx.save();
                    this.ctx.translate(10, 10);
                    for(let r=0; r<limit; r+=15) { 
                        this.ctx.beginPath(); this.ctx.arc(0, 0, r, 0, Math.PI*2); this.ctx.stroke(); 
                    }
                    this.ctx.restore();
                }
            }

            drawTargetRelative(tx, ty, vpW, vpH) {
                const mode = STATE.config.targetMode;
                const t = STATE.runtime.target; // Type only
                
                if (mode === 'mask_center') {
                    this.ctx.fillStyle = '#000'; this.ctx.beginPath(); this.ctx.arc(0, 0, 150, 0, Math.PI*2); this.ctx.fill();
                    this.ctx.strokeStyle = '#333'; this.ctx.lineWidth = 2; this.ctx.stroke(); return;
                }
                if (mode === 'mask_periph') {
                    // Tricky in relative mode. Draw big rect then cut hole?
                    this.ctx.fillStyle = '#000'; this.ctx.beginPath(); 
                    this.ctx.rect(-vpW, -vpH, vpW*2, vpH*2); // Oversized rect
                    this.ctx.arc(0, 0, 150, 0, Math.PI*2, true); 
                    this.ctx.fill(); return;
                }

                this.ctx.shadowBlur = 10; this.ctx.shadowColor = 'red'; this.ctx.fillStyle = '#e74c3c';
                if (mode === 'dynamic') {
                    const colors = ['#e74c3c', '#f1c40f', '#3498db'];
                    this.ctx.fillStyle = colors[STATE.runtime.target.type]; 
                    this.ctx.shadowColor = colors[STATE.runtime.target.type];
                }
                this.ctx.beginPath(); this.ctx.arc(tx, ty, 8, 0, Math.PI*2); this.ctx.fill(); this.ctx.shadowBlur = 0;
            }
        }

        // --- SESSION CONTROLLER ---
        class SessionController {
            constructor(engine) {
                this.engine = engine;
                this.timerEl = document.getElementById('timer-display');
                this.cogOverlay = document.getElementById('cognitive-overlay');
                this.vrInstruction = document.getElementById('vr-instruction');
                this.cogInterval = null;
                this.timerInterval = null;
                this.secondsLeft = 0;
            }

            start() {
                if (STATE.isRunning) return;
                STATE.isRunning = true;
                STATE.runtime.startTime = Date.now();
                
                // UI Handling
                if (!STATE.isVR) {
                    document.getElementById('ui-panel').classList.add('collapsed');
                } else {
                    document.getElementById('ui-panel').classList.add('hidden');
                    this.vrInstruction.style.display = 'block';
                    setTimeout(() => this.vrInstruction.style.display = 'none', 4000);
                }

                this.secondsLeft = 0; 
                this.timerInterval = setInterval(() => {
                    this.secondsLeft++;
                    const m = Math.floor(this.secondsLeft / 60).toString().padStart(2,'0');
                    const s = (this.secondsLeft % 60).toString().padStart(2,'0');
                    this.timerEl.textContent = `${m}:${s}`;
                }, 1000);
                this.engine.tick();
                this.handleCognitive();
            }

            enterVR() {
                // Try to enter fullscreen, but handle errors silently (iframe sandbox issues)
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.warn("VR Fullscreen blocked (Permissions Policy). Starting windowed VR.");
                    });
                }
                STATE.isVR = true;
                this.start();
            }

            stop() {
                if (!STATE.isRunning) return;
                STATE.isRunning = false;
                STATE.isVR = false;
                
                if (document.exitFullscreen && document.fullscreenElement) {
                    document.exitFullscreen().catch(e => console.log("Exit fullscreen failed or not needed", e));
                }

                clearInterval(this.timerInterval);
                clearInterval(this.cogInterval);
                this.cogOverlay.style.display = 'none';
                this.vrInstruction.style.display = 'none';
                
                document.getElementById('ui-panel').classList.remove('hidden');
                document.getElementById('ui-panel').classList.remove('collapsed');
                document.getElementById('modal-borg').classList.add('active');
            }

            handleCognitive() {
                const mode = STATE.config.cogMode;
                if (mode === 'off') return;
                const taskLoop = () => {
                    const a = Math.floor(Math.random() * 20) + 1;
                    const b = Math.floor(Math.random() * 20) + 1;
                    if (mode === 'math') {
                        // In VR, overlay must be duplicated or centered properly.
                        // Currently fixed to screen center, which might be "between eyes".
                        // Better to rely on Audio in VR.
                        if (!STATE.isVR) {
                            this.cogOverlay.style.display = 'block';
                            this.cogOverlay.textContent = `${a} + ${b} = ?`;
                            setTimeout(() => this.cogOverlay.textContent = '', 3000);
                        } else {
                            // Audio fallback for VR visual math? 
                            // Or show text centered in canvas? 
                            // Let's force Audio for VR implicitly for now or just let visual be center (might be hard to read)
                        }
                    } else if (mode === 'audio') {
                        let connector = "plus";
                        if(CUR_LANG === 'es') connector = "más";
                        if(CUR_LANG === 'de') connector = "plus";
                        AudioManager.speak(`${a} ${connector} ${b}`);
                    }
                };
                taskLoop();
                this.cogInterval = setInterval(taskLoop, 8000);
            }

            logSession(score) {
                const logs = JSON.parse(localStorage.getItem('pppd_logs') || '[]');
                const entry = { date: new Date().toLocaleDateString(), duration: this.secondsLeft, score: score, speed: STATE.config.speed, mode: STATE.config.bg };
                logs.unshift(entry);
                localStorage.setItem('pppd_logs', JSON.stringify(logs.slice(0, 50)));
                this.renderHistory();
            }

            renderHistory() {
                const logs = JSON.parse(localStorage.getItem('pppd_logs') || '[]');
                const container = document.getElementById('history-container');
                container.innerHTML = logs.map(l => {
                    let cls = 'score-good'; if (l.score < 3) cls = 'score-bad'; if (l.score > 6) cls = 'score-danger';
                    return `<div class="log-entry"><span>${l.date} (${l.duration}s)</span><span class="${cls}">Borg: ${l.score}/10</span></div>`;
                }).join('');

                if(logs.length >= 3) {
                    const avg = (logs[0].score + logs[1].score + logs[2].score) / 3;
                    const fb = document.getElementById('progression-feedback');
                    fb.style.display = 'block';
                    if (avg < 3) fb.innerHTML = I18N[CUR_LANG].adv_low;
                    else if (avg > 6) fb.innerHTML = I18N[CUR_LANG].adv_high;
                    else fb.innerHTML = I18N[CUR_LANG].adv_ok;
                }
            }

            exportCSV() {
                const logs = JSON.parse(localStorage.getItem('pppd_logs') || '[]');
                if (!logs.length) return alert("Empty");
                let csv = "Date,Dur,Score,Spd,Bg\n";
                logs.forEach(l => csv += `${l.date},${l.duration},${l.score},${l.speed},${l.mode}\n`);
                const blob = new Blob([csv], {type: 'text/csv'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob); a.download = 'pppd_rehab.csv'; a.click();
            }

            clearHistory() {
                if(confirm("Reset History?")) { localStorage.removeItem('pppd_logs'); this.renderHistory(); }
            }
        }

        // --- I18N LOGIC ---
        function setLang(lang) {
            CUR_LANG = lang;
            document.documentElement.lang = lang;
            
            document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.lang-btn[onclick="setLang('${lang}')"]`).classList.add('active');

            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if(I18N[lang][key]) el.innerHTML = I18N[lang][key];
            });

            document.getElementById('warn-text').innerHTML = I18N[lang].warn_text;
            updateSelectOptions(lang);
            session.renderHistory();
        }

        function updateSelectOptions(lang) {
            const fills = [
                ['preset-select', [
                    {v:'manual', k:'opt_manual'}, {v:'p1', k:'opt_p1'}, {v:'p2', k:'opt_p2'}, 
                    {v:'p3', k:'opt_p3'}, {v:'p4', k:'opt_p4'}
                ]],
                ['inp-flow', [
                    {v:'h', k:'opt_flow_h'}, {v:'v', k:'opt_flow_v'}, {v:'r', k:'opt_flow_r'}, 
                    {v:'e', k:'opt_flow_e'}, {v:'mix_hr', k:'opt_flow_mix_hr'}, {v:'mix_er', k:'opt_flow_mix_er'}
                ]],
                ['inp-bg', [
                    {v:'black', k:'opt_bg_black'}, {v:'noise', k:'opt_bg_noise'}, {v:'grid', k:'opt_bg_grid'}, 
                    {v:'checker', k:'opt_bg_checker'}, {v:'moire', k:'opt_bg_moire'}
                ]],
                ['inp-target', [
                    {v:'static', k:'opt_tgt_static'}, {v:'dynamic', k:'opt_tgt_dynamic'}, {v:'pursuit', k:'opt_tgt_pursuit'}, 
                    {v:'saccade', k:'opt_tgt_saccade'}, {v:'anti', k:'opt_tgt_anti'}, 
                    {v:'mask_center', k:'opt_tgt_mask_c'}, {v:'mask_periph', k:'opt_tgt_mask_p'}
                ]],
                ['inp-cognitive', [
                    {v:'off', k:'opt_cog_off'}, {v:'math', k:'opt_cog_math'}, {v:'audio', k:'opt_cog_audio'}
                ]]
            ];

            fills.forEach(([id, opts]) => {
                const el = document.getElementById(id);
                const currentVal = el.value;
                el.innerHTML = '';
                opts.forEach(o => {
                    const opt = document.createElement('option');
                    opt.value = o.v;
                    opt.text = I18N[lang][o.k];
                    el.appendChild(opt);
                });
                if(currentVal) el.value = currentVal; 
            });
        }

        // --- INIT ---
        const engine = new RenderEngine('app-canvas');
        const session = new SessionController(engine);

        const bindRange = (id, key, labelId, suffix='') => {
            document.getElementById(id).addEventListener('input', (e) => {
                STATE.config[key] = parseInt(e.target.value);
                if(labelId) document.getElementById(labelId).textContent = e.target.value + suffix;
            });
        };
        const bindSelect = (id, key) => {
            document.getElementById(id).addEventListener('change', (e) => { STATE.config[key] = e.target.value; });
        };

        bindRange('inp-speed', 'speed', 'val-speed');
        bindRange('inp-tilt', 'tilt', 'val-tilt', '°');
        bindRange('inp-drift', 'drift', 'val-drift', '%');
        bindRange('inp-asym', 'asym', 'val-asym');
        bindRange('inp-flicker', 'flicker', 'val-flicker', 'Hz');
        
        bindSelect('inp-flow', 'flow'); bindSelect('inp-bg', 'bg'); 
        bindSelect('inp-target', 'targetMode'); bindSelect('inp-cognitive', 'cogMode');

        document.getElementById('preset-select').addEventListener('change', (e) => {
            const val = e.target.value;
            if (val === 'manual') return;
            const p = PROTOCOLS[val];
            Object.assign(STATE.config, p);
            document.getElementById('inp-speed').value = p.speed; document.getElementById('val-speed').textContent = p.speed;
            document.getElementById('inp-flow').value = p.flow; document.getElementById('inp-bg').value = p.bg;
            document.getElementById('inp-tilt').value = p.tilt; document.getElementById('val-tilt').textContent = p.tilt+'°';
            document.getElementById('inp-drift').value = p.drift; document.getElementById('val-drift').textContent = p.drift+'%';
            document.getElementById('inp-flicker').value = p.flicker; document.getElementById('val-flicker').textContent = p.flicker;
            document.getElementById('inp-target').value = p.target; document.getElementById('inp-cognitive').value = p.cog;
        });

        document.getElementById('btn-start').addEventListener('click', () => session.start());
        document.getElementById('btn-vr').addEventListener('click', () => session.enterVR());
        document.getElementById('btn-stop').addEventListener('click', () => session.stop());
        document.getElementById('btn-export').addEventListener('click', () => session.exportCSV());
        document.getElementById('btn-clear').addEventListener('click', () => session.clearHistory());
        document.getElementById('ui-toggle').addEventListener('click', () => document.getElementById('ui-panel').classList.toggle('collapsed'));
        document.getElementById('btn-accept').addEventListener('click', () => document.getElementById('modal-warning').classList.remove('active'));
        
        // VR Exit on Touch
        document.getElementById('canvas-wrapper').addEventListener('touchstart', (e) => {
            if(STATE.isVR) session.stop();
        });
        document.getElementById('canvas-wrapper').addEventListener('click', (e) => {
            if(STATE.isVR) session.stop();
        });

        const borgContainer = document.getElementById('borg-container');
        for (let i = 0; i <= 10; i++) {
            const b = document.createElement('div');
            b.className = 'borg-btn'; b.textContent = i;
            b.onclick = () => { session.logSession(i); document.getElementById('modal-borg').classList.remove('active'); };
            borgContainer.appendChild(b);
        }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (STATE.isRunning) session.stop();
            }
        });

        // Initialize Language (Default EN)
        setLang('en');
        session.renderHistory();

    </script>
</body>
</html>
