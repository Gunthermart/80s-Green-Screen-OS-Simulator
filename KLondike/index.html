<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    
    <!-- Titre principal de la page -->
    <title>Solitaire Klondike (Patience) - Jeu Rétro Années 80</title>

    <!-- Métadonnées pour le SEO -->
    <meta name="description" content="Jouez au Solitaire Klondike (Patience) dans un style rétro-futuriste des années 80. Un jeu de cartes classique avec un look de terminal informatique, entièrement jouable en 5 langues.">
    <meta name="keywords" content="solitaire, klondike, patience, jeu de cartes, jeu rétro, années 80, 8-bit, terminal, jeu en ligne, html5 game">
    <meta name="author" content="Votre Nom ou Nom de votre studio">

    <!-- Métadonnées pour le responsive design -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Métadonnées Open Graph pour le partage sur les réseaux sociaux (Facebook, LinkedIn, etc.) -->
    <meta property="og:title" content="Solitaire Klondike - Style Rétro Années 80">
    <meta property="og:description" content="Redécouvrez le classique jeu de Patience avec une esthétique de terminal informatique 'glow' des années 80.">
    <meta property="og:image" content="https://leonce-equity.com/klondike/klondike.png">
    <meta property="og:url" content="URL_DE_VOTRE_JEU_EN_LIGNE"> <!-- Remplacez par l'URL finale de votre jeu -->
    <meta property="og:type" content="website">
    <meta property="og:locale" content="fr_FR">

    <!-- Métadonnées Twitter Card pour le partage sur Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Solitaire Klondike - Style Rétro Années 80">
    <meta name="twitter:description" content="Redécouvrez le classique jeu de Patience avec une esthétique de terminal informatique 'glow' des années 80.">
    <meta name="twitter:image" content="https://leonce-equity.com/klondike/klondike.png">
    
    <!-- Favicons pour les navigateurs et appareils -->
    <link rel="icon" href="/favicon.ico" sizes="any">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">

    <!-- Polices de caractères Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <style>
        /* --- General Styles --- */
        :root {
            --glow-green: #00ff41;
            --glow-red: #ff0055; /* Nouvelle couleur pour les cartes rouges */
            --dark-bg: #0d0d0d;
            --card-bg: #0d0d0d; /* Fond des cartes rendu opaque */
            --card-width: 100px;
            --card-height: 140px;
            --gap: 15px;
            --tableau-offset: 30px;
        }

        body {
            font-family: 'VT323', monospace;
            background-color: var(--dark-bg);
            color: var(--glow-green);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 0; /* No padding on body */
            box-sizing: border-box;
            text-shadow: 0 0 5px var(--glow-green);
        }

        /* Effet de lignes de balayage (scanlines) pour l'ambiance rétro */
        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: repeating-linear-gradient(0deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3) 1px, transparent 1px, transparent 3px);
            pointer-events: none;
            z-index: 9999;
        }

        /* --- Terminal Bar --- */
        .terminal-bar {
            width: 100%;
            background-color: var(--glow-green);
            color: var(--dark-bg);
            text-shadow: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 10px;
            box-sizing: border-box;
            font-size: 20px;
        }
        .terminal-bar .title {
            font-weight: bold;
        }
        .close-terminal-btn {
            background-color: var(--dark-bg);
            color: var(--glow-green);
            border: 2px solid var(--dark-bg);
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            font-weight: bold;
        }

        .game-container {
            padding: 20px;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- Controls and Info --- */
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
        }

        button, .info-panel {
            background-color: transparent;
            border: 2px solid var(--glow-green);
            color: var(--glow-green);
            padding: 10px 20px;
            font-size: 20px;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 8px var(--glow-green) inset, 0 0 5px var(--glow-green);
            font-family: 'VT323', monospace;
        }

        button:hover {
            background-color: rgba(0, 255, 65, 0.1);
            box-shadow: 0 0 12px var(--glow-green) inset, 0 0 10px var(--glow-green);
        }
        
        .language-selector {
            display: flex;
            gap: 5px;
            border: 2px solid var(--glow-green);
            padding: 5px;
            box-shadow: 0 0 8px var(--glow-green) inset, 0 0 5px var(--glow-green);
        }
        .language-selector button {
            padding: 5px 10px;
            font-size: 18px;
            border: none;
            box-shadow: none;
        }
        .language-selector button.active {
            background-color: var(--glow-green);
            color: var(--dark-bg);
            text-shadow: none;
        }


        /* --- Game Board --- */
        .game-board {
            display: grid;
            grid-template-columns: repeat(7, var(--card-width));
            grid-template-rows: var(--card-height) auto;
            gap: var(--gap);
            background-color: rgba(0, 255, 65, 0.05);
            padding: var(--gap);
            border: 2px solid var(--glow-green);
            box-shadow: 0 0 15px var(--glow-green);
            width: fit-content;
        }
        .game-board.auto-playing {
            pointer-events: none;
        }

        /* --- Piles --- */
        .upper-piles {
            grid-column: 1 / 8;
            display: flex;
            justify-content: space-between;
        }

        .stock-waste-piles, .foundation-piles {
            display: flex;
            gap: var(--gap);
        }

        .pile {
            width: var(--card-width);
            height: var(--card-height);
            border: 2px dashed rgba(0, 255, 65, 0.5);
            border-radius: 4px;
            position: relative;
        }

        .tableau-pile {
            height: auto;
            min-height: var(--card-height);
        }

        /* --- Cards --- */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            border-radius: 4px;
            background-color: var(--card-bg);
            position: absolute;
            cursor: grab;
            user-select: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px;
            box-sizing: border-box;
            font-size: 24px;
            font-weight: normal;
            transition: top 0.2s ease-out, left 0.2s ease-out, transform 0.2s;
        }

        .card.dragging {
            cursor: grabbing;
            opacity: 0.0; /* Cacher la carte originale pendant le glissement */
        }
        
        .card.hint {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }

        .card.face-down {
            border: 2px solid var(--glow-green);
            background: 
                repeating-linear-gradient(var(--dark-bg), var(--dark-bg) 8px, var(--glow-green) 9px, var(--dark-bg) 10px),
                repeating-linear-gradient(90deg, var(--dark-bg), var(--dark-bg) 8px, var(--glow-green) 9px, var(--dark-bg) 10px);
            color: transparent;
            text-shadow: none;
            box-shadow: 0 0 5px var(--glow-green);
            cursor: default;
        }

        /* Style pour les cartes noires (Pique, Trèfle) */
        .card.black {
            color: var(--glow-green);
            border: 2px solid var(--glow-green);
            text-shadow: 0 0 5px var(--glow-green);
            box-shadow: 0 0 5px var(--glow-green);
        }
        
        /* Style pour les cartes rouges (Coeur, Carreau) */
        .card.red {
            color: var(--glow-red);
            border: 2px solid var(--glow-red);
            text-shadow: 0 0 5px var(--glow-red);
            box-shadow: 0 0 5px var(--glow-red);
        }

        .card-suit { font-size: 28px; line-height: 1; }
        .card-rank { align-self: flex-start; }
        .card-suit-bottom { align-self: flex-end; transform: rotate(180deg); }

        .tableau-pile .card { top: 0; left: 0; }

        /* --- Win Message & Modal --- */
        .overlay-message {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(13, 13, 13, 0.9);
            color: var(--glow-green);
            padding: 40px 60px;
            border: 2px solid var(--glow-green);
            text-align: center;
            font-size: 2.5em;
            z-index: 2000;
            box-shadow: 0 0 25px var(--glow-green);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1500;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
        }

        .modal-content {
            background-color: var(--dark-bg);
            margin: 10% auto;
            padding: 20px 30px;
            border: 2px solid var(--glow-green);
            width: 80%;
            max-width: 600px;
            position: relative;
            box-shadow: 0 0 20px var(--glow-green);
        }

        .modal-content h2 { margin-top: 0; color: var(--glow-green); }
        .modal-content p, .modal-content li { color: var(--glow-green); }
        .modal-content ul { padding-left: 20px; }
        .modal-content li { margin-bottom: 10px; }

        .close-btn {
            color: var(--glow-green);
            float: right;
            font-size: 40px;
            font-weight: bold;
            text-shadow: 0 0 5px var(--glow-green);
        }

        .close-btn:hover,
        .close-btn:focus {
            color: #fff;
            text-decoration: none;
            cursor: pointer;
        }

        /* --- Responsive Design --- */
        @media (max-width: 900px) {
            :root {
                --card-width: 90px;
                --card-height: 126px;
                --gap: 12px;
                --tableau-offset: 28px;
            }
        }

        @media (max-width: 768px) {
            :root {
                --card-width: 80px;
                --card-height: 112px;
                --gap: 10px;
                --tableau-offset: 25px;
            }
            .card { font-size: 20px; }
            .card-suit { font-size: 22px; }
        }

        @media (max-width: 600px) {
            .game-container {
                padding: 10px 5px;
            }
            :root {
                --gap: 5px;
                --card-width: calc((100vw - 8 * var(--gap)) / 7);
                --card-height: calc(var(--card-width) * 1.4);
                --tableau-offset: calc(var(--card-height) / 5);
            }
            .card {
                font-size: calc(var(--card-width) / 4);
                padding: 2px;
                border-width: 1px;
            }
            .card-suit {
                font-size: calc(var(--card-width) / 3.5);
            }
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            .modal-content {
                width: 95%;
                margin: 10% auto;
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="terminal-bar">
        <span class="title" data-key="title">C:\DOS\SOLITAIRE.EXE</span>
        <a href="#" class="close-terminal-btn" onclick="return false;">X</a>
    </div>

    <div class="game-container">
        <div class="controls">
            <button id="new-game-btn" data-key="newGame"></button>
            <button id="rules-btn" data-key="rules"></button>
            <button id="wiz-btn" data-key="wiz"></button>
            <button id="auto-btn" data-key="auto"></button>
            <div class="info-panel"><span data-key="moves"></span>: <span id="moves-count">0</span></div>
        </div>
        <div class="language-selector">
            <button data-lang="fr" class="active">FR</button>
            <button data-lang="en">EN</button>
            <button data-lang="es">ES</button>
            <button data-lang="de">DE</button>
            <button data-lang="zh">ZH</button>
        </div>
    </div>

    <div class="game-board" id="game-board">
        <!-- Piles will be generated by JS -->
    </div>

    <div class="overlay-message" id="win-message">
        <span data-key="victory"></span>
        <br>
        <span id="win-moves" style="font-size: 0.7em;"></span>
    </div>

    <div id="rules-modal" class="modal">
      <div class="modal-content">
        <span class="close-btn">&times;</span>
        <h2 data-key="rulesTitle"></h2>
        <p><strong data-key="rulesGoalTitle"></strong> <span data-key="rulesGoalText"></span></p>
        <h3 data-key="rulesSetupTitle"></h3>
        <ul>
          <li><strong data-key="rulesTableauTitle"></strong> <span data-key="rulesTableauText"></span></li>
          <li><strong data-key="rulesStockTitle"></strong> <span data-key="rulesStockText"></span></li>
          <li><strong data-key="rulesFoundationsTitle"></strong> <span data-key="rulesFoundationsText"></span></li>
        </ul>
        <h3 data-key="rulesHowToTitle"></h3>
        <ul>
          <li><strong data-key="rulesMoveTitle"></strong> <span data-key="rulesMoveText"></span></li>
          <li><strong data-key="rulesRevealTitle"></strong> <span data-key="rulesRevealText"></span></li>
          <li><strong data-key="rulesEmptyTitle"></strong> <span data-key="rulesEmptyText"></span></li>
          <li><strong data-key="rulesUseStockTitle"></strong> <span data-key="rulesUseStockText"></span></li>
          <li><strong data-key="rulesBuildFoundationsTitle"></strong> <span data-key="rulesBuildFoundationsText"></span></li>
        </ul>
      </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- TRANSLATIONS ---
        const translations = {
            fr: {
                title: "C:\\DOS\\SOLITAIRE.EXE",
                newGame: "> Nouvelle Partie", rules: "> Règles_", wiz: "> Wiz_", auto: "> Auto_", stop: "> Stop_",
                moves: "Mouvements",
                victory: "> VICTOIRE ! <",
                victoryMoves: "En {moves} mouvements",
                rulesTitle: "Règles du Solitaire (Patience)",
                rulesGoalTitle: "But du jeu :",
                rulesGoalText: "Reconstituer les quatre familles de cartes (Pique, Cœur, Carreau, Trèfle) dans un ordre croissant (de l'As au Roi) sur les quatre piles de fondation.",
                rulesSetupTitle: "Mise en place :",
                rulesTableauTitle: "Tableau :",
                rulesTableauText: "7 colonnes de cartes. La première colonne a 1 carte, la deuxième 2, et ainsi de suite. Seule la dernière carte de chaque colonne est visible.",
                rulesStockTitle: "Pioche (Stock) :",
                rulesStockText: "Le reste des cartes, face cachée.",
                rulesFoundationsTitle: "Fondations :",
                rulesFoundationsText: "Les 4 cases vides en haut à droite, prêtes à recevoir les As.",
                rulesHowToTitle: "Comment jouer :",
                rulesMoveTitle: "Déplacer des cartes :",
                rulesMoveText: "Vous pouvez déplacer une carte (ou une suite) sur une autre colonne si la carte de destination est de rang supérieur et de couleur opposée.",
                rulesRevealTitle: "Révéler des cartes :",
                rulesRevealText: "Quand vous déplacez une carte visible, la carte du dessous (si elle existe) est retournée.",
                rulesEmptyTitle: "Colonnes vides :",
                rulesEmptyText: "Seul un Roi (ou une suite commençant par un Roi) peut être déplacé sur une colonne vide.",
                rulesUseStockTitle: "Utiliser la pioche :",
                rulesUseStockText: "Cliquez sur la pioche pour tirer des cartes. La carte du dessus de la défausse est jouable.",
                rulesBuildFoundationsTitle: "Construire les fondations :",
                rulesBuildFoundationsText: "Envoyez les cartes de l'As au Roi sur les fondations. Le double-clic est un raccourci.",
            },
            en: {
                title: "C:\\DOS\\SOLITAIRE.EXE",
                newGame: "> New Game", rules: "> Rules_", wiz: "> Wiz_", auto: "> Auto_", stop: "> Stop_",
                moves: "Moves",
                victory: "> VICTORY! <",
                victoryMoves: "In {moves} moves",
                rulesTitle: "Rules of Solitaire (Patience)",
                rulesGoalTitle: "Goal:",
                rulesGoalText: "Rebuild the four suits from Ace to King on the foundation piles.",
                rulesSetupTitle: "Setup:",
                rulesTableauTitle: "Tableau:",
                rulesTableauText: "7 columns of cards are dealt. The first has 1 card, the second 2, and so on. Only the last card of each column is face up.",
                rulesStockTitle: "Stock:",
                rulesStockText: "The remaining cards, face down.",
                rulesFoundationsTitle: "Foundations:",
                rulesFoundationsText: "The 4 empty piles at the top right, ready for the Aces.",
                rulesHowToTitle: "How to Play:",
                rulesMoveTitle: "Moving Cards:",
                rulesMoveText: "You can move a card (or a sequence) onto another column if the destination card is one rank higher and of the opposite color.",
                rulesRevealTitle: "Revealing Cards:",
                rulesRevealText: "When you move a face-up card, the card beneath it (if any) is turned face up.",
                rulesEmptyTitle: "Empty Columns:",
                rulesEmptyText: "Only a King (or a sequence starting with a King) can be moved to an empty column.",
                rulesUseStockTitle: "Using the Stock:",
                rulesUseStockText: "Click the stock to draw cards. The top card of the waste pile is playable.",
                rulesBuildFoundationsTitle: "Building Foundations:",
                rulesBuildFoundationsText: "Send cards from Ace to King to the foundations. Double-clicking is a shortcut.",
            },
            es: {
                title: "C:\\DOS\\SOLITARIO.EXE",
                newGame: "> Nuevo Juego", rules: "> Reglas_", wiz: "> Pista_", auto: "> Auto_", stop: "> Parar_",
                moves: "Movimientos",
                victory: "> ¡VICTORIA! <",
                victoryMoves: "En {moves} movimientos",
                rulesTitle: "Reglas del Solitario (Paciencia)",
                rulesGoalTitle: "Objetivo:",
                rulesGoalText: "Reconstruir los cuatro palos desde el As hasta el Rey en las pilas de base.",
                rulesSetupTitle: "Preparación:",
                rulesTableauTitle: "Tablero:",
                rulesTableauText: "Se reparten 7 columnas de cartas. La primera tiene 1 carta, la segunda 2, y así sucesivamente. Solo la última carta de cada columna está boca arriba.",
                rulesStockTitle: "Mazo:",
                rulesStockText: "El resto de las cartas, boca abajo.",
                rulesFoundationsTitle: "Bases:",
                rulesFoundationsText: "Las 4 pilas vacías arriba a la derecha, listas para los Ases.",
                rulesHowToTitle: "Cómo Jugar:",
                rulesMoveTitle: "Mover Cartas:",
                rulesMoveText: "Puedes mover una carta (o una secuencia) a otra columna si la carta de destino es de un rango superior y de color opuesto.",
                rulesRevealTitle: "Revelar Cartas:",
                rulesRevealText: "Cuando mueves una carta boca arriba, la carta de abajo (si la hay) se voltea.",
                rulesEmptyTitle: "Columnas Vacías:",
                rulesEmptyText: "Solo un Rey (o una secuencia que comience con un Rey) puede moverse a una columna vacía.",
                rulesUseStockTitle: "Usar el Mazo:",
                rulesUseStockText: "Haz clic en el mazo para sacar cartas. La carta superior del descarte se puede jugar.",
                rulesBuildFoundationsTitle: "Construir las Bases:",
                rulesBuildFoundationsText: "Envía las cartas del As al Rey a las bases. Hacer doble clic es un atajo.",
            },
            de: {
                title: "C:\\DOS\\SOLITAER.EXE",
                newGame: "> Neues Spiel", rules: "> Regeln_", wiz: "> Tipp_", auto: "> Auto_", stop: "> Stopp_",
                moves: "Züge",
                victory: "> SIEG! <",
                victoryMoves: "In {moves} Zügen",
                rulesTitle: "Regeln für Solitär (Patience)",
                rulesGoalTitle: "Ziel:",
                rulesGoalText: "Bauen Sie die vier Farben von Ass bis König auf den Grundstapeln auf.",
                rulesSetupTitle: "Aufbau:",
                rulesTableauTitle: "Spielbereich:",
                rulesTableauText: "Es werden 7 Spalten mit Karten ausgelegt. Die erste hat 1 Karte, die zweite 2 usw. Nur die letzte Karte jeder Spalte ist aufgedeckt.",
                rulesStockTitle: "Stapel:",
                rulesStockText: "Die restlichen Karten, verdeckt.",
                rulesFoundationsTitle: "Grundlagen:",
                rulesFoundationsText: "Die 4 leeren Stapel oben rechts, bereit für die Asse.",
                rulesHowToTitle: "Spielanleitung:",
                rulesMoveTitle: "Karten bewegen:",
                rulesMoveText: "Sie können eine Karte (oder eine Sequenz) auf eine andere Spalte verschieben, wenn die Zielkarte einen Rang höher und von entgegengesetzter Farbe ist.",
                rulesRevealTitle: "Karten aufdecken:",
                rulesRevealText: "Wenn Sie eine aufgedeckte Karte bewegen, wird die darunter liegende Karte (falls vorhanden) aufgedeckt.",
                rulesEmptyTitle: "Leere Spalten:",
                rulesEmptyText: "Nur ein König (oder eine mit einem König beginnende Sequenz) kann auf eine leere Spalte gelegt werden.",
                rulesUseStockTitle: "Stapel verwenden:",
                rulesUseStockText: "Klicken Sie auf den Stapel, um Karten zu ziehen. Die oberste Karte des Abfallstapels ist spielbar.",
                rulesBuildFoundationsTitle: "Grundlagen bauen:",
                rulesBuildFoundationsText: "Senden Sie Karten von Ass bis König zu den Grundlagen. Ein Doppelklick ist eine Abkürzung.",
            },
            zh: {
                title: "C:\\DOS\\SOLITAIRE.EXE",
                newGame: "> 新游戏", rules: "> 规则_", wiz: "> 提示_", auto: "> 自动_", stop: "> 停止_",
                moves: "移动",
                victory: "> 胜利! <",
                victoryMoves: "用了 {moves} 步",
                rulesTitle: "纸牌接龙规则",
                rulesGoalTitle: "目标:",
                rulesGoalText: "在四个基础牌堆上按从A到K的顺序重新构建四种花色。",
                rulesSetupTitle: "设置:",
                rulesTableauTitle: "游戏区:",
                rulesTableauText: "发7列牌。第一列1张，第二列2张，以此类推。每列的最后一张牌面朝上。",
                rulesStockTitle: "牌库:",
                rulesStockText: "剩下的牌，牌面朝下。",
                rulesFoundationsTitle: "基础牌堆:",
                rulesFoundationsText: "右上角的4个空牌堆，准备好放A。",
                rulesHowToTitle: "怎么玩:",
                rulesMoveTitle: "移动牌:",
                rulesMoveText: "如果目标牌的等级高一级且颜色相反，你可以将一张牌（或一个序列）移动到另一列上。",
                rulesRevealTitle: "翻开牌:",
                rulesRevealText: "当你移动一张面朝上的牌时，它下面的牌（如果有的话）会翻过来。",
                rulesEmptyTitle: "空列:",
                rulesEmptyText: "只有K（或以K开头的序列）可以移动到空列。",
                rulesUseStockTitle: "使用牌库:",
                rulesUseStockText: "点击牌库来抽牌。废牌堆最上面的牌是可以打出的。",
                rulesBuildFoundationsTitle: "构建基础牌堆:",
                rulesBuildFoundationsText: "将从A到K的牌送到基础牌堆。双击是快捷方式。",
            }
        };

        // --- CONFIGURATION ---
        const DRAW_COUNT = 1;

        // --- CONSTANTS & GAME DATA ---
        const SUITS = ['♥', '♦', '♠', '♣'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const RANK_VALUES = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 };

        // --- DOM ELEMENTS ---
        const gameBoardEl = document.getElementById('game-board');
        const movesCountEl = document.getElementById('moves-count');
        const winMessageEl = document.getElementById('win-message');
        const rulesModal = document.getElementById('rules-modal');
        const closeBtn = document.querySelector('.close-btn');
        const langSelector = document.querySelector('.language-selector');

        // --- GAME STATE ---
        let state = {};
        let isAutoPlaying = false;
        let autoPlayTimer = null;
        let currentLanguage = 'fr';

        // --- DRAG STATE ---
        let dragged = { element: null, sourcePile: null, cards: [] };

        // ==================================================================
        //                LANGUAGE & UI
        // ==================================================================
        function setLanguage(lang) {
            if (!translations[lang]) return;
            currentLanguage = lang;
            
            document.querySelectorAll('[data-key]').forEach(el => {
                const key = el.dataset.key;
                if (translations[lang][key]) {
                    el.textContent = translations[lang][key];
                }
            });

            // Update auto button text if it's in 'Stop' state
            const autoBtn = document.getElementById('auto-btn');
            if (isAutoPlaying) {
                autoBtn.textContent = translations[currentLanguage].stop;
            }

            // Update language selector active state
            langSelector.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === lang);
            });
        }

        // ==================================================================
        //                INITIALIZATION AND RENDERING
        // ==================================================================
        
        function initGame() {
            if (isAutoPlaying) {
                toggleAutoPlay();
            }
            state = {
                stock: [],
                waste: [],
                foundations: [[], [], [], []],
                tableau: [[], [], [], [], [], [], []],
                moves: 0,
            };
            const deck = createDeck();
            shuffleDeck(deck);
            dealCards(deck);
            renderAllPiles();
            winMessageEl.style.display = 'none';
        }

        function createBoardStructure() {
            gameBoardEl.innerHTML = `
                <div class="upper-piles">
                    <div class="stock-waste-piles">
                        <div class="pile stock" data-pile-type="stock"></div>
                        <div class="pile waste" data-pile-type="waste"></div>
                    </div>
                    <div class="foundation-piles">
                        ${[0,1,2,3].map(i => `<div class="pile foundation" data-pile-type="foundation" data-pile-index="${i}"></div>`).join('')}
                    </div>
                </div>
                ${[0,1,2,3,4,5,6].map(i => `<div class="pile tableau-pile" data-pile-type="tableau" data-pile-index="${i}"></div>`).join('')}
            `;
        }

        function renderAllPiles() {
            renderStock();
            renderWaste();
            renderFoundations();
            renderTableau();
            updateMoves();
        }

        function createCardElement(card) {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${card.color}`;
            cardEl.dataset.rank = card.rank;
            cardEl.dataset.suit = card.suit;
            
            if (card.faceUp) {
                cardEl.draggable = true;
                cardEl.innerHTML = `
                    <span class="card-rank">${card.rank}</span>
                    <span class="card-suit">${card.suit}</span>
                    <span class="card-suit-bottom">${card.suit}</span>
                `;
            } else {
                cardEl.classList.add('face-down');
            }
            return cardEl;
        }

        function renderStock() {
            const stockPileEl = gameBoardEl.querySelector('.stock');
            stockPileEl.innerHTML = '';
            if (state.stock.length > 0) {
                const cardBack = createCardElement({ faceUp: false });
                stockPileEl.appendChild(cardBack);
            }
        }

        function renderWaste() {
            const wastePileEl = gameBoardEl.querySelector('.waste');
            wastePileEl.innerHTML = '';
            if (state.waste.length > 0) {
                const topCard = state.waste[state.waste.length - 1];
                const cardEl = createCardElement(topCard);
                cardEl.dataset.sourcePile = 'waste';
                wastePileEl.appendChild(cardEl);
            }
        }

        function renderFoundations() {
            state.foundations.forEach((pile, i) => {
                const pileEl = gameBoardEl.querySelector(`.foundation[data-pile-index="${i}"]`);
                pileEl.innerHTML = '';
                if (pile.length > 0) {
                    const topCard = pile[pile.length - 1];
                    const cardEl = createCardElement(topCard);
                    cardEl.dataset.sourcePile = 'foundation';
                    cardEl.dataset.sourceIndex = i;
                    pileEl.appendChild(cardEl);
                }
            });
        }

        function renderTableau() {
            const tableauOffset = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tableau-offset'));
            state.tableau.forEach((pile, i) => {
                const pileEl = gameBoardEl.querySelector(`.tableau-pile[data-pile-index="${i}"]`);
                pileEl.innerHTML = '';
                pile.forEach((card, j) => {
                    const cardEl = createCardElement(card);
                    cardEl.style.top = `${j * tableauOffset}px`;
                    cardEl.dataset.sourcePile = 'tableau';
                    cardEl.dataset.sourceIndex = i;
                    cardEl.dataset.cardIndex = j;
                    pileEl.appendChild(cardEl);
                });
            });
        }

        // ==================================================================
        //                      GAME LOGIC & RULES
        // ==================================================================

        function createDeck() {
            return SUITS.flatMap(suit => 
                RANKS.map(rank => ({
                    suit,
                    rank,
                    color: (suit === '♥' || suit === '♦') ? 'red' : 'black',
                    faceUp: false
                }))
            );
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        function dealCards(deck) {
            for (let i = 0; i < 7; i++) {
                for (let j = 0; j <= i; j++) {
                    state.tableau[i].push(deck.pop());
                }
                state.tableau[i][state.tableau[i].length - 1].faceUp = true;
            }
            state.stock = deck;
        }

        function isValidTableauMove(cardToMove, destPile) {
            if (destPile.length === 0) {
                return cardToMove.rank === 'K';
            }
            const topCard = destPile[destPile.length - 1];
            return cardToMove.color !== topCard.color && RANK_VALUES[cardToMove.rank] === RANK_VALUES[topCard.rank] - 1;
        }

        function isValidFoundationMove(cardToMove, destPile) {
            if (destPile.length === 0) {
                return cardToMove.rank === 'A';
            }
            const topCard = destPile[destPile.length - 1];
            return cardToMove.suit === topCard.suit && RANK_VALUES[cardToMove.rank] === RANK_VALUES[topCard.rank] + 1;
        }

        function handleMove(cards, from, to) {
            const sourceArray = from.type === 'tableau' ? state.tableau[from.index] : state.waste;
            sourceArray.splice(from.cardIndex, cards.length);
            
            const destArray = to.type === 'tableau' ? state.tableau[to.index] : state.foundations[to.index];
            destArray.push(...cards);

            if (from.type === 'tableau' && sourceArray.length > 0) {
                sourceArray[sourceArray.length - 1].faceUp = true;
            }

            state.moves++;
            renderAllPiles();
            checkWinCondition();
        }
        
        function checkWinCondition() {
            const totalInFoundations = state.foundations.reduce((sum, pile) => sum + pile.length, 0);
            if (totalInFoundations === 52) {
                if(isAutoPlaying) toggleAutoPlay();
                winMessageEl.style.display = 'block';
                document.getElementById('win-moves').textContent = translations[currentLanguage].victoryMoves.replace('{moves}', state.moves);
            }
        }

        function updateMoves() {
            movesCountEl.textContent = state.moves;
        }

        // ==================================================================
        //                      HINT & AUTO-PLAY LOGIC
        // ==================================================================

        function findHint() {
            const move = findNextMove();
            if (move && move.element) {
                showHint(move.element);
            }
        }
        
        function showHint(element) {
            element.classList.add('hint');
            setTimeout(() => {
                element.classList.remove('hint');
            }, 600);
        }

        function findNextMove() {
            // 1. Check tableau to foundation
            for (let i = 0; i < state.tableau.length; i++) {
                if (state.tableau[i].length > 0) {
                    const card = state.tableau[i][state.tableau[i].length - 1];
                    for (let j = 0; j < state.foundations.length; j++) {
                        if (isValidFoundationMove(card, state.foundations[j])) {
                            return {
                                cards: [card],
                                from: { type: 'tableau', index: i, cardIndex: state.tableau[i].length - 1 },
                                to: { type: 'foundation', index: j },
                                element: gameBoardEl.querySelector(`[data-pile-type="tableau"][data-pile-index="${i}"] .card:last-child`)
                            };
                        }
                    }
                }
            }
            
            // 2. Check waste to foundation
            if (state.waste.length > 0) {
                const card = state.waste[state.waste.length - 1];
                for (let i = 0; i < state.foundations.length; i++) {
                    if (isValidFoundationMove(card, state.foundations[i])) {
                        return {
                            cards: [card],
                            from: { type: 'waste', index: 0, cardIndex: state.waste.length - 1 },
                            to: { type: 'foundation', index: i },
                            element: gameBoardEl.querySelector('.waste .card')
                        };
                    }
                }
            }

            // 3. Check tableau to tableau
            for (let i = 0; i < state.tableau.length; i++) {
                for (let j = 0; j < state.tableau[i].length; j++) {
                    const card = state.tableau[i][j];
                    if (card.faceUp) {
                        for (let k = 0; k < state.tableau.length; k++) {
                            if (i === k) continue;
                            if (isValidTableauMove(card, state.tableau[k])) {
                                return {
                                    cards: state.tableau[i].slice(j),
                                    from: { type: 'tableau', index: i, cardIndex: j },
                                    to: { type: 'tableau', index: k },
                                    element: gameBoardEl.querySelector(`[data-pile-type="tableau"][data-pile-index="${i}"] .card[data-card-index="${j}"]`)
                                };
                            }
                        }
                    }
                }
            }
            
            // 4. Check waste to tableau
            if (state.waste.length > 0) {
                const card = state.waste[state.waste.length - 1];
                for (let i = 0; i < state.tableau.length; i++) {
                    if (isValidTableauMove(card, state.tableau[i])) {
                        return {
                            cards: [card],
                            from: { type: 'waste', index: 0, cardIndex: state.waste.length - 1 },
                            to: { type: 'tableau', index: i },
                            element: gameBoardEl.querySelector('.waste .card')
                        };
                    }
                }
            }
            return null; // No move found
        }
        
        function autoPlayStep() {
            const move = findNextMove();
            if (move) {
                handleMove(move.cards, move.from, move.to);
                return true;
            }
            
            if (state.stock.length > 0 || state.waste.length > 0) {
                handleStockClick(true); // Pass true to indicate auto play
                return true;
            }

            return false; // No moves possible at all
        }

        function toggleAutoPlay() {
            isAutoPlaying = !isAutoPlaying;
            const autoBtn = document.getElementById('auto-btn');
            if (isAutoPlaying) {
                autoBtn.textContent = translations[currentLanguage].stop;
                gameBoardEl.classList.add('auto-playing');
                autoPlayLoop();
            } else {
                autoBtn.textContent = translations[currentLanguage].auto;
                gameBoardEl.classList.remove('auto-playing');
                if (autoPlayTimer) {
                    clearTimeout(autoPlayTimer);
                    autoPlayTimer = null;
                }
            }
        }

        function autoPlayLoop() {
            if (!isAutoPlaying) return;
            if (autoPlayStep()) {
                autoPlayTimer = setTimeout(autoPlayLoop, 400); // Made slightly faster
            } else {
                toggleAutoPlay(); // Stop if no moves left
            }
        }

        // ==================================================================
        //                      EVENT HANDLERS
        // ==================================================================

        gameBoardEl.addEventListener('click', (e) => {
            if (e.target.closest('.stock')) {
                handleStockClick(false);
            }
        });

        gameBoardEl.addEventListener('dblclick', (e) => {
            const cardEl = e.target.closest('.card:not(.face-down)');
            if (!cardEl) return;

            const { sourcePile, sourceIndex, cardIndex } = cardEl.dataset;
            
            let card, sourceArray;
            if (sourcePile === 'tableau') {
                sourceArray = state.tableau[parseInt(sourceIndex)];
                if (parseInt(cardIndex) !== sourceArray.length - 1) return;
                card = sourceArray[sourceArray.length - 1];
            } else if (sourcePile === 'waste') {
                if (state.waste.length === 0) return;
                sourceArray = state.waste;
                card = sourceArray[sourceArray.length - 1];
            } else {
                return;
            }

            for (let i = 0; i < state.foundations.length; i++) {
                if (isValidFoundationMove(card, state.foundations[i])) {
                    state.foundations[i].push(sourceArray.pop());
                    if (sourcePile === 'tableau' && sourceArray.length > 0) {
                        sourceArray[sourceArray.length - 1].faceUp = true;
                    }
                    state.moves++;
                    renderAllPiles();
                    checkWinCondition();
                    return;
                }
            }
        });

        gameBoardEl.addEventListener('dragstart', (e) => {
            const cardEl = e.target.closest('.card:not(.face-down)');
            if (!cardEl) {
                e.preventDefault();
                return;
            }

            setTimeout(() => cardEl.classList.add('dragging'), 0);
            dragged.element = cardEl;

            const { sourcePile, sourceIndex, cardIndex } = cardEl.dataset;
            const sIndex = parseInt(sourceIndex);
            const cIndex = parseInt(cardIndex);

            dragged.sourcePile = { type: sourcePile, index: sIndex, cardIndex: cIndex };

            if (sourcePile === 'tableau') {
                dragged.cards = state.tableau[sIndex].slice(cIndex);
            } else if (sourcePile === 'waste') {
                dragged.cards = [state.waste[state.waste.length - 1]];
                dragged.sourcePile.cardIndex = state.waste.length - 1;
            }
        });

        gameBoardEl.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        gameBoardEl.addEventListener('drop', (e) => {
            e.preventDefault();
            if (!dragged.element) return;

            const dropTargetEl = e.target.closest('.pile, .card');
            if (!dropTargetEl) return;
            
            let dest;
            if (dropTargetEl.classList.contains('pile')) {
                dest = { type: dropTargetEl.dataset.pileType, index: parseInt(dropTargetEl.dataset.pileIndex) };
            } else {
                dest = { type: dropTargetEl.dataset.sourcePile, index: parseInt(dropTargetEl.dataset.sourceIndex) };
            }
            
            if (!dest || !dest.type || isNaN(dest.index)) return;

            const cardToMove = dragged.cards[0];

            if (dest.type === 'tableau') {
                if (isValidTableauMove(cardToMove, state.tableau[dest.index])) {
                    handleMove(dragged.cards, dragged.sourcePile, dest);
                }
            } else if (dest.type === 'foundation') {
                if (dragged.cards.length === 1 && isValidFoundationMove(cardToMove, state.foundations[dest.index])) {
                    handleMove(dragged.cards, dragged.sourcePile, dest);
                }
            }
        });

        gameBoardEl.addEventListener('dragend', (e) => {
            if (dragged.element) {
                dragged.element.classList.remove('dragging');
            }
            dragged = { element: null, sourcePile: null, cards: [] };
        });

        function handleStockClick(isAuto) {
            if (state.stock.length > 0) {
                const count = Math.min(state.stock.length, DRAW_COUNT);
                for (let i = 0; i < count; i++) {
                    const card = state.stock.pop();
                    card.faceUp = true;
                    state.waste.push(card);
                }
                if (!isAuto) state.moves++; // Increment moves only when drawing manually
            } else if (state.waste.length > 0) {
                state.stock = state.waste.reverse();
                state.stock.forEach(c => c.faceUp = false);
                state.waste = [];
                if (!isAuto) state.moves++; // Also count reset as a move for manual play
            } else {
                return;
            }
            renderAllPiles();
        }

        // --- UI Buttons Handlers ---
        document.getElementById('new-game-btn').addEventListener('click', initGame);
        document.getElementById('rules-btn').addEventListener('click', () => { rulesModal.style.display = 'block'; });
        document.getElementById('wiz-btn').addEventListener('click', findHint);
        document.getElementById('auto-btn').addEventListener('click', toggleAutoPlay);
        closeBtn.addEventListener('click', () => { rulesModal.style.display = 'none'; });
        window.addEventListener('click', (event) => {
            if (event.target == rulesModal) {
                rulesModal.style.display = 'none';
            }
        });
        langSelector.addEventListener('click', (e) => {
            if(e.target.tagName === 'BUTTON') {
                const lang = e.target.dataset.lang;
                setLanguage(lang);
            }
        });

        // --- START GAME ---
        createBoardStructure();
        initGame();
        setLanguage('fr'); // Set initial language
    });
    </script>
</body>
</html>
