<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO & Social Media Meta Tags -->
    <title>Carte Mentale 3D : La Pensée de Michel Clouscard</title>
    <meta name="description" content="Explorez la pensée complexe de Michel Clouscard à travers une carte mentale interactive en 3D. Naviguez dans ses concepts clés, du 'capitalisme de la séduction' à son analyse de Mai 68.">
    <link rel="canonical" href="https://leonce-equity.com/mapmind/index.html" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://leonce-equity.com/mapmind/index.html">
    <meta property="og:title" content="Carte Mentale 3D : La Pensée de Michel Clouscard">
    <meta property="og:description" content="Une visualisation interactive et immersive pour comprendre les concepts fondamentaux du philosophe Michel Clouscard.">
    <meta property="og:image" content="https://leonce-equity.com/mapmind/mapmind.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://leonce-equity.com/mapmind/index.html">
    <meta property="twitter:title" content="Carte Mentale 3D : La Pensée de Michel Clouscard">
    <meta property="twitter:description" content="Une visualisation interactive et immersive pour comprendre les concepts fondamentaux du philosophe Michel Clouscard.">
    <meta property="twitter:image" content="https://leonce-equity.com/mapmind/mapmind.png">

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #020617; /* slate-950 */
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
        .label {
            color: #f1f5f9; /* slate-100 */
            font-size: 14px;
            background: rgba(15, 23, 42, 0.6);
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
            user-select: none;
            transition: opacity 0.2s;
        }
        #bottom-panel {
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateY(100%);
            max-height: 16rem; /* Environ 5-6 lignes de texte */
        }
        #bottom-panel.open {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Panneau de détails en bas -->
    <div id="bottom-panel" class="fixed bottom-0 left-0 right-0 z-40 bg-slate-900/70 text-slate-200 shadow-2xl border-t border-slate-700/50 backdrop-blur-xl">
        <div class="relative p-4 sm:p-6 max-w-4xl mx-auto h-full">
             <button id="close-button" class="absolute top-3 right-3 text-slate-400 hover:text-white p-1 rounded-full">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            <div id="details-content" class="h-full overflow-y-auto pr-8 prose prose-sm prose-invert max-w-none">
                 <!-- Le contenu sera injecté ici -->
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { forceSimulation as d3ForceSimulation, forceLink as d3ForceLink, forceManyBody as d3ForceManyBody, forceCenter as d3ForceCenter } from 'https://cdn.skypack.dev/d3-force-3d';
        import { hierarchy as d3Hierarchy } from 'https://cdn.skypack.dev/d3-hierarchy';
        import { scaleOrdinal as d3ScaleOrdinal } from 'https://cdn.skypack.dev/d3-scale';

        // --- DATA ---
        const originalData = {
          "Michel Clouscard: Pensée Détaillée": {
            "description": "Michel Clouscard (1928-2009) est un philosophe et sociologue marxiste français, reconnu pour sa critique radicale du capitalisme, qu'il nomme 'capitalisme de la séduction'.",
            "I. Contexte et Positionnement": {
              "description": "Né dans une famille modeste du Tarn, sa pensée est enracinée dans la tradition marxiste, enrichie par Rousseau et Hegel.",
              "A. Biographie et Influences": [
                "Né en 1928 à Montpinier, Tarn, décédé en 2009",
                "Issu d'une **famille modeste** (père mineur à Carmaux)",
                "Carrière atypique: **sportif de haut niveau** (présélectionné JO 1948)",
                "**Lignée philosophique**: **Rousseau, Hegel, Marx**"
              ],
              "B. Marginalisation": [
                "Peu connu de son vivant, son œuvre est aujourd'hui redécouverte.",
                "Vladimir Jankélévitch a salué 'Le Capitalisme de la séduction' comme un 'chef-d'œuvre'."
              ],
              "C. Adversaires Intellectuels": [
                "S'oppose au **structuralisme** et critique les intellectuels de 68 (Foucault, Deleuze, etc.).",
                "Rejette le **\"freudo-marxisme\"** comme un pseudo-marxisme."
              ]
            },
            "II. Le Capitalisme de la Séduction": {
              "description": "Concept central de sa critique, développé dans son livre éponyme (1981).",
              "A. Concept Central": [
                "Un capitalisme qui a \"viré à gauche au niveau politico-culturel et à droite au niveau économico-social\"",
                "**\"Tout est permis, mais rien n'est possible\"**: liberté formelle sans les moyens matériels.",
                "**Permissif sur le consommateur, répressif sur le producteur**."
              ],
              "B. Genèse Post-1945": [
                "Le **Plan Marshall** (1947-1951) est un \"cheval de Troie\" des États-Unis.",
                "Contrepartie: **colonisation culturelle** par le modèle américain.",
                "Montée des **nouvelles classes moyennes** (ingénieurs, cadres, etc.)."
              ],
              "C. Mai 68: Révolution de Palais": [
                "Une **mutation du capitalisme**, pas une contestation.",
                "**Alliance du libéral (Pompidou) et du libertaire (Cohn-Bendit)** contre le conservatisme (De Gaulle).",
                "Le **sociétal** (libération des mœurs) a masqué le **social** (plus grande grève ouvrière de l'histoire)."
              ],
              "D. Le \"Dressage Anthropologique\"": {
                "description": "Processus d'initiation à la civilisation capitaliste.",
                "Niveaux d'initiation": [
                    "1. Ludique (enfance): Flippers, juke-box",
                    "2. Libidinal (adolescence): Jeans, cheveux longs",
                    "3. Animation Machinale: Musique Rock/Disco",
                    "4. Marginal: Drogues, liberté sexuelle",
                    "5. Intégration par la technologie: Moto, Hi-fi"
                ],
                "Le \"Mondain\"": ["Laboratoire des nouveaux modèles culturels transgressifs qui deviendront les normes."],
                "Mythe de la \"société de consommation\"": ["Seule une minorité consomme le luxe, la majorité produit."]
              }
            },
            "III. Propositions et Solutions": {
              "description": "Clouscard esquisse des pistes pour une société plus juste.",
              "A. Morale Socialiste": [
                "Réconcilier la **praxis (travail) et la psyché (vécu)**.",
                "Équilibre production/consommation: \"Tu ne consommeras pas plus que tu ne produis\"."
              ],
              "B. Structure de l'État": [
                "**Défense de l'État-nation** contre la mondialisation.",
                "**Parlement du Travailleur Collectif**: une chambre des producteurs."
              ]
            },
            "IV. Critiques Adressées": {
              "description": "Sa pensée radicale a suscité des critiques.",
              "A. Vision de Mai 68": ["Analyse jugée unilatérale, proche de la ligne du PCF de l'époque."],
              "B. 'Stalinisme'": ["Accusé d'une polémique de style stalinien."],
              "C. Manque de propositions concrètes": ["Reproche de ne pas avoir proposé un modèle de société clé en main."],
              "D. Angles morts": ["Peu d'intérêt pour l'écologie ou les combats \"minoritaires\" (féminisme, antiracisme)."]
            }
          }
        };

        // --- SETUP ---
        let scene, camera, renderer, labelRenderer, controls;
        const container = document.getElementById('container');
        const bottomPanel = document.getElementById('bottom-panel');
        const detailsContent = document.getElementById('details-content');
        const closeButton = document.getElementById('close-button');
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredNode = null;

        const colorScale = d3ScaleOrdinal([ "#a78bfa", "#f87171", "#4ade80", "#fb923c", "#38bdf8" ]);

        let graph = { nodes: [], links: [] };
        const nodeObjects = new Map();

        // --- DATA TRANSFORMATION ---
        function transformData(obj, name) {
            const newNode = { name };
            if (Array.isArray(obj)) {
                newNode.description = `<ul>${obj.map(item => `<li>${item}</li>`).join('')}</ul>`;
                return newNode;
            }
            if (typeof obj === 'object' && obj !== null) {
                const keys = Object.keys(obj);
                const childrenKeys = keys.filter(key => key !== 'description');
                if (obj.description) {
                    newNode.description = obj.description;
                }
                if (childrenKeys.length > 0) {
                    newNode.children = childrenKeys.map(key => transformData(obj[key], key));
                }
            }
            return newNode;
        }

        const rootKey = Object.keys(originalData)[0];
        const data = transformData(originalData[rootKey], rootKey);


        function init() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 450;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            container.appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, labelRenderer.domElement);
            controls.enableDamping = true;
            controls.minDistance = 100;
            controls.maxDistance = 800;

            // Lights & Stars
            scene.add(new THREE.AmbientLight(0xbbbbbb));
            scene.add(new THREE.DirectionalLight(0xffffff, 1.5));
            const pointLight1 = new THREE.PointLight(0xa78bfa, 500, 2000);
            pointLight1.position.set(100, 200, 300);
            scene.add(pointLight1);
            const pointLight2 = new THREE.PointLight(0xf87171, 500, 2000);
            pointLight2.position.set(-200, -150, -250);
            scene.add(pointLight2);
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                starVertices.push(THREE.MathUtils.randFloatSpread(2000));
                starVertices.push(THREE.MathUtils.randFloatSpread(2000));
                starVertices.push(THREE.MathUtils.randFloatSpread(2000));
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0x64748b, size: 0.7 });
            scene.add(new THREE.Points(starGeometry, starMaterial));

            buildGraph();
            updateGraph();

            window.addEventListener('resize', onWindowResize);
            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('click', onNodeClick);
            container.addEventListener('dblclick', onNodeDblClick);
            closeButton.addEventListener('click', closePanel);

            animate();
        }

        function buildGraph() {
            const root = d3Hierarchy(data);
            graph.nodes = root.descendants();
            graph.links = root.links();

            graph.nodes.forEach(node => {
                if (node.depth === 1) node.color = colorScale(node.data.name);
                else if (node.depth > 1) node.color = node.parent.color;
                else node.color = '#94a3b8';
                
                // Start fully expanded
                node.hidden = false;
                if (node.children) {
                    node._children = node.children;
                }
            });
        }

        function updateGraph() {
            const visibleNodes = graph.nodes.filter(n => !n.hidden);
            const visibleLinks = graph.links.filter(l => !l.source.hidden && !l.target.hidden);

            nodeObjects.forEach(obj => {
                if (obj.mesh) scene.remove(obj.mesh);
                if (obj.label) obj.mesh.remove(obj.label);
            });
            nodeObjects.clear();
            if (scene.getObjectByName('linksGroup')) scene.remove(scene.getObjectByName('linksGroup'));

            visibleNodes.forEach(node => {
                const isExpandable = !!(node.children || node._children);
                const isCollapsed = !!node._children && !node.children;
                
                const geometry = new THREE.SphereGeometry(node.depth === 0 ? 10 : 6, 32, 32);
                const material = new THREE.MeshPhysicalMaterial({
                    color: node.color,
                    transmission: isCollapsed ? 0 : 0.95,
                    thickness: isCollapsed ? 0 : 2.0,
                    roughness: 0.1,
                    metalness: 0.05,
                    ior: 1.5,
                    specularIntensity: 1,
                    transparent: true,
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData.node = node;
                scene.add(mesh);

                const labelDiv = document.createElement('div');
                labelDiv.className = 'label';
                labelDiv.textContent = node.data.name;
                const label = new CSS2DObject(labelDiv);
                label.position.set(0, 12, 0);
                mesh.add(label);

                nodeObjects.set(node, { mesh, label });
            });
            
            const linksGroup = new THREE.Group();
            linksGroup.name = 'linksGroup';
            visibleLinks.forEach(link => {
                const material = new THREE.LineBasicMaterial({ color: 0x94a3b8, transparent: true, opacity: 0.5 });
                const geometry = new THREE.BufferGeometry();
                const line = new THREE.Line(geometry, material);
                line.userData.link = link;
                linksGroup.add(line);
            });
            scene.add(linksGroup);

            const simulation = d3ForceSimulation(visibleNodes, 3)
                .force('link', d3ForceLink(visibleLinks).distance(d => d.source.depth * 10 + 60).strength(0.8))
                .force('charge', d3ForceManyBody().strength(-200))
                .force('center', d3ForceCenter())
                .on('tick', () => {
                    visibleNodes.forEach(node => {
                        const { x, y, z } = node;
                        const obj = nodeObjects.get(node);
                        if (obj) obj.mesh.position.set(x, y, z);
                    });
                    linksGroup.children.forEach(line => {
                        const { source, target } = line.userData.link;
                        const points = [
                            new THREE.Vector3(source.x, source.y, source.z),
                            new THREE.Vector3(target.x, target.y, target.z)
                        ];
                        const curve = new THREE.CatmullRomCurve3(points);
                        line.geometry.setFromPoints(curve.getPoints(10));
                    });
                });
        }
        
        function getIntersectedObject(event) {
            if (bottomPanel.contains(event.target)) return null;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Array.from(nodeObjects.values()).map(o => o.mesh));
            return intersects.length > 0 ? intersects[0].object : null;
        }

        function onMouseMove(event) {
            const intersected = getIntersectedObject(event);
            if (hoveredNode && hoveredNode !== intersected) {
                const obj = nodeObjects.get(hoveredNode.userData.node);
                if (obj) obj.mesh.scale.set(1, 1, 1);
            }
            if (intersected) {
                document.body.style.cursor = 'pointer';
                const obj = nodeObjects.get(intersected.userData.node);
                if (obj) obj.mesh.scale.set(1.3, 1.3, 1.3);
                hoveredNode = intersected;
            } else {
                document.body.style.cursor = 'default';
                hoveredNode = null;
            }
        }

        function onNodeClick(event) {
            const intersected = getIntersectedObject(event);
            if (intersected) {
                const node = intersected.userData.node;
                openPanel(node);
            } else {
                if (!bottomPanel.contains(event.target)) {
                    closePanel();
                }
            }
        }
        
        function openPanel(node) {
            const detailsText = node.data.description;
            let content = `<h3 class="text-xl font-bold mb-1" style="color:${node.color || '#1e293b'}">${node.data.name}</h3>`;
            if (detailsText) {
                const formattedDetails = detailsText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                content += `<div class="prose prose-sm prose-invert mt-2 max-w-none">${formattedDetails}</div>`;
            } else {
                content += `<p class="italic mt-2 text-slate-400">Double-cliquez sur ce nœud pour explorer ou replier ses concepts enfants.</p>`;
            }
            detailsContent.innerHTML = content;
            bottomPanel.classList.add('open');
        }

        function closePanel() {
            bottomPanel.classList.remove('open');
        }

        function onNodeDblClick(event) {
            const intersected = getIntersectedObject(event);
            if (intersected) {
                const node = intersected.userData.node;
                if (!node._children && !node.children) return;
                
                if (node.children) { // Collapse
                    node.descendants().slice(1).forEach(child => child.hidden = true);
                    node.children = null;
                } else { // Expand
                    node.children = node._children;
                    node.children.forEach(child => {
                        child.hidden = false;
                        if(child.children) {
                             child.descendants().slice(1).forEach(grandchild => grandchild.hidden = true);
                        }
                    });
                }
                updateGraph();
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
