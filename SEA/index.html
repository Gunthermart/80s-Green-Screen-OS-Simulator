<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tableau de Bord Interactif - Simulation d'Aquarium</title>
    <!-- Métadonnées SEO pour les moteurs de recherche -->
    <meta name="description" content="Explorez une simulation d'aquarium interactive en 3D avec un écosystème dynamique. Contrôlez l'environnement et observez les poissons interagir, se reproduire et évoluer. Une expérience immersive pour les passionnés de biologie marine.">
    <meta name="keywords" content="simulation, aquarium, 3D, interactif, écosystème, poissons, vie marine, biodiversité, prédateurs, reproduction, environnement, tableau de bord">
    
    <!-- Balises Open Graph pour les réseaux sociaux (Facebook, LinkedIn, etc.) -->
    <meta property="og:title" content="Tableau de Bord Interactif - Simulation d'Aquarium">
    <meta property="og:description" content="Explorez une simulation d'aquarium interactive en 3D avec un écosystème dynamique. Contrôlez l'environnement et observez les poissons interagir, se reproduire et évoluer. Une expérience immersive pour les passionnés de biologie marine.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://leonce-equity.com/sea/">
    <meta property="og:image" content="https://leonce-equity.com/sea/aquarium.png">

    <!-- Balises Twitter Card pour le partage sur Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Tableau de Bord Interactif - Simulation d'Aquarium">
    <meta name="twitter:description" content="Explorez une simulation d'aquarium interactive en 3D avec un écosystème dynamique. Contrôlez l'environnement et observez les poissons interagir, se reproduire et évoluer. Une expérience immersive pour les passionnés de biologie marine.">
    <meta name="twitter:image" content="https://leonce-equity.com/sea/aquarium.png">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.132.2/three.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" xintegrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.skypack.dev/three@0.132.2",
            "orbit-controls": "https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js"
        }
    }
    </script>
    <script>
    tailwind.config = {
        theme: {
            extend: {
                colors: {
                    primary: {
                        50: '#e0f7fa',
                        100: '#b2ebf2',
                        200: '#80deea',
                        300: '#4dd0e1',
                        400: '#26c6da',
                        500: '#00bcd4',
                        600: '#00acc1',
                        700: '#0097a7',
                        800: '#00838f',
                        900: '#006064'
                    },
                    secondary: {
                        50: '#e0f2f1',
                        100: '#b2dfdb',
                        200: '#80cbc4',
                        300: '#4db6ac',
                        400: '#26a69a',
                        500: '#009688',
                        600: '#00897b',
                        700: '#00796b',
                        800: '#00695c',
                        900: '#004d40'
                    },
                    accent: {
                        50: '#fff8e1',
                        100: '#ffecb3',
                        200: '#ffe082',
                        300: '#ffd54f',
                        400: '#ffca28',
                        500: '#ffc107',
                        600: '#ffb300',
                        700: '#ffa000',
                        800: '#ff8f00',
                        900: '#ff6f00'
                    },
                    deep: {
                        blue: '#0a3d62',
                        teal: '#1e3799'
                    }
                },
                animation: {
                    'float': 'floating 3s ease-in-out infinite',
                    'glow': 'glowing 2s ease-in-out infinite'
                },
                keyframes: {
                    floating: {
                        '0%, 100%': { transform: 'translateY(0)' },
                        '50%': { transform: 'translateY(-10px)' }
                    },
                    glowing: {
                        '0%, 100%': { boxShadow: '0 0 5px 2px rgba(59, 130, 246, 0.3)' },
                        '50%': { boxShadow: '0 0 15px 5px rgba(59, 130, 246, 0.5)' }
                    }
                }
            }
        }
    }
    </script>
    <style>
        body { 
            font-family: 'Montserrat', sans-serif; 
            background: linear-gradient(135deg, #0a3d62 0%, #1e3799 100%);
        }

        /* Custom Scrollbar */
        .sidebar-scrollbar::-webkit-scrollbar { width: 6px; }
        .sidebar-scrollbar::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 20px; }
        .sidebar-scrollbar::-webkit-scrollbar-thumb { 
            background: linear-gradient(to bottom, #38ada9, #78e08f);
            border-radius: 20px; 
        }
        
        /* Glass effect */
        .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px); 
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .glass-dark {
            background: rgba(10, 25, 47, 0.7);
            backdrop-filter: blur(12px); 
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Accordion animations */
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s cubic-bezier(0, 1, 0, 1);
        }
        .accordion-content.open {
            transition: max-height 1s ease-in-out;
        }
        
        /* Custom range slider styling */
        input[type=range] { 
            -webkit-appearance: none; 
            background: transparent; 
            width: 100%; 
            margin: 10px 0;
        }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; 
            height: 6px; 
            cursor: pointer; 
            background: linear-gradient(to right, #38ada9, #78e08f);
            border-radius: 10px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; 
            height: 20px; 
            width: 20px; 
            border-radius: 50%; 
            background: #ffffff;
            border: 2px solid #38ada9;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer; 
            margin-top: -7px;
            transition: all 0.2s ease;
        }
        input[type=range]:hover::-webkit-slider-thumb {
            box-shadow: 0 0 10px rgba(56, 173, 169, 0.5);
            transform: scale(1.1);
        }
        input[type=range]:disabled::-webkit-slider-thumb { 
            background: #9ca3af; 
            transform: none;
            border-color: #9ca3af;
        }
        input[type=range]:disabled::-webkit-slider-runnable-track {
            background: #4b5563;
        }
        
        /* Disabled states */
        #controls-sidebar *:disabled, #mobile-controls-drawer *:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        /* Canvas settings */
        #simulation-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        /* Language button styling */
        .lang-btn {
            background-color: rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .lang-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        .lang-btn.active {
            background-color: #38ada9;
            color: white;
            box-shadow: 0 4px 12px rgba(56, 173, 169, 0.4);
            border: 1px solid #38ada9;
        }
        
        /* Event log animations */
        #event-log-container {
            transition: all 0.3s ease-in-out;
        }
        #event-log-container:hover #full-log {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        #latest-event-text {
            transition: opacity 0.5s ease-in-out;
        }
        
        /* Icon animations */
        .icon-pulse {
            animation: pulse 1s 2;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.25); }
        }
        
        /* Additional animations */
        .save-feedback {
            transition: opacity 0.5s ease-in-out;
        }
        
        /* Button effects */
        .btn {
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        .btn:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }
        .btn:hover:after {
            width: 200%;
            height: 200%;
        }
        
        /* Underwater lighting effect */
        .underwater-light {
            position: fixed;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, rgba(56, 173, 169, 0.1), transparent 70%);
            pointer-events: none;
            z-index: 2;
            opacity: 0.6;
        }
        
        /* Wave animation */
        .wave {
            position: absolute;
            width: 100%;
            height: 10px;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: wave 8s linear infinite;
            opacity: 0.5;
        }
        .wave:nth-child(1) { top: 20%; animation-delay: 0s; }
        .wave:nth-child(2) { top: 45%; animation-delay: 2s; }
        .wave:nth-child(3) { top: 70%; animation-delay: 4s; }
        
        @keyframes wave {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* Fish icon styles */
        .fish-icon {
            display: inline-block;
            margin-right: 5px;
            animation: fishSwim 3s ease-in-out infinite;
        }
        
        @keyframes fishSwim {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(5px); }
        }

        /* Stats counter animation */
        .stats-counter {
            transition: all 0.3s ease;
        }
        .stats-counter.updated {
            color: #38ada9;
            transform: scale(1.2);
        }

        /* Adjusted styles for better contrast */
        .fecundity-value {
            color: #d1d5db; /* gray-300 for contrast */
        }
        .param-label {
            color: #e5e7eb; /* gray-200 for contrast */
        }
        #latest-event {
            width: 320px; /* Ajout d'une largeur fixe pour éviter l'effet de scintillement */
        }
    </style>
</head>
<body class="text-gray-100 antialiased overflow-hidden">

    <div id="app-container" class="relative w-full h-screen overflow-hidden">
        <div class="underwater-light"></div>
        <div class="wave"></div>
        <div class="wave"></div>
        <div class="wave"></div>
        <canvas id="simulation-canvas"></canvas>

        <!-- Panneau de statistiques pour mobile -->
        <header id="mobile-header" class="fixed top-4 left-1/2 -translate-x-1/2 z-20 transition-all duration-300 block lg:hidden w-11/12 max-w-md">
            <div class="glass rounded-2xl shadow-xl p-3">
                <div id="stats-mobile" class="flex justify-around items-center text-sm text-center">
                    <div>
                        <div class="relative flex items-center justify-center">
                            <i class="fa-solid fa-fish text-primary-300 fish-icon"></i>
                            <span class="font-bold text-white stats-counter fish-count">0</span>
                        </div>
                        <span class="block text-xs text-primary-200" data-lang-key="fish_count_label">Poissons</span>
                    </div>
                    <div class="border-l border-primary-700/50 h-8"></div>
                    <div>
                        <div class="relative flex items-center justify-center">
                            <i class="fa-solid fa-skull text-accent-300 fish-icon"></i>
                            <span class="font-bold text-white stats-counter predator-count">0</span>
                        </div>
                        <span class="block text-xs text-primary-200" data-lang-key="predator_count_label">Prédateurs</span>
                    </div>
                    <div class="border-l border-primary-700/50 h-8"></div>
                     <div>
                        <div class="relative flex items-center justify-center">
                            <i class="fa-solid fa-egg text-secondary-300 fish-icon"></i>
                            <span class="font-bold text-secondary-300 stats-counter birth-count">0</span>
                        </div>
                        <span class="block text-xs text-primary-200" data-lang-key="births_label">Naissances</span>
                    </div>
                </div>
            </div>
        </header>

        <!-- Panneau de statistiques pour PC -->
        <header id="main-header" class="fixed top-4 right-4 z-20 transition-all duration-300 hidden lg:block">
            <div class="glass rounded-2xl shadow-xl p-3">
                <div id="stats-desktop" class="flex flex-col sm:flex-row items-center space-y-2 sm:space-y-0 sm:space-x-4 text-sm text-center">
                    <div>
                        <div class="relative flex items-center justify-center">
                            <i class="fa-solid fa-fish text-primary-300 fish-icon"></i>
                            <span class="font-bold text-white stats-counter fish-count">0</span>
                        </div>
                        <span class="block text-xs text-primary-200" data-lang-key="fish_count_label">Poissons</span>
                    </div>
                    <div class="border-b sm:border-l sm:border-b-0 border-primary-700/50 h-8 w-full sm:w-auto"></div>
                    <div>
                        <div class="relative flex items-center justify-center">
                            <i class="fa-solid fa-skull text-accent-300 fish-icon"></i>
                            <span class="font-bold text-white stats-counter predator-count">0</span>
                        </div>
                        <span class="block text-xs text-primary-200" data-lang-key="predator_count_label">Prédateurs</span>
                    </div>
                    <div class="border-b sm:border-l sm:border-b-0 border-primary-700/50 h-8 w-full sm:w-auto"></div>
                    <div class="hidden sm:block">
                        <span class="font-bold text-white stats-counter prey-predator-ratio">N/A</span>
                        <span class="block text-xs text-primary-200">Ratio Proie/Préd.</span>
                    </div>
                    <div class="hidden sm:block border-l border-primary-700/50 h-8"></div>
                    <div class="hidden md:block">
                        <div class="relative flex items-center justify-center">
                            <i class="fa-solid fa-egg text-secondary-300 fish-icon"></i>
                            <span class="font-bold text-secondary-300 stats-counter birth-count">0</span>
                        </div>
                        <span class="block text-xs text-primary-200" data-lang-key="births_label">Naissances</span>
                    </div>
                    <div class="hidden md:block border-l border-primary-700/50 h-8"></div>
                    <div class="hidden md:block">
                        <div class="relative flex items-center justify-center">
                            <i class="fa-solid fa-skull-crossbones text-accent-400 fish-icon"></i>
                            <span class="font-bold text-accent-400 stats-counter death-count">0</span>
                        </div>
                        <span class="block text-xs text-primary-200" data-lang-key="deaths_label">Morts</span>
                    </div>
                </div>
            </div>
        </header>

        <aside id="controls-sidebar" class="fixed top-0 left-0 z-30 w-80 h-screen glass-dark shadow-xl transition-transform duration-300 -translate-x-full pt-24 pb-8">
            <div class="h-full overflow-y-auto sidebar-scrollbar px-6">
                <div id="accordion-container" class="space-y-3"></div>
            </div>
        </aside>
        
        <!-- Conteneur pour le tiroir mobile -->
        <div id="mobile-controls-container" class="lg:hidden fixed bottom-0 left-0 right-0 z-30 pointer-events-none">
            <div id="mobile-controls-drawer" class="w-full glass-dark rounded-t-2xl shadow-xl transition-transform duration-500 translate-y-full max-h-[75vh] overflow-y-auto pointer-events-auto">
                <div class="p-5" id="mobile-accordion-container"></div>
            </div>
        </div>


        <div id="welcome-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-deep-blue/90 backdrop-blur-md">
            <div class="glass relative overflow-hidden rounded-2xl shadow-2xl w-full max-w-2xl max-h-[90vh] md:max-h-none p-6 m-4 transform transition-all duration-500 scale-95 opacity-0 flex flex-col">
                <div class="absolute -bottom-20 -right-20 w-64 h-64 bg-primary-500/20 rounded-full blur-3xl pointer-events-none"></div>
                <div class="absolute -top-20 -left-20 w-64 h-64 bg-secondary-500/10 rounded-full blur-3xl pointer-events-none"></div>
                
                <div class="relative z-10 flex-grow overflow-y-auto">
                    <h2 class="text-xl md:text-3xl font-bold text-white mb-2 flex items-center">
                        <i class="fa-solid fa-water mr-3 text-primary-400"></i>
                        Bienvenue dans la Simulation d'Aquarium
                    </h2>
                    <p class="text-primary-100 text-sm md:text-base mb-4">
                        Explorez un écosystème 3D dynamique. Observez les poissons naître, grandir et interagir. Utilisez les contrôles pour façonner leur monde.
                    </p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 text-xs md:text-sm">
                        <div class="flex items-center space-x-3 p-3 glass rounded-xl animate-float">
                            <i class="fa-solid fa-seedling text-xl text-secondary-400"></i>
                            <span class="text-white" data-lang-key="feature_lifecycle">Cycle de vie complet et système de prédation.</span>
                        </div>
                        <div class="flex items-center space-x-3 p-3 glass rounded-xl animate-float" style="animation-delay: 0.5s">
                            <i class="fa-solid fa-sliders text-xl text-secondary-400"></i>
                            <span class="text-white" data-lang-key="feature_controls">Contrôles avancés sur l'environnement et les espèces.</span>
                        </div>
                    </div>
    
                    <div class="glass rounded-xl mb-4 overflow-hidden">
                        <div class="bg-primary-900/50 py-2 px-3">
                            <h3 class="font-bold text-primary-300 text-sm md:text-base">
                                <i class="fa-solid fa-lightbulb mr-2"></i>
                                Guide Rapide
                            </h3>
                        </div>
                        <div class="p-3">
                            <ul class="space-y-2 text-xs md:text-sm">
                                <li class="flex items-start">
                                    <i class="fa-solid fa-computer-mouse mt-1 mr-3 text-accent-400"></i>
                                    <span class="text-primary-100" data-lang-key="tip_explore">Faites glisser pour faire pivoter la caméra et utilisez la molette pour zoomer.</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fa-solid fa-gauge-high mt-1 mr-3 text-accent-400"></i>
                                    <span class="text-primary-100" data-lang-key="tip_fertility">Ajustez les paramètres dans la barre latérale pour voir leur impact en temps réel.</span>
                                </li>
                                <li class="flex items-start">
                                    <i class="fa-solid fa-dragon mt-1 mr-3 text-accent-400"></i>
                                    <span class="text-primary-100" data-lang-key="tip_predator">Libérez le super-prédateur pour un défi supplémentaire !</span>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
                    
                <div class="relative z-10 flex-shrink-0 flex flex-wrap justify-between items-center gap-2 mt-4">
                    <div id="lang-selector" class="flex items-center space-x-1 glass rounded-xl p-1.5">
                        <button data-lang="en" class="lang-btn px-2 py-1 text-xs md:px-3 md:py-1.5 md:text-sm font-medium rounded-lg transition-all">EN</button>
                        <button data-lang="fr" class="lang-btn px-2 py-1 text-xs md:px-3 md:py-1.5 md:text-sm font-medium rounded-lg transition-all">FR</button>
                        <button data-lang="es" class="lang-btn px-2 py-1 text-xs md:px-3 md:py-1.5 md:text-sm font-medium rounded-lg transition-all">ES</button>
                        <button data-lang="de" class="lang-btn px-2 py-1 text-xs md:px-3 md:py-1.5 md:text-sm font-medium rounded-lg transition-all">DE</button>
                        <button data-lang="zh" class="lang-btn px-2 py-1 text-xs md:px-3 md:py-1.5 md:text-sm font-medium rounded-lg transition-all">ZH</button>
                    </div>
                    <div class="flex items-center space-x-2">
                        <label class="flex items-center text-xs md:text-sm text-primary-100 cursor-pointer">
                            <input type="checkbox" id="dont-show-again" class="h-3 w-3 md:h-4 md:w-4 rounded border-primary-400 text-secondary-500 focus:ring-secondary-500">
                            <span class="ml-1 md:ml-2" data-lang-key="dont_show_again">Ne plus afficher</span>
                        </label>
                        <button id="start-simulation-btn" class="btn px-4 py-2 text-sm md:px-6 md:py-2.5 md:font-semibold bg-gradient-to-r from-secondary-600 to-primary-600 text-white rounded-xl shadow-lg hover:shadow-primary-500/50 focus:outline-none transition-all transform hover:-translate-y-1" data-lang-key="start_simulation">
                            <i class="fa-solid fa-play mr-2"></i>
                            Démarrer la Simulation
                        </button>
                    </div>
                </div>
                <div class="mt-4 text-xs text-center text-primary-200/50">
                    (C) EXJV
                </div>
            </div>
        </div>

        <div id="event-log-container" class="fixed bottom-4 right-4 z-40 transition-all duration-300">
            <div id="full-log" class="absolute bottom-full mb-3 w-80 h-64 glass-dark rounded-xl p-3 text-xs font-mono text-white opacity-0 transform translate-y-4 pointer-events-none transition-all duration-300 overflow-y-auto sidebar-scrollbar">
                <div class="text-primary-300 text-sm mb-2 font-semibold flex items-center">
                    <i class="fa-solid fa-history mr-2"></i>
                    Journal des événements
                </div>
                <div id="log-content" class="space-y-2 pt-1"></div>
            </div>
            <div id="latest-event" class="flex items-center h-12 px-4 glass-dark rounded-full shadow-xl hover:animate-glow transition-all duration-300 cursor-pointer transform hover:scale-105">
                <span id="latest-event-icon" class="mr-3 text-lg">⚪</span>
                <span id="latest-event-text" class="text-white text-sm"></span>
            </div>
        </div>
        
        <!-- Ajout d'un bouton pour basculer le tiroir mobile -->
        <div id="mobile-toggle-btn" class="fixed bottom-4 left-4 z-40 block lg:hidden">
            <button class="glass rounded-full h-16 w-16 flex items-center justify-center shadow-xl text-2xl transition-all duration-300 hover:shadow-primary-500/50 transform hover:scale-110">
                <i class="fa-solid fa-list-ul text-primary-300"></i>
            </button>
        </div>

        <!-- En mode PC, ce conteneur de boutons sera masqué -->
        <div id="ui-toggle-cluster" class="fixed top-4 left-4 z-50 flex space-x-3 hidden lg:flex">
            <!-- Bouton pour les statistiques, visible sur PC -->
            <button data-target="main-header" class="ui-toggle-btn glass rounded-full h-12 w-12 flex items-center justify-center shadow-xl text-xl transition-all duration-300 opacity-100 hover:shadow-primary-500/50 transform hover:scale-110">
                <i class="fa-solid fa-chart-column text-primary-300"></i>
            </button>
            <!-- Bouton pour les contrôles, visible sur PC -->
            <button data-target="controls-sidebar" class="ui-toggle-btn glass rounded-full h-12 w-12 flex items-center justify-center shadow-xl text-xl transition-all duration-300 opacity-50 hover:shadow-primary-500/50 transform hover:scale-110">
                <i class="fa-solid fa-list-ul text-primary-300"></i>
            </button>
            <!-- Bouton pour les notifications, visible sur PC -->
            <button data-target="event-log-container" class="ui-toggle-btn glass rounded-full h-12 w-12 flex items-center justify-center shadow-xl text-xl transition-all duration-300 opacity-100 hover:shadow-primary-500/50 transform hover:scale-110">
                <i class="fa-solid fa-bell text-primary-300"></i>
            </button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'orbit-controls';
        
        // --- Global variables for the simulation ---
        let scene, camera, renderer, controls, superPredator, submarine, autoModeManager;
        // Utilisez des tableaux typés pour une meilleure performance et un meilleur contrôle de la mémoire
        let boids = [], eggs = [], food = [], rocks = [], plants = [], particles = [];
        const worldSize = { width: 500, height: 250, depth: 350 };
        let aquariumBox, lastFrameTime = 0, isSubmarineViewActive = false, isAutoModeActive = false;
        let diseaseEventTriggered = false;
        let criticalDiseaseTriggered = false;
        let fishMarkedForCull = [];
        let diseaseSpreadCounter = 0;
        let latestEventTimeout;
        let lastStatsUpdateTime = 0;

        // --- OPTIMIZATION: Cache DOM elements for quick access ---
        const dom = {};

        // --- OPTIMIZATION: Reusable Vector3 objects to avoid garbage collection ---
        const tempVec3 = new THREE.Vector3();
        const desiredVelocity = new THREE.Vector3();
        const steerForce = new THREE.Vector3();

        // --- Simulation state and configuration ---
        const simulationStats = { preyEaten: 0, eggsLaid: {}, babiesHatched: {}, maxGeneration: {}, totalBirths: 0, totalDeaths: 0 };
        const flockingForces = { alignment: 0.4, cohesion: 0.3, separation: 1.2 };
        const environmentSettings = { rockCount: 15, plantCount: 60 };

        const fishSpecies = {
            'cichla': { type: 'predator', count: 4, color: 0xef4444, scale: 1.4, maxSpeed: 0.7, perceptionRadius: 120, riskAssessment: { maxDistance: 150, maxGroupSize: 5 }, fertility: 0.01, vertices: new Float32Array([0,0,0, -18,0,0, -5,4,0, -5,-4,0, -18,0,0, -25,2,0, -25,-2,0]) },
            'tetra': { type: 'prey', count: 50, color: 0xec4899, scale: 0.45, maxSpeed: 0.4, perceptionRadius: 35, fearRadius: 80, fertility: 0.03, vertices: new Float32Array([0,0,0, -6,2.5,0, -12,0,0, 0,0,0, -12,0,0, -6,-2.5,0, -12,0,0, -16,4,0, -16,-4,0]) },
            'barbus': { type: 'prey', count: 45, color: 0xf97316, scale: 0.6, maxSpeed: 0.4, perceptionRadius: 40, fearRadius: 85, fertility: 0.05, vertices: new Float32Array([0,0,0, -6,2.5,0, -12,0,0, 0,0,0, -12,0,0, -6,-2.5,0, -12,0,0, -16,4,0, -16,-4,0]) },
            'rasbora': { type: 'prey', count: 50, color: 0x06b6d4, scale: 0.45, maxSpeed: 0.4, perceptionRadius: 30, fearRadius: 70, fertility: 0.06, vertices: new Float32Array([0,0,0, -7,3,0, -14,0,0, 0,0,0, -14,0,0, -7,-3,0, -14,0,0, -18,5,0, -18,-5,0]) },
            'angel': { type: 'prey', count: 25, color: 0x8b5cf6, scale: 0.6, maxSpeed: 0.35, perceptionRadius: 35, fearRadius: 75, fertility: 0.03, vertices: new Float32Array([0,0,0, -5,5,0, -10,0,0, 0,0,0, -10,0,0, -5,-5,0, -10,0,0, -13,3,0, -10,0,0, -13,-3,0]) }
        };

        // --- Translation data for multiple languages ---
        const translations = {
            fr: {
                species: "Espèces", parameters: "Paramètres", fish_count_label: "Poissons", predator_count_label: "Prédateurs", ropefish_status_label: "Super-Prédateur", active: "ACTIF", inactive: "INACTIF", release_ropefish: "Libérer Super-Prédateur", remove_ropefish: "Retirer Super-Prédateur", feed: "Nourrir", save: "Sauvegarder", reset: "Réinitialiser la Simulation", load_save: "Restaurer la Sauvegarde", clear_save: "Effacer la Sauvegarde", forces: "Forces de Groupe", environment: "Environnement", statistics: "Statistiques", actions: "Actions", system: "Système", count: "Nombre", scale: "Taille", max_speed: "Vitesse Max", perception_radius: "Perception", fear_radius: "Rayon Fuite", fertility: "Fécondité", alignment: "Alignement", cohesion: "Cohésion", separation: "Séparation", rock_count: "Rochers", plant_count: "Plantes", prey_eaten: "Proies mangées", eggs_laid: "Œufs pondus", babies_hatched: "Bébés nés", generation: "Génération Max", welcome_title: "Bienvenue dans la Simulation d'Aquarium", welcome_description: "Explorez un écosystème 3D dynamique. Observez les poissons naître, grandir et interagir. Utilisez les contrôles pour façonner leur monde.", feature_lifecycle: "Cycle de vie complet et système de prédation.", feature_controls: "Contrôles avancés sur l'environnement et les espèces.", quick_tips_title: "Guide Rapide", tip_explore: "Faites glisser pour faire pivoter la caméra et utilisez la molette pour zoomer.", tip_fertility: "Ajustez les paramètres dans la barre latérale pour voir leur impact en temps réel.", tip_predator: "Libérez le super-prédateur pour un défi supplémentaire !", start_simulation: "Démarrer la Simulation", dont_show_again: "Ne plus afficher", toggle_view: "Changer de Vue", view_orbital: "Vue Orbitale", view_submarine: "Vue Sous-marin", auto_mode: "Mode Automatique", random_mode: "Mode Aléatoire", survival_time: "Survie",
                births_label: "Naissances", deaths_label: "Morts",
                notif_stress: "Les proies sont stressées, la fertilité chute.", notif_calm: "Le calme revient, la fertilité remonte.", notif_super_predator_eat: "{species} a été mangé par le Super-Prédateur.", notif_predator_eat: "{prey} a été mangé par {predator}.", notif_fertility_boost: "Fertilité de {species} augmentée !", notif_birth: "Un {species} est né.", notif_death_age: "{species} est mort de vieillesse.", notif_disease_warning: "ALERTE: Surpopulation. Une maladie se propage...", notif_disease_critical: "ALERTE: Surpopulation critique ! Une épidémie décime la population.", notif_infected: "{species} a été infecté.", notif_death_disease: "{species} est mort de maladie."
            },
            en: {
                species: "Species", parameters: "Parameters", fish_count_label: "Fish", predator_count_label: "Predators", ropefish_status_label: "Super-Predator", active: "ACTIVE", inactive: "INACTIVE", release_ropefish: "Release Super-Predator", remove_ropefish: "Remove Super-Predator", feed: "Feed", save: "Save", reset: "Reset Simulation", load_save: "Load Save", clear_save: "Clear Save", forces: "Flocking Forces", environment: "Environment", statistics: "Statistics", actions: "Actions", system: "System", count: "Count", scale: "Scale", max_speed: "Max Speed", perception_radius: "Perception", fear_radius: "Fear Radius", fertility: "Fertility", alignment: "Alignment", cohesion: "Cohesion", separation: "Separation", rock_count: "Rocks", plant_count: "Plantes", prey_eaten: "Prey Eaten", eggs_laid: "Eggs Laid", babies_hatched: "Babies Hatched", generation: "Max Generation", welcome_title: "Welcome to the Aquarium Simulation", welcome_description: "Explore a dynamic 3D ecosystem. Watch fish be born, grow, and interact. Use the controls to shape their world.", feature_lifecycle: "Complete life cycle and predation system.", feature_controls: "Advanced controls over environment and species.", quick_tips_title: "Quick Guide", tip_explore: "Drag to rotate the camera and use the scroll wheel to zoom.", tip_fertility: "Adjust settings in the sidebar to see their real-time impact.", tip_predator: "Release the super-predator for an extra challenge!", start_simulation: "Start Simulation", dont_show_again: "Don't show again", toggle_view: "Toggle View", view_orbital: "Orbital View", view_submarine: "Submarine View", auto_mode: "Auto Mode", random_mode: "Random Mode", survival_time: "Survival",
                births_label: "Births", deaths_label: "Deaths",
                notif_stress: "Prey are stressed, fertility drops.", notif_calm: "Calm returns, fertility rises.", notif_super_predator_eat: "{species} was eaten by the Super-Predator.", notif_predator_eat: "{prey} was eaten by {predator}.", notif_fertility_boost: "Fertility of {species} boosted!", notif_birth: "A {species} was born.", notif_death_age: "{species} died of old age.", notif_disease_warning: "ALERT: Overpopulation. A disease is spreading...", notif_disease_critical: "ALERT: Critical overpopulation! An epidemic is decimating the population.", notif_infected: "{species} has been infected.", notif_death_disease: "{species} died of disease."
            },
            es: {
                species: "Especies", parameters: "Parámetros", fish_count_label: "Peces", predator_count_label: "Depredadores", ropefish_status_label: "Superdepredador", active: "ACTIVO", inactive: "INACTIVO", release_ropefish: "Liberar Superdepredador", remove_ropefish: "Quitar Superdepredador", feed: "Alimentar", save: "Guardar", reset: "Reiniciar Simulación", load_save: "Cargar Guardado", clear_save: "Borrar Guardado", forces: "Fuerzas de Grupo", environment: "Entorno", statistics: "Estadísticas", actions: "Acciones", system: "Sistema", count: "Cantidad", scale: "Tamaño", max_speed: "Vel. Máxima", perception_radius: "Percepción", fear_radius: "Radio de Miedo", fertility: "Fertilidad", alignment: "Alineación", cohesion: "Cohesión", separation: "Separación", rock_count: "Rocas", plant_count: "Plantes", prey_eaten: "Presas comidas", eggs_laid: "Huevos puestos", babies_hatched: "Crías nacidas", generation: "Generación Máx", welcome_title: "Bienvenido a la Simulación de Acuario", welcome_description: "Explora un ecosistema 3D dinámico. Observa a los peces nacer, crecer e interactuar. Usa los controles para dar forma a su mundo.", feature_lifecycle: "Ciclo de vida completo y sistema de depredación.", feature_controls: "Controles avanzados sobre el entorno y las especies.", quick_tips_title: "Guía Rápida", tip_explore: "Arrastra para rotar la cámara y usa la rueda del ratón para hacer zoom.", tip_fertility: "Ajusta la configuración en la barra lateral para ver su impacto en tiempo real.", tip_predator: "¡Libera al superdepredador para un desafío adicional!", start_simulation: "Iniciar Simulación", dont_show_again: "No volver a mostrar", toggle_view: "Cambiar Vista", view_orbital: "Vista Orbital", view_submarine: "Vista Submarino", auto_mode: "Modo Automático", random_mode: "Modo Aleatorio", survival_time: "Supervivencia",
                births_label: "Nacimientos", deaths_label: "Muertes",
                notif_stress: "Las presas están estresadas, la fertilidad disminuye.", notif_calm: "Vuelve la calma, la fertilidad aumenta.", notif_super_predator_eat: "{species} fue comido por el Superdepredador.", notif_predator_eat: "{prey} fue comido por {predator}.", notif_fertility_boost: "¡Fertilidad de {species} aumentada!", notif_birth: "Ha nacido un {species}.", notif_death_age: "{species} murió de vejez.", notif_disease_warning: "ALERTA: Sobrepoblación. Una enfermedad se está propagando...", notif_disease_critical: "ALERTA: ¡Sobrepoblación crítica! Una epidemia está diezmando la población.", notif_infected: "{species} ha sido infectado.", notif_death_disease: "{species} murió de enfermedad."
            },
            de: {
                species: "Arten", parameters: "Parameter", fish_count_label: "Fische", predator_count_label: "Raubtiere", ropefish_status_label: "Super-Raubtier", active: "AKTIV", inactive: "INAKTIV", release_ropefish: "Super-Raubtier freilassen", remove_ropefish: "Super-Raubtier entfernen", feed: "Füttern", save: "Speichern", reset: "Simulation zurücksetzen", load_save: "Speicherstand laden", clear_save: "Speicherstand löschen", forces: "Schwarmkräfte", environment: "Umgebung", statistics: "Statistiken", actions: "Aktionen", system: "System", count: "Anzahl", scale: "Größe", max_speed: "Max. Geschw.", perception_radius: "Wahrnehmung", fear_radius: "Fluchtradius", fertility: "Fruchtbarkeit", alignment: "Ausrichtung", cohesion: "Zusammenhalt", separation: "Trennung", rock_count: "Felsen", plant_count: "Pflanzen", prey_eaten: "Beute gefressen", eggs_laid: "Eier gelegt", babies_hatched: "Babys geschlüpft", generation: "Max. Generation", welcome_title: "Willkommen bei der Aquarium-Simulation", welcome_description: "Erkunden Sie ein dynamisches 3D-Ökosystem. Beobachten Sie, wie Fische geboren werden, wachsen und interagieren. Verwenden Sie die Steuerelemente, um ihre Welt zu gestalten.", feature_lifecycle: "Vollständiger Lebenszyklus und Raubtiersystem.", feature_controls: "Erweiterte Steuerung von Umgebung und Arten.", quick_tips_title: "Kurzanleitung", tip_explore: "Ziehen Sie, um die Kamera zu drehen, und verwenden Sie das Mausrad zum Zoomen.", tip_fertility: "Passen Sie die Einstellungen in der Seitenleiste an, um ihre Echtzeit-Auswirkungen zu sehen.", tip_predator: "Lassen Sie das Super-Raubtier für eine zusätzliche Herausforderung frei!", start_simulation: "Simulation starten", dont_show_again: "Nicht erneut anzeigen", toggle_view: "Ansicht wechseln", view_orbital: "Orbitalansicht", view_submarine: "U-Boot-Ansicht", auto_mode: "Auto-Modus", random_mode: "Zufallsmodus", survival_time: "Überleben",
                births_label: "Geburten", deaths_label: "Todesfälle",
                notif_stress: "Beutetiere sind gestresst, Fruchtbarkeit sinkt.", notif_calm: "Ruhe kehrt ein, Fruchtbarkeit steigt.", notif_super_predator_eat: "{species} wurde vom Super-Raubtier gefressen.", notif_predator_eat: "{prey} wurde von {predator} gefressen.", notif_fertility_boost: "Fruchtbarkeit von {species} erhöht!", notif_birth: "Ein {species} wurde geboren.", notif_death_age: "{species} ist an Altersschwäche gestorben.", notif_disease_warning: "ALARM: Überbevölkerung. Eine Krankheit breitet sich aus...", notif_disease_critical: "ALARM: Kritische Überbevölkerung! Eine Epidemie dezimiert die Population.", notif_infected: "{species} wurde infiziert.", notif_death_disease: "{species} ist an einer Krankheit gestorben."
            },
            zh: {
                species: "物种", parameters: "参数", fish_count_label: "鱼类", predator_count_label: "捕食者", ropefish_status_label: "超级捕食者", active: "活动", inactive: "不活动", release_ropefish: "释放超级捕食者", remove_ropefish: "移除超级捕食者", feed: "喂食", save: "保存", reset: "重置模拟", load_save: "加载存档", clear_save: "清除存档", forces: "群体力量", environment: "环境", statistics: "统计数据", actions: "行动", system: "系统", count: "数量", scale: "大小", max_speed: "最大速度", perception_radius: "感知范围", fear_radius: "恐惧半径", fertility: "繁殖力", alignment: "对齐", cohesion: "凝聚", separation: "分离", rock_count: "岩石", plant_count: "植物", prey_eaten: "被捕食", eggs_laid: "产卵数", babies_hatched: "孵化数", generation: "最大代数", welcome_title: "欢迎来到水族馆模拟", welcome_description: "探索动态的3D生态系统。观察鱼类的出生、成长和互动。使用控件来塑造它们的世界。", feature_lifecycle: "完整的生命周期和捕食系统。", feature_controls: "对环境和物种的高级控制。", quick_tips_title: "快速指南", tip_explore: "拖动以旋转相机并使用滚轮进行缩放。", tip_fertility: "在侧边栏中调整设置以查看其实时影响。", tip_predator: "释放超级捕食者以获得额外挑战！", start_simulation: "开始模拟", dont_show_again: "不再显示", toggle_view: "切换视图", view_orbital: "轨道视图", view_submarine: "潜艇视图", auto_mode: "自动模式", random_mode: "随机模式", survival_time: "生存时间",
                births_label: "出生", deaths_label: "死亡",
                notif_stress: "猎物感到压力，繁殖力下降。", notif_calm: "恢复平静，繁殖力上升。", notif_super_predator_eat: "{species} 被超级捕食者吃掉了。", notif_predator_eat: "{prey} 被 {predator} 吃掉了。", notif_fertility_boost: "{species} 的繁殖力提升！", notif_birth: "一条 {species} 出生了。", notif_death_age: "{species} 因年老而死亡。", notif_disease_warning: "警告：鱼群过多。疾病正在蔓延...", notif_disease_critical: "警告：鱼群严重过多！一场瘟疫正在摧毁大部分鱼群。", notif_infected: "{species} 已被感染。", notif_death_disease: "{species} 因病死亡。"
            }
        };
        let currentLang = 'fr';
        const localeMap = { fr: 'fr-FR', en: 'en-US', es: 'es-ES', de: 'de-DE', zh: 'zh-CN' };

        // --- Auto-Mode Logic to manage the simulation automatically ---
        class AutoModeManager {
            constructor() {
                this.updateInterval = 3000; this.lastUpdateTime = 0;
                this.targets = { minPrey: 80, maxPrey: 150, superPredatorThreshold: 180 };
                this.startTime = 0; this.timerInterval = null;
                this.timerDisplayElement = null;
                this.lastPreyCount = 0;
            }
            start() {
                this.timerDisplayElement = dom.autoModeTimer;
                const statsEl = dom.autoModeStats;
                if (!statsEl || !this.timerDisplayElement) return;

                this.startTime = performance.now();
                statsEl.classList.remove('hidden');
                
                if (this.timerInterval) clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    const elapsedTime = Math.floor((performance.now() - this.startTime) / 1000);
                    const minutes = String(Math.floor(elapsedTime / 60)).padStart(2, '0');
                    const seconds = String(elapsedTime % 60).padStart(2, '0');
                    if (this.timerDisplayElement) {
                        this.timerDisplayElement.textContent = `${minutes}:${seconds}`;
                    }
                }, 1000);
                this.lastPreyCount = boids.filter(b => !b.isEaten && !b.isPredator).length;
            }
            stop(freeze = false) {
                clearInterval(this.timerInterval); this.timerInterval = null;
                if (!freeze) {
                    const statsEl = dom.autoModeStats;
                    if (statsEl) {
                        statsEl.classList.add('hidden');
                    }
                    if (this.timerDisplayElement) {
                        this.timerDisplayElement.textContent = '00:00';
                    }
                }
            }
            update() {
                const now = performance.now();
                if (now - this.lastUpdateTime < 16.67) return; // 60 FPS
                this.lastUpdateTime = now;
                const aliveBoids = boids.filter(b => !b.isEaten);
                const prey = aliveBoids.filter(b => !b.isPredator);
                if ((prey.length + aliveBoids.filter(b => b.isPredator).length) === 0 && this.startTime > 0) {
                    this.stop(true); return;
                }
                const populationChangeRate = (this.lastPreyCount > 0) ? (prey.length - this.lastPreyCount) / this.lastPreyCount : 0;
                if (populationChangeRate < -0.10) { generateFood(); generateFood(); }
                if (prey.length < this.targets.minPrey) {
                    this.adjustFertility(true);
                    if (prey.length < this.targets.minPrey / 2) generateFood();
                } else if (prey.length > this.targets.maxPrey) {
                    this.adjustFertility(false);
                }
                if (prey.length > this.targets.superPredatorThreshold && !superPredator.isActive) {
                    superPredator.spawn();
                } else if (prey.length < this.targets.maxPrey && superPredator.isActive) {
                    superPredator.remove();
                }
                this.lastPreyCount = prey.length;
            }
            adjustFertility(increase) {
                for (const species in fishSpecies) {
                    if (fishSpecies[species].type === 'prey') {
                        const config = fishSpecies[species];
                        config.fertility = increase ? Math.min(0.1, config.fertility + 0.002) : Math.max(0.001, config.fertility - 0.002);
                        const slider = document.getElementById(`${species}-fertility`);
                        if (slider) {
                            slider.value = config.fertility;
                            document.getElementById(`${slider.id}-value`).textContent = config.fertility.toFixed(3);
                        }
                    }
                }
            }
        }

        // --- Submarine class for an alternative camera view ---
        class Submarine {
            constructor() {
                this.mesh = new THREE.Group();
                const material = new THREE.MeshLambertMaterial({ color: 0x6b7280 });
                const body = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 20, 8), material);
                body.rotation.z = Math.PI / 2;
                this.mesh.add(body);
                const cockpit = new THREE.Mesh(new THREE.SphereGeometry(5, 8, 6), material);
                cockpit.position.x = 5;
                this.mesh.add(cockpit);
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(8, 0, 0); 
                this.mesh.add(this.camera);
                this.position = new THREE.Vector3(0, worldSize.height / 2 + 20, 0);
                this.velocity = new THREE.Vector3(0.3, 0, 0);
                this.acceleration = new THREE.Vector3();
                this.mesh.position.copy(this.position);
                this.maxSpeed = 0.4; this.maxForce = 0.01;
                this.target = this.getNewTarget();
                scene.add(this.mesh);
            }
            getNewTarget() {
                return new THREE.Vector3( (Math.random() - 0.5) * (worldSize.width - 40), Math.random() * (worldSize.height - 40) + 20, (Math.random() - 0.5) * (worldSize.depth - 40) );
            }
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.setLength(this.maxSpeed);
                let steer = new THREE.Vector3().subVectors(desired, this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }
            update() {
                if (this.position.distanceTo(this.target) < 50) {
                    this.target = this.getNewTarget();
                }
                this.acceleration.add(this.seek(this.target));
                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.multiplyScalar(0);
                this.checkBounds(); 
                this.mesh.position.lerp(this.position, 0.1);
                const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), this.velocity.clone().normalize());
                this.mesh.quaternion.slerp(targetQuaternion, 0.05);
            }
            checkBounds() {
                const margin = 20;
                if (this.position.x < -worldSize.width/2+margin || this.position.x > worldSize.width/2-margin ||
                    this.position.y < margin || this.position.y > worldSize.height-margin ||
                    this.position.z < -worldSize.depth/2+margin || this.position.z > worldSize.depth/2-margin) {
                    this.target = new THREE.Vector3(0, worldSize.height / 2, 0);
                }
            }
        }

        // --- Super-Predator class (Ropefish) ---
        class Ropefish {
            constructor() { this.isActive = false; }
            spawn() {
                if (this.isActive || boids.length === 0) return;
                this.isActive = true;
                const headMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00, wireframe: true });
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x16a34a, wireframe: true });
                this.segmentCount = 30; this.segmentSpacing = 3.5; this.speed = 0.9; this.turnSpeed = 0.04; this.attackRadius = 10;
                this.body = new THREE.Group(); this.segments = []; this.path = []; this.pathLength = 120; this.target = null;
                const head = new THREE.Mesh(new THREE.SphereGeometry(4, 6, 4), headMaterial);
                this.segments.push(head); this.body.add(head);
                for (let i = 1; i < this.segmentCount; i++) {
                    const segment = new THREE.Mesh(new THREE.SphereGeometry(2.5, 6, 4), bodyMaterial);
                    this.segments.push(segment); this.body.add(segment);
                }
                this.velocity = new THREE.Vector3(Math.random() * 2 - 1, 0, Math.random() * 2 - 1).normalize().multiplyScalar(this.speed);
                const startPos = new THREE.Vector3((Math.random() - 0.5) * worldSize.width * 0.8, 15, (Math.random() - 0.5) * worldSize.depth * 0.8);
                this.segments.forEach(seg => seg.position.copy(startPos));
                this.path = Array(this.pathLength).fill(startPos);
                scene.add(this.body);
                document.querySelectorAll('.ropefish-status-text').forEach(el => el.textContent = translations[currentLang].active);
                document.querySelectorAll('#release-ropefish-btn').forEach(btn => btn.textContent = translations[currentLang].remove_ropefish);
                showNotification('notif_stress', 'warning');
            }
            update(boids) {
                if (!this.isActive) return;
                this.findTarget(boids); this.move(); this.checkBounds();
            }
            findTarget(allBoids) {
                if (this.target && this.target.isEaten) this.target = null;
                if (!this.target || Math.random() < 0.01) {
                    let closestBoid = null, minDistance = Infinity;
                    const aliveBoids = allBoids.filter(b => !b.isEaten && !b.isPredator);
                    if (aliveBoids.length === 0) { this.target = null; return; }
                    for (const boid of aliveBoids) {
                        const d = this.segments[0].position.distanceTo(boid.position);
                        if (d < minDistance) { minDistance = d; closestBoid = boid; }
                    }
                    this.target = closestBoid;
                }
            }
            move() {
                let desiredVelocity = new THREE.Vector3();
                if (this.target) { desiredVelocity.subVectors(this.target.position, this.segments[0].position); } 
                else {
                    desiredVelocity.copy(this.velocity);
                    if (Math.random() < 0.05) { desiredVelocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), (Math.random() - 0.5) * Math.PI / 2); }
                }
                desiredVelocity.normalize().multiplyScalar(this.speed);
                this.velocity.lerp(desiredVelocity, this.turnSpeed);
                const newHeadPos = this.segments[0].position.clone().add(this.velocity);
                this.path.unshift(newHeadPos);
                if (this.path.length > this.pathLength) this.path.pop();
                for (let i = 1; i < this.segments.length; i++) {
                    const index = Math.floor(Math.min(i * this.segmentSpacing, this.path.length - 1));
                    if (this.path[index]) this.segments[i].position.lerp(this.path[index], 0.5);
                }
                if (this.target && this.segments[0].position.distanceTo(this.target.position) < this.attackRadius) {
                    showNotification('notif_super_predator_eat', 'death', { species: this.target.species });
                    createEatEffect(this.target.position, 0xFFFF00);
                    this.target.isEaten = true; simulationStats.preyEaten++; this.target = null;
                }
            }
            checkBounds() {
                const margin = 2;
                const headPosition = this.segments[0].position;
                if (headPosition.x < -worldSize.width/2+margin) { headPosition.x = -worldSize.width/2+margin; this.velocity.x *= -1; }
                else if (headPosition.x > worldSize.width/2-margin) { headPosition.x = worldSize.width/2-margin; this.velocity.x *= -1; }
                if (headPosition.y < margin) { headPosition.y = margin; this.velocity.y *= -1; }
                else if (headPosition.y > worldSize.height-margin) { headPosition.y = worldSize.height-margin; this.velocity.y *= -1; }
                if (headPosition.z < -worldSize.depth/2+margin) { headPosition.z = -worldSize.depth/2+margin; this.velocity.z *= -1; }
                else if (headPosition.z > worldSize.depth/2-margin) { headPosition.z = worldSize.depth/2-margin; this.velocity.z *= -1; }
            }
            
            // Nouvelle méthode pour supprimer le super prédateur de la scène
            remove() {
                if(this.isActive) {
                    scene.remove(this.body);
                    this.isActive = false;
                    document.querySelectorAll('.ropefish-status-text').forEach(el => el.textContent = translations[currentLang].inactive);
                    document.querySelectorAll('#release-ropefish-btn').forEach(btn => btn.textContent = translations[currentLang].remove_ropefish);
                    showNotification('notif_calm', 'info');
                }
            }
        }

        // --- Food particle class for feeding the fish ---
        class FoodParticle {
            constructor(position) {
                this.position = position.clone(); this.velocity = new THREE.Vector3(0, -0.1, 0); this.lifetime = 1000 + Math.random() * 500;
                const material = new THREE.MeshBasicMaterial({ color: 0xfacc15, wireframe: false, transparent: true, opacity: 0.9 });
                this.mesh = new THREE.Mesh(new THREE.SphereGeometry(1.2, 8, 6), material);
                this.mesh.position.copy(this.position); scene.add(this.mesh);
            }
            update() {
                this.position.add(this.velocity); this.mesh.position.copy(this.position);
                if (this.position.y < 1) { this.position.y = 1; this.velocity.y = 0; }
                this.lifetime--;
                if (this.lifetime < 100) { this.mesh.material.opacity = (this.lifetime / 100) * 0.9; }
                return this.lifetime <= 0;
            }
        }

        // --- Egg class for reproduction ---
        class Egg {
            constructor(species, position, color, parentGeneration = 1) {
                this.species = species; this.parentGeneration = parentGeneration; this.hatchTime = 500 + Math.random() * 200;
                const material = new THREE.MeshBasicMaterial({ color: color, wireframe: false, transparent: true, opacity: 0.8 });
                this.mesh = new THREE.Mesh(new THREE.SphereGeometry(1.5, 6, 4), material);
                this.mesh.position.copy(position); scene.add(this.mesh);
                simulationStats.eggsLaid[this.species] = (simulationStats.eggsLaid[this.species] || 0) + 1;
            }
            update() {
                this.hatchTime--;
                if (this.hatchTime <= 0) return this.hatch();
                return null;
            }
            hatch() {
                const baby = new Boid(this.species, true, this.parentGeneration);
                baby.position.copy(this.mesh.position);
                simulationStats.babiesHatched[this.species] = (simulationStats.babiesHatched[this.species] || 0) + 1;
                simulationStats.totalBirths++;
                showNotification('notif_birth', 'birth', { species: this.species });
                return [baby];
            }
        }

        // --- Boid class for fish behavior simulation ---
        class Boid {
            constructor(species, isBaby = false, parentGeneration = 0) {
                this.species = species; const config = fishSpecies[species];
                this.isPredator = config.type === 'predator'; this.maxSpeed = config.maxSpeed; this.maxForce = 0.05;
                this.perceptionRadius = config.perceptionRadius; this.fearRadius = config.fearRadius || 0;
                this.fertility = config.fertility || 0; this.satiation = this.isPredator ? 300 : 0; this.isEaten = false;
                this.isDiseased = false; this.diseaseTimer = 0;
                this.fertilityBoostTimer = 0;
                this.generation = isBaby ? parentGeneration + 1 : 1;
                if (this.generation > (simulationStats.maxGeneration[species] || 0)) { simulationStats.maxGeneration[species] = this.generation; }
                this.adultAge = 800; this.maxAge = 6000; this.age = isBaby ? 0 : Math.random() * this.maxAge;
                const material = new THREE.MeshBasicMaterial({ color: config.color, side: THREE.DoubleSide, transparent: true });
                this.mesh = new THREE.Mesh(new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(config.vertices, 3)), material);
                const initialScale = isBaby ? config.scale * 0.3 : config.scale;
                this.mesh.scale.set(initialScale, initialScale, initialScale);
                this.position = new THREE.Vector3(Math.random()*worldSize.width-worldSize.width/2, Math.random()*(worldSize.height-10)+5, Math.random()*worldSize.depth-worldSize.depth/2);
                this.velocity = new THREE.Vector3(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1).setLength(Math.random() * this.maxSpeed * 0.5 + 0.1);
                this.acceleration = new THREE.Vector3(); this.mesh.position.copy(this.position); scene.add(this.mesh);
            }
            applyForce(force) { this.acceleration.add(force); }
            update(allBoids) {
                if (this.isEaten) return;

                if (this.isDiseased) {
                    this.diseaseTimer--;
                    const duration = (boids.length > 600) ? 300 : 600;
                    this.mesh.material.opacity = this.diseaseTimer / duration;
                    if (this.diseaseTimer <= 0) {
                        this.isEaten = true;
                    }
                    return;
                }

                this.age++;
                if (!this.isAdult && this.age > this.adultAge) this.isAdult = true;
                if (this.age > this.maxAge) {
                    this.isEaten = true;
                    showNotification('notif_death_age', 'death', { species: this.species });
                    return;
                }
                
                let currentFertility = this.fertility;
                if (!this.isPredator && superPredator && superPredator.isActive) {
                    currentFertility *= 0.5;
                }
                if (this.isPredator && this.fertilityBoostTimer > 0) {
                    this.fertilityBoostTimer--;
                    currentFertility *= 5;
                }

                if (this.matingCooldown > 0) this.matingCooldown--;
                else if (this.isAdult && !this.isMating && Math.random() < currentFertility) this.wantsToMate = true;
                
                if (this.isMating) this.mate();
                else {
                    if (this.wantsToMate) this.findPartner(allBoids);
                    if (this.isPredator) this.hunt(allBoids);
                    else this.schoolAndFlee(allBoids);
                }
                this.velocity.add(this.acceleration); this.velocity.clampLength(0, this.maxSpeed);
                this.position.add(this.velocity); this.acceleration.multiplyScalar(0);
                this.checkBounds(); this.mesh.position.copy(this.position);
                if (this.velocity.lengthSq() > 0.0001) {
                    this.mesh.lookAt(new THREE.Vector3().addVectors(this.position, this.velocity));
                    this.mesh.rotateY(-Math.PI / 2);
                }
            }
            findPartner(allBoids) {
                for (const other of allBoids) {
                    if (other !== this && other.species === this.species && other.wantsToMate && !other.isMating) {
                        if (this.position.distanceTo(other.position) < this.perceptionRadius) {
                            this.isMating = true; this.wantsToMate = false; this.matingPartner = other; this.matingTimer = 300;
                            other.isMating = true; other.wantsToMate = false; other.matingPartner = this; other.matingTimer = 300;
                            return;
                        }
                    }
                }
            }
            mate() {
                this.matingTimer--;
                if (this.matingTimer <= 0 || this.matingPartner.isEaten || !this.matingPartner) {
                    if (this.matingPartner) { this.matingPartner.isMating = false; this.matingPartner.matingCooldown = 1500; }
                    this.isMating = false; this.matingPartner = null; this.matingCooldown = 1500; return;
                }
                const directionToPartner = new THREE.Vector3().subVectors(this.matingPartner.position, this.position);
                if (directionToPartner.length() > 20) this.applyForce(this.seek(this.matingPartner.position));
                if (this.matingTimer === 1) {
                    const eggPosition = new THREE.Vector3().addVectors(this.position, this.matingPartner.position).multiplyScalar(0.5); eggPosition.y = 2;
                    const parentGeneration = Math.max(this.generation, this.matingPartner.generation);
                    eggs.push(new Egg(this.species, eggPosition, fishSpecies[this.species].color, parentGeneration));
                }
            }
            hunt(allBoids) {
                // Optimisation: Utilisez une approche de grille spatiale (spatial hash) pour une recherche plus rapide
                // Pour l'instant, nous filtrons toujours sur tous les boids, ce qui peut devenir lent
                if (this.schoolAndFlee(allBoids, true)) return;
                if (this.satiation > 0) { this.satiation--; this.schoolAndFlee(allBoids, true); return; }
                let bestTarget = null, minDistance = Infinity;
                const preyBoids = allBoids.filter(b => !b.isEaten && !b.isPredator);
                const riskConfig = fishSpecies[this.species].riskAssessment;
                for (const target of preyBoids) {
                    const d = this.position.distanceTo(target.position);
                    if (d > riskConfig.maxDistance || d > minDistance) continue;
                    let groupSize = preyBoids.filter(p => target.position.distanceTo(p.position) < 25).length;
                    if (groupSize > riskConfig.maxGroupSize) continue;
                    minDistance = d; bestTarget = target;
                }
                if (bestTarget) {
                    this.applyForce(this.seek(bestTarget.position));
                    if (this.position.distanceTo(bestTarget.position) < 5) {
                        showNotification('notif_predator_eat', 'death', { prey: bestTarget.species, predator: this.species });
                        createEatEffect(bestTarget.position, fishSpecies[this.species].color);
                        bestTarget.isEaten = true; simulationStats.preyEaten++; this.satiation = 300;
                        this.matingCooldown = 0; this.fertilityBoostTimer = 600;
                        showNotification('notif_fertility_boost', 'info', { species: this.species });
                    }
                } else this.schoolAndFlee(allBoids, true);
            }
            schoolAndFlee(allBoids, ignorePredators = false) {
                if (superPredator && superPredator.isActive) {
                    const d = this.position.distanceTo(superPredator.segments[0].position);
                    if (d < 200) {
                        let diff = new THREE.Vector3().subVectors(this.position, superPredator.segments[0].position);
                        let steer = this.seek(this.position.clone().add(diff.normalize()));
                        steer.multiplyScalar(7.5);
                        this.applyForce(steer);
                        return true;
                    }
                }
                if (!this.isPredator && !ignorePredators) {
                    let fleeVector = new THREE.Vector3(), predatorCount = 0;
                    for (const other of allBoids) {
                        if (other.isPredator && this.position.distanceTo(other.position) < this.fearRadius) {
                            fleeVector.add(new THREE.Vector3().subVectors(this.position, other.position)); predatorCount++;
                        }
                    }
                    if (predatorCount > 0) {
                        this.applyForce(this.seek(this.position.clone().add(fleeVector.normalize())).multiplyScalar(2.5)); return true;
                    }
                }
                this.applyForce(this.separate(allBoids).multiplyScalar(flockingForces.separation));
                this.applyForce(this.align(allBoids).multiplyScalar(flockingForces.alignment));
                this.applyForce(this.cohere(allBoids).multiplyScalar(flockingForces.cohesion)); return false;
            }
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position).setLength(this.maxSpeed);
                return new THREE.Vector3().subVectors(desired, this.velocity).clampLength(0, this.maxForce);
            }
            separate(boids) {
                let steer = new THREE.Vector3(), count = 0;
                for (let other of boids) {
                    let d = this.position.distanceTo(other.position);
                    if (d > 0 && d < 15) {
                        steer.add(new THREE.Vector3().subVectors(this.position, other.position).normalize().divideScalar(d)); count++;
                    }
                }
                if (count > 0) steer.divideScalar(count);
                if (steer.length() > 0) steer.setLength(this.maxSpeed).sub(this.velocity).clampLength(0, this.maxForce);
                return steer;
            }
            align(boids) {
                let sum = new THREE.Vector3(), count = 0;
                for (let other of boids) {
                    if (other.species === this.species && this.position.distanceTo(other.position) < this.perceptionRadius) {
                        sum.add(other.velocity); count++;
                    }
                }
                if (count > 0) return sum.divideScalar(count).setLength(this.maxSpeed).sub(this.velocity).clampLength(0, this.maxForce);
                return new THREE.Vector3();
            }
            cohere(boids) {
                let sum = new THREE.Vector3(), count = 0;
                for (let other of boids) {
                    if (other.species === this.species && this.position.distanceTo(other.position) < this.perceptionRadius) {
                        sum.add(other.position); count++;
                    }
                }
                if (count > 0) return this.seek(sum.divideScalar(count));
                return new THREE.Vector3();
            }
            checkBounds() {
                const margin = 2;
                if (this.position.x < -worldSize.width/2+margin) { this.position.x = -worldSize.width/2+margin; this.velocity.x *= -1; }
                else if (this.position.x > worldSize.width/2-margin) { this.position.x = worldSize.width/2-margin; this.velocity.x *= -1; }
                if (this.position.y < margin) { this.position.y = margin; this.velocity.y *= -1; }
                else if (this.position.y > worldSize.height-margin) { this.position.y = worldSize.height-margin; this.velocity.y *= -1; }
                if (this.position.z < -worldSize.depth/2+margin) { this.position.z = -worldSize.depth/2+margin; this.velocity.z *= -1; }
                else if (this.position.z > worldSize.depth/2-margin) { this.position.z = worldSize.depth/2-margin; this.velocity.z *= -1; }
            }
        }

        // --- Main Three.js setup and animation loop ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a3d62);
            scene.fog = new THREE.Fog(0x0a3d62, 500, 1500);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 200, 100);
            scene.add(directionalLight);

            const canvas = document.getElementById('simulation-canvas');
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 100, 450);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // Initialisation of OrbitControls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 1500;
            controls.target.set(0, worldSize.height / 2, 0);

            createAquariumBox(); createDecor(); createPlants();
            superPredator = new Ropefish();
            submarine = new Submarine();
            autoModeManager = new AutoModeManager();
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function createEatEffect(position, color) {
            const particleCount = 20;
            const material = new THREE.LineBasicMaterial({ color: color });
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5)]);
                const particle = new THREE.Line(geometry, material);
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2),
                    life: 1.0
                };
                particles.push(particle); scene.add(particle);
            }
        }
        
        function createDiseaseEffect(position) {
            const particleCount = 15;
            const material = new THREE.MeshBasicMaterial({ color: 0x84cc16, transparent: true });
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(Math.random() * 1.5, 4, 4);
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5),
                    life: 1.5
                };
                particles.push(particle);
                scene.add(particle);
            }
        }

        function triggerProgressiveDisease(decimationRate) {
            const fishToRemoveCount = Math.floor(boids.length * decimationRate);
            const shuffledBoids = [...boids].sort(() => 0.5 - Math.random());
            fishMarkedForCull = shuffledBoids.slice(0, fishToRemoveCount);
            showNotification('notif_disease_warning', 'warning');
        }

        function triggerImmediateDisease(decimationRate) {
            const fishToRemoveCount = Math.floor(boids.length * decimationRate);
            const shuffledBoids = [...boids].filter(b => !b.isEaten).sort(() => 0.5 - Math.random());
            for (let i = 0; i < fishToRemoveCount; i++) {
                if (shuffledBoids[i]) {
                    shuffledBoids[i].isEaten = true;
                    createDiseaseEffect(shuffledBoids[i].position);
                }
            }
            showNotification('notif_disease_critical', 'danger');
        }

        function createAquariumBox() {
            const geometry = new THREE.BoxGeometry(worldSize.width, worldSize.height, worldSize.depth);
            const material = new THREE.MeshBasicMaterial({ color: 0x60a5fa, wireframe: true, transparent: true, opacity: 0.2 });
            aquariumBox = new THREE.Mesh(geometry, material);
            aquariumBox.position.set(0, worldSize.height / 2, 0);
            scene.add(aquariumBox);
        }

        function createDecor() {
            rocks.forEach(rock => scene.remove(rock)); rocks.length = 0;
            const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x64748b, wireframe: false });
            for (let i = 0; i < environmentSettings.rockCount; i++) {
                const size = Math.random() * 35 + 15;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(size, 0), rockMaterial);
                rock.position.set((Math.random() - 0.5) * (worldSize.width - size * 2), size / 2, (Math.random() - 0.5) * (worldSize.depth - size * 2));
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                scene.add(rock); rocks.push(rock);
            }
        }

        function createPlants() {
            plants.forEach(plant => scene.remove(plant)); plants.length = 0;
            const material = new THREE.LineBasicMaterial({ color: 0x10b981, linewidth: 2 });
            for (let i = 0; i < environmentSettings.plantCount; i++) {
                const points = []; const height = Math.random() * 80 + 30;
                points.push(new THREE.Vector3(0, 0, 0));
                for(let j=1; j<5; j++) {
                    points.push(new THREE.Vector3(Math.sin(j*0.5)*10, j*height/5, Math.cos(j*0.5)*10));
                }
                const plant = new THREE.Line(new THREE.BufferGeometry().setFromPoints(new THREE.CatmullRomCurve3(points).getPoints(20)), material);
                plant.position.set((Math.random() - 0.5) * worldSize.width * 0.9, 0, (Math.random() - 0.5) * worldSize.depth * 0.9);
                scene.add(plant); plants.push(plant);
            }
        }

        function createBoids() {
            boids.forEach(boid => scene.remove(boid.mesh)); boids.length = 0;
            for (const species in fishSpecies) {
                for (let i = 0; i < fishSpecies[species].count; i++) {
                    boids.push(new Boid(species));
                }
            }
        }
        
        function updateBoidProperties(species, property, value) {
            const aliveBoids = boids.filter(b => b.species === species && !b.isEaten);

            if (property === 'scale') {
                aliveBoids.forEach(boid => {
                    boid.mesh.scale.set(value, value, value);
                });
            } else if (property === 'maxSpeed') {
                aliveBoids.forEach(boid => {
                    boid.maxSpeed = value;
                });
            } else if (property === 'perceptionRadius') {
                 aliveBoids.forEach(boid => {
                    boid.perceptionRadius = value;
                });
            } else if (property === 'fertility') {
                 aliveBoids.forEach(boid => {
                    boid.fertility = value;
                });
            }
        }
        
        // --- UI update functions ---
        function updateStats() {
            boids = boids.filter(boid => !boid.isEaten);
            const aliveBoids = boids.filter(b => !b.isEaten);
            const preyCount = aliveBoids.filter(b => !b.isPredator).length;
            const predatorCount = aliveBoids.filter(b => b.isPredator).length;
            const ratio = predatorCount > 0 ? (preyCount / predatorCount).toFixed(1) : '∞';

            dom.fishCounts.forEach(el => el.textContent = preyCount);
            dom.predatorCounts.forEach(el => el.textContent = predatorCount);
            dom.preyPredatorRatios.forEach(el => el.textContent = ratio);
            dom.birthCounts.forEach(el => el.textContent = simulationStats.totalBirths);
            dom.deathCounts.forEach(el => el.textContent = simulationStats.totalDeaths);
            
            const statsContainers = document.querySelectorAll('#stats-panel-content');
            if (statsContainers.length > 0) {
                 statsContainers.forEach(statsContainer => {
                    statsContainer.querySelector('#stats-prey-eaten').textContent = simulationStats.preyEaten;
                    for (const species in fishSpecies) {
                        const speciesContainer = statsContainer.querySelector(`#stats-container-${species}`);
                        if (speciesContainer) {
                            speciesContainer.querySelector(`#stats-${species}-count`).textContent = aliveBoids.filter(b => b.species === species).length;
                            speciesContainer.querySelector(`#stats-${species}-eggs`).textContent = simulationStats.eggsLaid[species] || 0;
                            speciesContainer.querySelector(`#stats-${species}-babies`).textContent = simulationStats.babiesHatched[species] || 0;
                            speciesContainer.querySelector(`#stats-${species}-generation`).textContent = simulationStats.maxGeneration[species] || 1;
                        }
                    }
                });
            }
        }

        function resetSimulation() {
            // Efface toutes les entités de la simulation de la scène
            boids.forEach(b => scene.remove(b.mesh));
            eggs.forEach(e => scene.remove(e.mesh));
            food.forEach(f => scene.remove(f.mesh));
            rocks.forEach(r => scene.remove(r));
            plants.forEach(p => scene.remove(p));

            // Réinitialise les tableaux d'entités
            boids.length = 0;
            eggs.length = 0;
            food.length = 0;
            rocks.length = 0;
            plants.length = 0;

            // Réinitialise les statistiques de la simulation
            simulationStats.preyEaten = 0;
            simulationStats.totalBirths = 0;
            simulationStats.totalDeaths = 0;
            Object.keys(fishSpecies).forEach(species => {
                simulationStats.eggsLaid[species] = 0;
                simulationStats.babiesHatched[species] = 0;
                simulationStats.maxGeneration[species] = 1;
            });
            
            // Supprime le super prédateur s'il est actif
            superPredator.remove();

            // Recrée les éléments par défaut
            createDecor();
            createPlants();
            createBoids();
        }

        function saveState() {
            // Enregistre toutes les entités de la simulation
            const state = {
                fishSpecies,
                flockingForces,
                environmentSettings,
                simulationStats,
                boids: boids.map(b => ({
                    species: b.species,
                    position: b.position,
                    velocity: b.velocity,
                    age: b.age,
                    generation: b.generation,
                    satiation: b.satiation,
                    isDiseased: b.isDiseased,
                    diseaseTimer: b.diseaseTimer,
                    fertilityBoostTimer: b.fertilityBoostTimer,
                    isAdult: b.isAdult,
                    wantsToMate: b.wantsToMate,
                    matingCooldown: b.matingCooldown,
                })),
                eggs: eggs.map(e => ({
                    species: e.species,
                    position: e.mesh.position,
                    hatchTime: e.hatchTime,
                    parentGeneration: e.parentGeneration
                })),
                food: food.map(f => ({
                    position: f.position,
                    lifetime: f.lifetime
                })),
                rocks: rocks.map(r => ({
                    position: r.position,
                    rotation: r.rotation,
                    size: r.geometry.parameters.radius
                })),
                plants: plants.map(p => ({
                    position: p.position
                })),
                superPredator: {
                    isActive: superPredator.isActive,
                    path: superPredator.isActive ? superPredator.path : [],
                    velocity: superPredator.isActive ? superPredator.velocity : null
                }
            };
            try {
                localStorage.setItem('aquarium-state', JSON.stringify(state));
                document.querySelectorAll('.save-feedback').forEach(el => {
                    el.classList.remove('opacity-0');
                    setTimeout(() => el.classList.add('opacity-0'), 2000);
                });
            } catch(e) {
                console.error("Failed to save state", e);
                alert('Erreur lors de la sauvegarde.');
            }
        }

        function loadState(showAlertOnFailure = false) {
            try {
                const savedStateJSON = localStorage.getItem('aquarium-state');
                if (!savedStateJSON) {
                    console.warn("No saved state found.");
                    if(showAlertOnFailure) {
                        alert('Aucune sauvegarde trouvée.');
                    }
                    return false;
                }
                const savedState = JSON.parse(savedStateJSON);

                // Efface toutes les entités de la simulation avant de charger
                boids.forEach(b => scene.remove(b.mesh));
                eggs.forEach(e => scene.remove(e.mesh));
                food.forEach(f => scene.remove(f.mesh));
                rocks.forEach(r => scene.remove(r));
                plants.forEach(p => scene.remove(p));

                boids.length = 0;
                eggs.length = 0;
                food.length = 0;
                rocks.length = 0;
                plants.length = 0;

                // Restaurer les paramètres de la simulation
                Object.assign(fishSpecies, savedState.fishSpecies);
                Object.assign(flockingForces, savedState.flockingForces);
                Object.assign(environmentSettings, savedState.environmentSettings);
                Object.assign(simulationStats, savedState.simulationStats);
                
                // Recréer les boids
                if (savedState.boids) {
                    savedState.boids.forEach(data => {
                        const boid = new Boid(data.species, false, data.parentGeneration);
                        boid.position.set(data.position.x, data.position.y, data.position.z);
                        boid.mesh.position.copy(boid.position);
                        boid.velocity.set(data.velocity.x, data.velocity.y, data.velocity.z);
                        boid.age = data.age;
                        boid.generation = data.generation;
                        boid.satiation = data.satiation;
                        boid.isDiseased = data.isDiseased;
                        boid.diseaseTimer = data.diseaseTimer;
                        boid.fertilityBoostTimer = data.fertilityBoostTimer;
                        boid.isAdult = data.isAdult;
                        boid.wantsToMate = data.wantsToMate;
                        boid.matingCooldown = data.matingCooldown;
                        scene.add(boid.mesh);
                        boids.push(boid);
                    });
                }
                // Recréer les oeufs
                if (savedState.eggs) {
                    savedState.eggs.forEach(data => {
                        const egg = new Egg(data.species, new THREE.Vector3().copy(data.position), fishSpecies[data.species].color, data.parentGeneration);
                        egg.hatchTime = data.hatchTime;
                        eggs.push(egg);
                        scene.add(egg.mesh);
                    });
                }
                // Recréer la nourriture
                if (savedState.food) {
                    savedState.food.forEach(data => {
                        const foodParticle = new FoodParticle(new THREE.Vector3().copy(data.position));
                        foodParticle.lifetime = data.lifetime;
                        food.push(foodParticle);
                        scene.add(foodParticle.mesh);
                    });
                }
                // Recréer les rochers
                if (savedState.rocks) {
                     savedState.rocks.forEach(data => {
                        const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x64748b, wireframe: false });
                        const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(data.size, 0), rockMaterial);
                        rock.position.copy(data.position);
                        rock.rotation.set(data.rotation._x, data.rotation._y, data.rotation._z);
                        rocks.push(rock);
                        scene.add(rock);
                    });
                }
                // Recréer les plantes
                if (savedState.plants) {
                     savedState.plants.forEach(data => {
                        const material = new THREE.LineBasicMaterial({ color: 0x10b981, linewidth: 2 });
                        const points = []; 
                        const height = Math.random() * 80 + 30;
                        points.push(new THREE.Vector3(0, 0, 0));
                        for(let j=1; j<5; j++) {
                            points.push(new THREE.Vector3(Math.sin(j*0.5)*10, j*height/5, Math.cos(j*0.5)*10));
                        }
                        const plant = new THREE.Line(new THREE.BufferGeometry().setFromPoints(new THREE.CatmullRomCurve3(points).getPoints(20)), material);
                        plant.position.copy(data.position);
                        plants.push(plant);
                        scene.add(plant);
                    });
                }

                // Restaurer l'état du super prédateur
                if (savedState.superPredator && savedState.superPredator.isActive) {
                    superPredator.spawn();
                    superPredator.path = savedState.superPredator.path.map(p => new THREE.Vector3().copy(p));
                    if (savedState.superPredator.velocity) {
                        superPredator.velocity.copy(savedState.superPredator.velocity);
                    }
                } else {
                    superPredator.remove();
                }

                // Mettre à jour l'interface utilisateur et les statistiques
                setupUI();
                updateStats();
                alert('Sauvegarde restaurée avec succès!');
                return true;

            } catch (e) {
                console.error("Failed to load state", e);
                if(showAlertOnFailure) {
                    alert('Erreur lors de la restauration de la sauvegarde.');
                }
                return false;
            }
        }


        // --- Language and UI setup functions ---
        function setLanguage(lang) {
            if (!translations[lang]) return;
            currentLang = lang;
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                if (translations[lang][key]) {
                    el.textContent = translations[lang][key];
                }
            });
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === lang);
            });
            setupUI();
        }
        
        function randomizeSettings() {
            flockingForces.alignment = (Math.random() * 2).toFixed(1);
            flockingForces.cohesion = (Math.random() * 2).toFixed(1);
            flockingForces.separation = (Math.random() * 2).toFixed(1);
            environmentSettings.rockCount = Math.floor(Math.random() * 50);
            environmentSettings.plantCount = Math.floor(Math.random() * 100);
            for (const species in fishSpecies) {
                const config = fishSpecies[species];
                config.count = Math.floor(Math.random() * 100) + 10;
                config.scale = (Math.random() * 1.5 + 0.2).toFixed(1);
                if (config.fertility !== undefined) {
                    config.fertility = (Math.random() * 0.05).toFixed(3);
                }
            }
            setupUI();
            createDecor();
            createPlants();
            resetSimulation();
        }

        function toggleAutoModeUI(isActive) {
            document.querySelectorAll('#accordion-container input[type="range"], #mobile-accordion-container input[type="range"]').forEach(slider => {
                slider.disabled = isActive;
            });
            document.querySelectorAll('#accordion-container button:not(.accordion-toggle-btn):not(#auto-mode-btn), #mobile-accordion-container button:not(.accordion-toggle-btn):not(#auto-mode-btn)').forEach(button => {
                button.disabled = isActive;
            });
            
            const autoModeButtons = document.querySelectorAll('#auto-mode-btn');
            if(isActive) {
                autoModeButtons.forEach(btn => btn.classList.add('bg-green-200', 'text-green-800'));
                autoModeManager.start();
            } else {
                autoModeButtons.forEach(btn => btn.classList.remove('bg-green-200', 'text-green-800'));
                autoModeManager.stop();
            }
        }
        
        function showNotification(key, type = 'info', params = {}) {
            const logContainer = dom.logContent;
            const latestEventText = dom.latestEventText;
            const latestEventIcon = dom.latestEventIcon;

            if (!logContainer || !latestEventText || !latestEventIcon) return;

            let message = translations[currentLang][key] || key;
            for (const param in params) {
                message = message.replace(`{${param}}`, params[param]);
            }

            const logEntry = document.createElement('p');
            let icon = '⚪';
            let textColor = 'text-gray-300';

            if (type === 'warning') { icon = '⚠️'; textColor = 'text-yellow-300'; }
            if (type === 'danger') { icon = '🚨'; textColor = 'text-red-400'; }
            if (type === 'death') { icon = '💀'; textColor = 'text-gray-500'; }
            if (type === 'info') { icon = 'ℹ️'; textColor = 'text-blue-300'; }
            if (type === 'birth') { icon = '🎉'; textColor = 'text-green-300'; }

            const timestamp = new Date().toLocaleTimeString(localeMap[currentLang] || 'en-US');
            logEntry.className = `flex items-start ${textColor}`;
            logEntry.innerHTML = `<span class="w-6 flex-shrink-0">${icon}</span><span class="flex-grow">${message}</span><span class="ml-2 text-gray-400">${timestamp}</span>`;

            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            if (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.firstChild);
            }
            
            latestEventIcon.textContent = icon;
            latestEventText.textContent = message;
            latestEventText.style.opacity = 1;
            latestEventIcon.classList.add('icon-pulse');

            clearTimeout(latestEventTimeout);
            latestEventTimeout = setTimeout(() => {
                latestEventText.style.opacity = 0;
            }, 4000);
            
            latestEventIcon.addEventListener('animationend', () => {
                latestEventIcon.classList.remove('icon-pulse');
            }, { once: true });
        }

        function setupUI() {
            const accordionContainer = dom.accordionContainer;
            const mobileAccordionContainer = dom.mobileAccordionContainer;
            accordionContainer.innerHTML = '';
            mobileAccordionContainer.innerHTML = '';
            const lang = translations[currentLang];

            const createAccordionSection = (titleKey, contentHtml, icon) => {
                const section = document.createElement('div');
                section.className = 'glass rounded-xl overflow-hidden mb-4';
                section.innerHTML = `
                    <button class="accordion-toggle-btn w-full flex justify-between items-center p-4 text-left font-semibold text-white hover:bg-primary-900/30 transition-colors">
                        <span class="flex items-center"><i class="fa-solid ${icon} mr-3 text-primary-400"></i> <span data-lang-key="${titleKey}">${lang[titleKey]}</span></span>
                        <span class="transform transition-transform duration-300 text-primary-400"><i class="fa-solid fa-chevron-down"></i></span>
                    </button>
                    <div class="accordion-content px-4 pb-4">
                        <div class="border-t border-primary-700/30 pt-4">${contentHtml}</div>
                    </div>
                `;
                return section;
            };

            const setupAccordionListeners = (section) => {
                const button = section.querySelector('button');
                const content = section.querySelector('.accordion-content');
                const arrow = button.querySelector('span.transform i'); // Cibler l'icône de la flèche
                button.addEventListener('click', () => {
                    const isOpen = content.classList.contains('open');
                    const container = section.parentElement;
                    container.querySelectorAll('.accordion-content.open').forEach(el => {
                        if (el !== content) {
                            el.classList.remove('open');
                            el.style.maxHeight = null;
                            el.previousElementSibling.querySelector('span.transform i').classList.remove('rotate-180');
                        }
                    });
                    if (!isOpen) {
                        content.classList.add('open');
                        content.style.maxHeight = content.scrollHeight + "px";
                        arrow.classList.add('rotate-180');
                    } else {
                        content.classList.remove('open');
                        content.style.maxHeight = null;
                        arrow.classList.remove('rotate-180');
                    }
                });
            };

            const createSlider = (id, labelKey, min, max, step, value, dataAttributes) => {
                const dataAttrString = Object.entries(dataAttributes).map(([key, val]) => `data-${key}="${val}"`).join(' ');
                // Added distinct classes for value spans to allow for more specific styling
                const valueClass = `font-mono bg-primary-900/50 text-white px-2 py-0.5 rounded ${dataAttributes.category}-${dataAttributes.property}-value`;
                const labelClass = `param-label flex-grow text-gray-400`;

                return `
                    <div class="mb-3">
                        <label for="${id}" class="flex justify-between items-center text-sm font-medium mb-1">
                            <span data-lang-key="${labelKey}" class="${labelClass}">${lang[labelKey]}</span>
                            <span id="${id}-value" class="${valueClass}">${value}</span>
                        </label>
                        <input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${value}" ${dataAttrString}>
                    </div>
                `;
            };

            let speciesContent = '<div class="space-y-4">';
            for (const species in fishSpecies) {
                const config = fishSpecies[species];
                const color = `#${config.color.toString(16).padStart(6, '0')}`;
                speciesContent += `<div class="p-4 rounded-xl glass mb-3" style="border: 1px solid ${color}66"><h4 class="font-bold mb-3 flex items-center" style="color: ${color};"><i class="fa-solid fa-fish mr-2"></i>${species.toUpperCase()}</h4>`;
                speciesContent += createSlider(`${species}-count`, 'count', 0, 150, 1, config.count, { category: 'species', species: species, property: 'count' });
                speciesContent += createSlider(`${species}-scale`, 'scale', 0.1, 3, 0.1, config.scale, { category: 'species', species: species, property: 'scale' });
                speciesContent += createSlider(`${species}-maxSpeed`, 'max_speed', 0.1, 1.0, 0.1, config.maxSpeed, { category: 'species', species: species, property: 'maxSpeed' });
                if (config.perceptionRadius !== undefined) {
                    speciesContent += createSlider(`${species}-perceptionRadius`, 'perception_radius', 10, 150, 1, config.perceptionRadius, { category: 'species', species: species, property: 'perceptionRadius' });
                }
                if (config.fearRadius !== undefined) {
                    speciesContent += createSlider(`${species}-fearRadius`, 'fear_radius', 0, 150, 1, config.fearRadius, { category: 'species', species: species, property: 'fearRadius' });
                }
                if (config.fertility !== undefined) {
                    speciesContent += createSlider(`${species}-fertility`, 'fertility', 0, 0.1, 0.001, config.fertility, { category: 'species', species: species, property: 'fertility' });
                }
                speciesContent += '</div>';
            }
            speciesContent += '</div>';
            
            let paramsContent = `<h4 class="font-bold mb-3 text-primary-300 flex items-center" data-lang-key="forces"><i class="fa-solid fa-fingerprint mr-2"></i>${lang['forces']}</h4>`;
            paramsContent += createSlider('alignment', 'alignment', 0, 2, 0.1, flockingForces.alignment, { category: 'flocking', property: 'alignment' });
            paramsContent += createSlider('cohesion', 'cohesion', 0, 2, 0.1, flockingForces.cohesion, { category: 'flocking', property: 'cohesion' });
            paramsContent += createSlider('separation', 'separation', 0, 2, 0.1, flockingForces.separation, { category: 'flocking', property: 'separation' });
            paramsContent += `<h4 class="font-bold mb-3 mt-5 text-primary-300 flex items-center" data-lang-key="environment"><i class="fa-solid fa-mountain-sun mr-2"></i>${lang['environment']}</h4>`;
            paramsContent += createSlider('rockCount', 'rock_count', 0, 50, 1, environmentSettings.rockCount, { category: 'environment', property: 'rockCount', reset: 'decor' });
            paramsContent += createSlider('plantCount', 'plant_count', 0, 100, 1, environmentSettings.plantCount, { category: 'environment', property: 'plantCount', reset: 'plants' });
            
            const createButton = (id, labelKey, extraClasses = '', icon = '', disabled = false) => `<button id="${id}" class="w-full text-left px-4 py-3 text-sm font-medium text-white bg-primary-900/30 rounded-lg hover:bg-primary-800/50 transition-all transform hover:-translate-y-1 shadow-md hover:shadow-lg mb-2 ${extraClasses}" data-lang-key="${labelKey}" ${disabled ? 'disabled' : ''}><i class="fa-solid ${icon} mr-2 text-primary-400"></i>${lang[labelKey]}</button>`;
            
            let actionsContent = `
                <div class="space-y-3">
                    ${createButton('feed-btn', 'feed', '', 'fa-cookie-bite')}
                    ${createButton('release-ropefish-btn', 'release_ropefish', '', 'fa-dragon')}
                    <div class="text-sm p-3 rounded-xl glass mb-2 flex justify-between items-center">
                        <span data-lang-key="ropefish_status_label" class="flex items-center"><i class="fa-solid fa-circle-info mr-2 text-primary-400"></i>${lang['ropefish_status_label']}:</span>
                        <span class="font-bold text-accent-400 ropefish-status-text">${lang['inactive']}</span>
                    </div>
                    ${createButton('toggle-view-btn', 'toggle_view', '', 'fa-camera')}
                    ${createButton('auto-mode-btn', 'auto_mode', '', 'fa-robot')}
                    <div id="auto-mode-stats" class="hidden text-sm p-3 rounded-xl glass mb-2 space-y-2">
                        <div class="flex justify-between items-center">
                            <span data-lang-key="survival_time" class="flex items-center"><i class="fa-solid fa-hourglass-half mr-2 text-primary-400"></i>${lang['survival_time']}:</span>
                            <span id="auto-mode-timer" class="font-mono font-bold text-primary-300">00:00</span>
                        </div>
                    </div>
                </div>`;
            
            let statsContent = `<div id="stats-panel-content" class="text-sm space-y-3">`;
            statsContent += `<div class="p-3 rounded-xl glass mb-3"><p class="flex justify-between items-center"><span class="flex items-center" data-lang-key="prey_eaten"><i class="fa-solid fa-skull-crossbones mr-2 text-accent-500"></i>${lang['prey_eaten']}:</span> <span id="stats-prey-eaten" class="font-mono text-accent-400 font-bold">0</span></p></div>`;
            for (const species in fishSpecies) {
                const color = `#${fishSpecies[species].color.toString(16).padStart(6, '0')}`;
                statsContent += `<div id="stats-container-${species}" class="p-3 rounded-xl glass mb-2" style="border: 1px solid ${color}66">
                    <h5 class="font-bold flex items-center mb-2" style="color: ${color};"><i class="fa-solid fa-fish mr-2"></i>${species.toUpperCase()}</h5>
                    <p class="flex justify-between items-center mb-1"><span class="flex items-center"><i class="fa-solid fa-calculator mr-2 text-primary-400"></i>Population:</span> <span id="stats-${species}-count" class="font-mono text-white">0</span></p>
                    <p class="flex justify-between items-center mb-1"><span class="flex items-center" data-lang-key="eggs_laid"><i class="fa-solid fa-egg mr-2 text-primary-400"></i>${lang['eggs_laid']}:</span> <span id="stats-${species}-eggs" class="font-mono text-white">0</span></p>
                    <p class="flex justify-between items-center mb-1"><span class="flex items-center" data-lang-key="babies_hatched"><i class="fa-solid fa-baby mr-2 text-primary-400"></i>${lang['babies_hatched']}:</span> <span id="stats-${species}-babies" class="font-mono text-white">0</span></p>
                    <p class="flex justify-between items-center"><span class="flex items-center" data-lang-key="generation"><i class="fa-solid fa-arrow-up-right-dots mr-2 text-primary-400"></i>${lang['generation']}:</span> <span id="stats-${species}-generation" class="font-mono text-white">1</span></p>
                </div>`;
            }
            statsContent += `</div>`;
            
            let systemContent = `
                <div class="space-y-3">
                    <div class="flex items-center space-x-2">
                        ${createButton('save-btn', 'save', 'opacity-50 cursor-not-allowed flex-grow', 'fa-floppy-disk', true)}
                        <span class="save-feedback text-secondary-400 opacity-0"><i class="fa-solid fa-circle-check text-xl"></i></span>
                    </div>
                    ${createButton('load-btn', 'load_save', 'opacity-50 cursor-not-allowed', 'fa-folder-open', true)}
                    ${createButton('reset-btn', 'reset', '', 'fa-arrows-rotate')}
                    ${createButton('clear-save-btn', 'clear_save', 'hover:bg-red-700/40 text-accent-300 hover:text-accent-200 opacity-50 cursor-not-allowed', 'fa-trash-can', true)}
                </div>`;
            
            const sections = [
                createAccordionSection('species', speciesContent, '🐠'),
                createAccordionSection('parameters', paramsContent, '🛠️'),
                createAccordionSection('actions', actionsContent, '⚡'),
                createAccordionSection('statistics', statsContent, '📊'),
                createAccordionSection('system', systemContent, '💾')
            ];

            sections.forEach(section => {
                const desktopSection = section.cloneNode(true);
                const mobileSection = section.cloneNode(true);
                accordionContainer.appendChild(desktopSection);
                mobileAccordionContainer.appendChild(mobileSection);
                setupAccordionListeners(desktopSection);
                setupAccordionListeners(mobileSection);
            });

            document.querySelectorAll('button[id]:not([disabled])').forEach(button => {
                button.addEventListener('click', handleButtonClick);
            });

            document.querySelectorAll('input[type=range]').forEach(slider => {
                slider.addEventListener('input', handleSliderInput);
            });
        }

        /**
         * A more efficient way to re-create the boid population based on new counts.
         * This avoids a full simulation reset.
         */
        function recreateBoidPopulation() {
            // Remove all existing boids from the scene
            boids.forEach(boid => scene.remove(boid.mesh));
            boids = [];

            // Create new boids based on the updated counts in fishSpecies
            for (const species in fishSpecies) {
                const config = fishSpecies[species];
                for (let i = 0; i < config.count; i++) {
                    boids.push(new Boid(species));
                }
            }
        }

        // --- Event handlers for UI interaction ---
        function handleButtonClick(e) {
            const id = e.currentTarget.id;
            const lang = translations[currentLang];
            switch(id) {
                case 'feed-btn': generateFood(); break;
                case 'release-ropefish-btn':
                    if (superPredator.isActive) {
                        superPredator.remove();
                    } else {
                        superPredator.spawn();
                    }
                    break;
                case 'toggle-view-btn': 
                    isSubmarineViewActive = !isSubmarineViewActive;
                    submarine.mesh.visible = !isSubmarineViewActive;
                    controls.enabled = !isSubmarineViewActive;
                    document.querySelectorAll('#toggle-view-btn').forEach(btn => {
                        btn.textContent = isSubmarineViewActive ? lang.view_orbital : lang.view_submarine;
                    });
                    break;
                case 'auto-mode-btn':
                    isAutoModeActive = !isAutoModeActive;
                    toggleAutoModeUI(isAutoModeActive);
                    break;
                case 'random-mode-btn': randomizeSettings(); break;
                // case 'save-btn': saveState(); break; // Disabled
                // case 'load-btn': loadState(true); break; // Disabled
                case 'reset-btn': resetSimulation(); break;
                // case 'clear-save-btn': // Disabled
                //     try { 
                //         localStorage.removeItem('aquarium-state'); 
                //         alert('Sauvegarde effacée.');
                //     } catch(e) {}
                //     break;
            }
        }

        function handleSliderInput(e) {
            const { value, id, dataset } = e.target;
            const { category, species, property } = dataset;
            document.querySelectorAll(`#${id}-value`).forEach(el => {
                el.textContent = parseFloat(value).toFixed(id.includes('fertility') ? 3 : (e.target.step < 1 ? 1 : 0));
            });
            
            if (category === 'species') {
                fishSpecies[species][property] = parseFloat(value);
                if (property === 'count') {
                    // If the number of fish changes, recreate the population.
                    recreateBoidPopulation();
                } else {
                    // Otherwise, update properties of existing fish in real-time.
                    updateBoidProperties(species, property, parseFloat(value));
                }
            }
            else if (category === 'flocking') {
                flockingForces[property] = parseFloat(value);
            }
            else if (category === 'environment') {
                environmentSettings[property] = parseInt(value, 10);
                if (property === 'rockCount') createDecor();
                else if (property === 'plantCount') createPlants();
            }
        }

        function generateFood() {
            const count = Math.floor(Math.random() * 10) + 15;
            for (let i = 0; i < count; i++) {
                const position = new THREE.Vector3((Math.random() - 0.5) * worldSize.width * 0.8, worldSize.height * (0.8 + Math.random() * 0.15), (Math.random() - 0.5) * worldSize.depth * 0.8);
                food.push(new FoodParticle(position));
            }
        }

        // --- The main animation loop ---
        function animate(time) {
            // Optimisation: Utiliser `performance.now()` pour un timing précis et ignorer les calculs si le temps n'a pas avancé
            const deltaTime = time - lastFrameTime;
            if (deltaTime > 16.67) { // 60 FPS
                requestAnimationFrame(animate);
                
                if (isAutoModeActive) autoModeManager.update();

                // Optimisation: regrouper les filtrages et les boucles
                const aliveBoids = boids.filter(b => !b.isEaten);
                const totalFish = aliveBoids.length;
                
                // Logique de propagation de la maladie
                if (totalFish > 600 && !criticalDiseaseTriggered) {
                    criticalDiseaseTriggered = true;
                    diseaseEventTriggered = true;
                    fishMarkedForCull = [];
                    triggerImmediateDisease(0.8);
                } else if (totalFish >= 500 && !diseaseEventTriggered && !criticalDiseaseTriggered) {
                    diseaseEventTriggered = true;
                    triggerProgressiveDisease(0.5 + Math.random() * 0.3);
                } else if (totalFish < 400) {
                    diseaseEventTriggered = false;
                    criticalDiseaseTriggered = false;
                    fishMarkedForCull = [];
                }

                if (fishMarkedForCull.length > 0) {
                    diseaseSpreadCounter++;
                    if (diseaseSpreadCounter > 10) { 
                        const fishToInfect = fishMarkedForCull.pop();
                        if (fishToInfect && !fishToInfect.isDiseased) {
                            fishToInfect.isDiseased = true;
                            fishToInfect.diseaseTimer = 600; // 10 seconds
                            createDiseaseEffect(fishToInfect.position);
                            showNotification('notif_infected', 'info', { species: fishToInfect.species });
                        }
                        diseaseSpreadCounter = 0;
                    }
                }
                
                // Mettre à jour les boids en vie
                for (const boid of aliveBoids) {
                    boid.update(boids); // Passez le tableau complet pour la logique de comportement
                }

                // Mettre à jour les œufs
                const hatchedBoids = [];
                eggs = eggs.filter(egg => {
                    const hatched = egg.update();
                    if (hatched) {
                        hatchedBoids.push(...hatched);
                        scene.remove(egg.mesh);
                        return false;
                    }
                    return true;
                });
                boids.push(...hatchedBoids);

                // Mettre à jour les particules et la nourriture
                food = food.filter(p => {
                    if (p.update()) {
                        scene.remove(p.mesh);
                        return false;
                    }
                    return true;
                });
                particles = particles.filter(p => {
                    p.position.add(p.userData.velocity);
                    p.userData.life -= 0.05;
                    if (p.userData.life <= 0) {
                        scene.remove(p);
                        return false;
                    }
                    return true;
                });
                
                // Mettre à jour le super prédateur et le sous-marin
                superPredator.update(boids);
                submarine.update();

                // Supprimer les boids mangés après la mise à jour de la boucle
                boids = boids.filter(boid => {
                    if (boid.isEaten) {
                        simulationStats.totalDeaths++;
                        if (boid.isDiseased) {
                            showNotification('notif_death_disease', 'death', { species: boid.species });
                        }
                        scene.remove(boid.mesh); 
                        return false; 
                    }
                    return true;
                });

                // Mettre à jour les statistiques de manière moins fréquente
                const now = performance.now();
                if (now - lastStatsUpdateTime > 1000) { // Throttle stats update
                    updateStats();
                    lastStatsUpdateTime = now;
                }
                
                // Rendre la scène
                const activeCamera = isSubmarineViewActive ? submarine.camera : camera;
                if (controls.enabled) controls.update();
                renderer.render(scene, activeCamera);

                lastFrameTime = time;
            } else {
                requestAnimationFrame(animate);
            }
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            if (submarine) {
                submarine.camera.aspect = aspect;
                submarine.camera.updateProjectionMatrix();
            }
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Modal and UI initialization ---
        function initModal() {
            const modal = dom.welcomeModal;
            const startBtn = dom.startSimulationBtn;
            const checkbox = dom.dontShowAgainCheckbox;
            const content = modal.querySelector('.transform');
            const langSelector = dom.langSelector;

            langSelector.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON' && e.target.dataset.lang) {
                    setLanguage(e.target.dataset.lang);
                }
            });

            try {
                if (localStorage.getItem('aquarium-welcome-dismissed')) {
                    modal.classList.add('hidden');
                    return;
                }
            } catch(e) {}

            setTimeout(() => {
                content.classList.remove('scale-95', 'opacity-0');
                content.classList.add('scale-100', 'opacity-100');
            }, 100);

            startBtn.addEventListener('click', () => {
                try {
                    if (checkbox.checked) localStorage.setItem('aquarium-welcome-dismissed', 'true');
                } catch(e) {}
                content.classList.add('scale-95', 'opacity-0');
                setTimeout(() => modal.classList.add('hidden'), 300);
            });
        }
        
        function setupUIToggle() {
            const toggleButtons = document.querySelectorAll('.ui-toggle-btn');
            const mobileDrawer = dom.mobileControlsDrawer;
            const mobileContainer = dom.mobileControlsContainer;
            const sidebar = dom.controlsSidebar;
            const mobileToggleBtn = document.getElementById('mobile-toggle-btn');

            // Toggle for the main controls sidebar (desktop only)
            const desktopSidebarToggleBtn = document.querySelector('.ui-toggle-btn[data-target="controls-sidebar"]');
            if (desktopSidebarToggleBtn) {
                desktopSidebarToggleBtn.addEventListener('click', () => {
                    const isVisible = !sidebar.classList.toggle('-translate-x-full');
                    desktopSidebarToggleBtn.classList.toggle('opacity-50', !isVisible);
                });
            }

            // Toggle for the mobile controls drawer
            if (mobileToggleBtn) {
                 mobileToggleBtn.addEventListener('click', () => {
                    const isVisible = mobileDrawer.classList.contains('translate-y-full');
                    if (isVisible) {
                        mobileDrawer.classList.remove('translate-y-full');
                        mobileContainer.classList.remove('pointer-events-none');
                    } else {
                        mobileDrawer.classList.add('translate-y-full');
                        mobileContainer.classList.add('pointer-events-none');
                    }
                });
            }
           
            // UI Toggle for header and event log (for all devices)
            const otherUiToggles = document.querySelectorAll('.ui-toggle-btn:not([data-target="controls-sidebar"])');
             otherUiToggles.forEach(button => {
                button.addEventListener('click', () => {
                    const targetId = button.dataset.target;
                    const targetElement = document.getElementById(targetId);
                    if (!targetElement) return;

                    const isVisible = !targetElement.classList.toggle('opacity-0');
                    targetElement.classList.toggle('pointer-events-none', !isVisible);
                    
                    button.classList.toggle('opacity-50', !isVisible);
                });
            });
        }
        
        // --- Cache DOM elements on page load ---
        function cacheDOMElements() {
            dom.fishCounts = document.querySelectorAll('.fish-count');
            dom.predatorCounts = document.querySelectorAll('.predator-count');
            dom.preyPredatorRatios = document.querySelectorAll('.prey-predator-ratio');
            dom.birthCounts = document.querySelectorAll('.birth-count');
            dom.deathCounts = document.querySelectorAll('.death-count');
            dom.logContent = document.getElementById('log-content');
            dom.latestEventText = document.getElementById('latest-event-text');
            dom.latestEventIcon = document.getElementById('latest-event-icon');
            dom.accordionContainer = document.getElementById('accordion-container');
            dom.mobileAccordionContainer = document.getElementById('mobile-accordion-container');
            dom.welcomeModal = document.getElementById('welcome-modal');
            dom.startSimulationBtn = document.getElementById('start-simulation-btn');
            dom.dontShowAgainCheckbox = document.getElementById('dont-show-again');
            dom.langSelector = document.getElementById('lang-selector');
            dom.mobileControlsDrawer = document.getElementById('mobile-controls-drawer');
            dom.mobileControlsContainer = document.getElementById('mobile-controls-container');
            dom.controlsSidebar = document.getElementById('controls-sidebar');
            dom.autoModeTimer = document.getElementById('auto-mode-timer');
            dom.autoModeStats = document.getElementById('auto-mode-stats');
        }

        // --- Main entry point when the document is ready ---
        document.addEventListener('DOMContentLoaded', () => {
            cacheDOMElements();
            init();
            const loaded = loadState();
            if (!loaded) {
                resetSimulation();
            }
            setupUI();
            initModal();
            setupUIToggle();
            setLanguage(currentLang);
            animate();
        });

    </script>
</body>
</html>
