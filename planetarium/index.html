<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planétarium 3D - Simulation du Système Solaire</title>
    
    <!-- Métadonnées SEO de base -->
    <meta name="description" content="Une simulation interactive et visuelle du système solaire en 3D avec un rendu de style fil de fer. Explorez les planètes, lunes, astéroïdes et sondes spatiales.">
    <meta name="keywords" content="planétarium, système solaire, simulation 3D, Three.js, rendu vectoriel, orbites, planètes, étoiles, astéroïdes, sondes spatiales">
    <meta name="author" content="Leonce Equity">

    <!-- Balises Open Graph pour le partage sur les réseaux sociaux (Facebook, LinkedIn, etc.) -->
    <meta property="og:title" content="Planétarium 3D - Une simulation du Système Solaire">
    <meta property="og:description" content="Explorez le système solaire d'une manière unique avec cette simulation interactive. Un rendu rétro-futuriste pour un voyage dans l'espace.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://leonce-equity.com/planetarium/">
    <meta property="og:image" content="https://leonce-equity.com/planetarium/planetarium.png">
    
    <!-- Balises Twitter Card pour le partage sur Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Planétarium 3D - Simulation du Système Solaire">
    <meta name="twitter:description" content="Découvrez une simulation interactive du système solaire en 3D avec un style vectoriel unique. Planets, lunes, comètes, tout y est !">
    <meta name="twitter:image" content="https://leonce-equity.com/planetarium/planetarium.png">

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }

        /* --- Panneau de Démarrage (Splash Screen) --- */
        #splash-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: #00ff00;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 100;
            transition: opacity 1s ease-out;
        }
        #splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #splash-screen h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-transform: uppercase;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 10px;
        }
        #splash-screen p {
            max-width: 500px;
            margin: 0 auto 30px auto;
            line-height: 1.6;
        }
        #start-button {
            background-color: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 15px 30px;
            font-family: inherit;
            font-size: 1.2em;
            cursor: pointer;
            text-transform: uppercase;
            transition: background-color 0.3s, color 0.3s;
        }
        #start-button:hover {
            background-color: #00ff00;
            color: #000;
        }

        /* --- Interface Utilisateur (HUD) --- */
        #hud-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }
        .hud-panel {
            color: #00ff00;
            background-color: rgba(0, 20, 0, 0.7);
            padding: 10px;
            border: 1px solid #00ff00;
            pointer-events: auto;
        }
        #info-panel {
            max-width: 250px;
        }
        #info-panel label {
            display: block;
            margin-bottom: 5px;
        }
        #info-panel select {
            width: 100%;
            padding: 5px;
            border-radius: 0;
            background-color: #001400;
            color: #00ff00;
            border: 1px solid #00ff00;
            font-family: inherit;
            max-height: 150px; /* Ajout pour un meilleur contrôle sur mobile */
            overflow-y: auto; /* Permet le défilement si la liste est longue */
        }
        #info-panel select:focus {
            outline: 1px solid #00ff00;
        }
        /* Style de la scrollbar pour le menu déroulant */
        #info-panel select::-webkit-scrollbar {
            width: 8px;
        }
        #info-panel select::-webkit-scrollbar-track {
            background: #001400;
        }
        #info-panel select::-webkit-scrollbar-thumb {
            background-color: #ffa500;
            border-radius: 4px;
        }
        #time-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        #time-controls button {
            background-color: transparent;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 5px 10px;
            font-family: inherit;
            cursor: pointer;
        }
        #time-controls button:hover {
            background-color: #00ff00;
            color: #000;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 120px;
            background: transparent;
        }
        /* Style du curseur pour les navigateurs basés sur WebKit (Chrome, Safari) */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: 1px solid #ffa500; /* Couleur orange pour le curseur */
            height: 18px;
            width: 10px;
            background: #ffa500; /* Couleur orange pour le curseur */
            cursor: pointer;
            margin-top: -8px;
        }
        /* Style du curseur pour Firefox */
        input[type=range]::-moz-range-thumb {
            border: 1px solid #ffa500; /* Couleur orange pour le curseur */
            height: 18px;
            width: 10px;
            background: #ffa500; /* Couleur orange pour le curseur */
            cursor: pointer;
        }
        /* Style de la piste pour les navigateurs basés sur WebKit (Chrome, Safari) */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: #ffa500; /* Couleur orange pour la piste */
        }
        /* Style de la piste pour Firefox */
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: #ffa500; /* Couleur orange pour la piste */
        }
        .label {
            position: absolute;
            color: #00ff00;
            background-color: rgba(0, 20, 0, 0.7);
            border: 1px solid #00ff00;
            padding: 5px 10px;
            font-size: 14px;
            white-space: nowrap;
            transform: translate(-50%, -120%);
            pointer-events: none;
            display: none;
        }
        #date-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
        }

        /* --- Menu Radial --- */
        #radial-menu-container {
            position: absolute;
            display: none;
            z-index: 1000;
        }
        .radial-menu-button {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #00ff00;
            color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 1px solid #00ff00;
        }
        .radial-menu-button:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px #00ff00;
        }
        .radial-menu-center {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* Styles spécifiques pour les appareils mobiles */
        @media (max-width: 768px) {
            #hud-container {
                flex-direction: column;
                align-items: center;
                gap: 10px;
                left: 5px;
                right: 5px;
            }
            .hud-panel {
                width: 90%;
                box-sizing: border-box;
            }
            #time-controls {
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }
            #info-panel select {
                border: 1px dashed #00ff00;
                color: #00ff00;
            }
        }
    </style>
</head>
<body>
    <div id="splash-screen">
        <h1>PLANÉTARIUM_v3.js</h1>
        <p>Une simulation en rendu vectoriel du système solaire. Explorez les orbites des planètes, des lunes et d'autres corps célestes. Utilisez la souris pour naviguer et un clic droit pour ouvrir un menu d'options.</p>
        <button id="start-button">LANCER LA SIMULATION</button>
    </div>

    <div id="hud-container">
        <div id="info-panel" class="hud-panel">
            <label for="target-selector">CIBLE :</label>
            <select id="target-selector"></select>
        </div>
        <div id="time-controls" class="hud-panel">
            <button id="pause-btn">PAUSE</button>
            <button id="play-btn">PLAY</button>
            <div class="slider-container">
                <label for="speed-slider">VITESSE:</label>
                <input type="range" id="speed-slider" min="1" max="100" value="10">
                <span id="speed-value">x10</span>
            </div>
        </div>
    </div>
    <div id="label-container"></div>
    <div id="date-panel" class="hud-panel"></div>

    <!-- Menu Radial -->
    <div id="radial-menu-container">
        <div class="radial-menu-center"></div>
        <div class="radial-menu-button" id="radial-target-btn" style="top: -60px; left: -20px;">CIBLER</div>
        <div class="radial-menu-button" id="radial-info-btn" style="top: 20px; left: 40px;">INFO</div>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- VARIABLES GLOBALES ---
        let scene, camera, renderer, controls;
        const celestialBodies = new Map();
        const GLOW_COLOR = 0x00ff00; // Couleur verte
        const ORANGE_COLOR = 0xffa500; // Couleur orange
        let simulationTime;
        let timeScale = 10;
        let isPaused = false;
        let labelContainer;
        let cameraTarget = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let datePanel;
        const simulationStartDate = new Date('2025-01-01T00:00:00');
        let radialMenuContainer;
        let targetedObject = null;

        // --- INITIALISATION ---
        function main() {
            setupTime();
            setupScene();
            setupLighting();
            createCelestialBodies();
            setupUI();
            setupEventListeners();
            animate(); // Démarrer la boucle d'animation
        }

        // --- CONFIGURATION DU TEMPS ---
        function setupTime() {
            const today = new Date('2025-08-03T14:45:00');
            const startOfYear = new Date(today.getFullYear(), 0, 0);
            const diff = today - startOfYear;
            const oneDay = 1000 * 60 * 60 * 24;
            const dayOfYear = diff / oneDay;
            simulationTime = dayOfYear;
        }

        // --- CONFIGURATION DE LA SCÈNE ---
        function setupScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 8000);
            camera.position.set(0, 700, 1500);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            labelContainer = document.getElementById('label-container');
            datePanel = document.getElementById('date-panel');
            radialMenuContainer = document.getElementById('radial-menu-container');
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 20;
            controls.maxDistance = 5000;
        }

        // --- CONFIGURATION DE L'ÉCLAIRAGE ---
        function setupLighting() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.2)); 
        }

        // --- CRÉATION DES OBJETS CÉLESTES ---
        function createCelestialBodies() {
            createSun();
            const earth = createPlanet('Terre', { size: 10, distance: 210, period: 1, tilt: 23.5, eccentricity: 0.017, info: "Planète tellurique" });
            createMoon(earth, { name: 'Lune', size: 2.7, distance: 20, period: 0.074, eccentricity: 0.055, info: "Satellite naturel" });
            createPlanet('Mercure', { size: 3.8, distance: 98, period: 0.24, tilt: 0.03, eccentricity: 0.206, info: "La plus proche du Soleil" });
            createPlanet('Vénus', { size: 9.5, distance: 148, period: 0.62, tilt: 177.4, eccentricity: 0.007, info: "Rotation rétrograde" });
            createPlanet('Mars', { size: 5.3, distance: 268, period: 1.88, tilt: 25.2, eccentricity: 0.094, info: "La planète rouge" });
            const jupiter = createPlanet('Jupiter', { size: 52, distance: 480, period: 11.86, tilt: 3.1, eccentricity: 0.049, info: "Géante gazeuse" });
            createMoon(jupiter, { name: 'Io', size: 3.6, distance: 70, period: 0.004, eccentricity: 0.004, info: "Lune volcanique" });
            createMoon(jupiter, { name: 'Europe', size: 3.1, distance: 90, period: 0.009, eccentricity: 0.009, info: "Océan sous-glaciaire" });
            createMoon(jupiter, { name: 'Ganymède', size: 5.2, distance: 110, period: 0.019, eccentricity: 0.001, info: "Plus grande lune" });
            createMoon(jupiter, { name: 'Callisto', size: 4.8, distance: 130, period: 0.045, eccentricity: 0.007, info: "Surface cratérisée" });
            const saturn = createPlanet('Saturne', { size: 44, distance: 650, period: 29.46, tilt: 26.7, eccentricity: 0.057, rings: { inner: 65, outer: 90 }, info: "Géante aux anneaux" });
            createMoon(saturn, { name: 'Titan', size: 4, distance: 60, period: 0.043, eccentricity: 0.028, info: "Atmosphère dense" });
            createMoon(saturn, { name: 'Encelade', size: 0.8, distance: 48, period: 0.0037, eccentricity: 0.004, info: "Geysers de glace" });
            createPlanet('Uranus', { size: 20, distance: 800, period: 84.01, tilt: 97.8, eccentricity: 0.046, rings: { inner: 30, outer: 40 }, info: "Géante de glace" });
            createPlanet('Neptune', { size: 18, distance: 950, period: 164.79, tilt: 28.3, eccentricity: 0.011, info: "Vents supersoniques" });
            const pluto = createPlanet('Pluton', { size: 2, distance: 1150, period: 248, tilt: 122.5, eccentricity: 0.249, orbitTilt: 17.2, info: "Planète naine" });
            createMoon(pluto, { name: 'Charon', size: 1, distance: 15, period: 0.0175, eccentricity: 0.000, info: "Lune binaire" });
            const eris = createPlanet('Eris', { size: 1.8, distance: 1600, period: 558, tilt: 97.5, eccentricity: 0.44, orbitTilt: 44, info: "Planète naine lointaine" });
            createAsteroidBelt();
            createPlanet('Cérès', { size: 1.5, distance: 374, period: 4.6, tilt: 10.6, eccentricity: 0.076, orbitTilt: 10.6, info: "Dans la ceinture d'astéroïdes" }, ORANGE_COLOR);
            createComet('Halley', { size: 2, distance: 1200, period: 76, orbitTilt: 162.3, eccentricity: 0.967, info: "Comète périodique" });
            createTrojanAsteroids(jupiter);
            createProbe('Voyager 1', { startDistance: 1300, speed: 3.6, direction: new THREE.Vector3(0.5, 0.1, -0.8).normalize(), info: "Objet humain le plus lointain" });
            createProbe('Voyager 2', { startDistance: 1200, speed: 3.2, direction: new THREE.Vector3(-0.3, -0.2, -0.9).normalize(), info: "Explore les géantes de glace" });
        }

        // --- FONCTIONS DE CRÉATION D'OBJETS ---
        function createSun() {
            const data = { name: 'Soleil', size: 40, info: "Étoile de type G2V" };
            const material = new THREE.MeshBasicMaterial({ color: GLOW_COLOR, wireframe: true });
            const sun = new THREE.Mesh(new THREE.SphereGeometry(data.size, 32, 32), material);
            sun.name = data.name;
            scene.add(sun);
            const label = createLabel(data.name, data.info);
            celestialBodies.set(data.name, { mesh: sun, label: label, data: data });
        }

        function createPlanet(name, data, color = GLOW_COLOR) {
            const material = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const planet = new THREE.Mesh(new THREE.SphereGeometry(data.size, 24, 24), material);
            planet.name = name;
            planet.rotation.z = THREE.MathUtils.degToRad(data.tilt);
            const pivot = new THREE.Object3D();
            const orbitPivot = new THREE.Object3D();
            orbitPivot.add(pivot);
            pivot.add(planet);
            scene.add(orbitPivot);
            if (data.orbitTilt) {
                orbitPivot.rotation.x = THREE.MathUtils.degToRad(data.orbitTilt);
            }
            if (data.rings) {
                const ringGeo = new THREE.RingGeometry(data.rings.inner, data.rings.outer, 64);
                const ringMat = new THREE.MeshBasicMaterial({ color: color, wireframe: true, side: THREE.DoubleSide });
                const ringsMesh = new THREE.Mesh(ringGeo, ringMat);
                ringsMesh.rotation.x = -Math.PI / 2;
                planet.add(ringsMesh);
            }
            const { semiMajorAxis, semiMinorAxis } = createOrbit(data.distance, data.eccentricity, orbitPivot, color);
            const label = createLabel(name, data.info);
            const planetData = { name, mesh: planet, pivot: pivot, orbitPivot: orbitPivot, period: data.period, moons: [], semiMajorAxis, semiMinorAxis, label: label, data: data };
            celestialBodies.set(name, planetData);
            return planetData;
        }

        function createMoon(planetData, data) {
            const moon = new THREE.Mesh(new THREE.SphereGeometry(data.size, 16, 16), new THREE.MeshBasicMaterial({ color: GLOW_COLOR, wireframe: true }));
            moon.name = data.name;
            const pivot = new THREE.Object3D();
            const orbitPivot = new THREE.Object3D();
            orbitPivot.add(pivot);
            pivot.add(moon);
            planetData.mesh.add(orbitPivot);
            const { semiMajorAxis, semiMinorAxis } = createOrbit(data.distance, data.eccentricity, orbitPivot, GLOW_COLOR);
            const label = createLabel(data.name, data.info);
            const moonData = { name: data.name, mesh: moon, pivot: pivot, period: data.period, semiMajorAxis, semiMinorAxis, label: label, data: data };
            planetData.moons.push(moonData);
            celestialBodies.set(data.name, moonData);
        }

        function createComet(name, data) {
            const material = new THREE.MeshBasicMaterial({ color: ORANGE_COLOR, wireframe: true });
            const comet = new THREE.Mesh(new THREE.SphereGeometry(data.size, 16, 16), material);
            comet.name = name;
            const tailGeometry = new THREE.BufferGeometry();
            const tailPositions = new Float32Array([0, 0, 0, 0, 0, 50]);
            tailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(tailPositions, 3));
            const tailMaterial = new THREE.LineBasicMaterial({ color: ORANGE_COLOR, transparent: true, opacity: 0.5 });
            const tail = new THREE.Line(tailGeometry, tailMaterial);
            comet.add(tail);
            const pivot = new THREE.Object3D();
            const orbitPivot = new THREE.Object3D();
            orbitPivot.add(pivot);
            pivot.add(comet);
            scene.add(orbitPivot);
            orbitPivot.rotation.x = THREE.MathUtils.degToRad(data.orbitTilt);
            const { semiMajorAxis, semiMinorAxis } = createOrbit(data.distance, data.eccentricity, orbitPivot, ORANGE_COLOR);
            const label = createLabel(name, data.info);
            const cometData = { name, mesh: comet, pivot: pivot, orbitPivot: orbitPivot, period: data.period, semiMajorAxis, semiMinorAxis, tail: tail, label: label, data: data };
            celestialBodies.set(name, cometData);
            return cometData;
        }
        
        function createLabel(name, info) {
            const div = document.createElement('div');
            div.className = 'label';
            div.innerHTML = `${name.toUpperCase()}<br><small>${info}</small>`;
            labelContainer.appendChild(div);
            return div;
        }

        function createOrbit(semiMajorAxis, eccentricity, parent, color = GLOW_COLOR) {
            const semiMinorAxis = semiMajorAxis * Math.sqrt(1 - eccentricity * eccentricity);
            const focus = Math.sqrt(semiMajorAxis * semiMajorAxis - semiMinorAxis * semiMinorAxis);
            const points = [];
            for (let i = 0; i <= 128; i++) {
                const angle = (i / 128) * 2 * Math.PI;
                const x = semiMajorAxis * Math.cos(angle) - focus;
                const z = semiMinorAxis * Math.sin(angle);
                points.push(new THREE.Vector3(x, 0, z));
            }
            const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const orbit = new THREE.Line(orbitGeometry, new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.3 }));
            parent.add(orbit);
            return { semiMajorAxis, semiMinorAxis };
        }

        function createAsteroidBelt() {
            const vertices = [];
            const beltCenter = 374;
            const beltWidth = 100;
            for (let i = 0; i < 10000; i++) {
                const radius = beltCenter + (Math.random() - 0.5) * beltWidth;
                const angle = Math.random() * Math.PI * 2;
                const y = (Math.random() - 0.5) * 5;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                vertices.push(x, y, z);
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: ORANGE_COLOR, size: 0.5, transparent: true, opacity: 0.5 });
            const asteroidBelt = new THREE.Points(geometry, material);
            scene.add(asteroidBelt);
        }

        function createTrojanAsteroids(jupiterData) {
            const createCluster = (name, angleOffset) => {
                const vertices = [];
                const clusterRadius = 80;
                for (let i = 0; i < 2000; i++) {
                    const r = clusterRadius * Math.sqrt(Math.random());
                    const theta = Math.random() * 2 * Math.PI;
                    const y = (Math.random() - 0.5) * 10;
                    const x = r * Math.cos(theta);
                    const z = r * Math.sin(theta);
                    vertices.push(x, y, z);
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const material = new THREE.PointsMaterial({ color: ORANGE_COLOR, size: 0.4, transparent: true, opacity: 0.4 });
                const points = new THREE.Points(geometry, material);
                points.name = name;
                const pivot = new THREE.Object3D();
                pivot.add(points);
                scene.add(pivot);
                
                const info = (angleOffset > 0) ? "Point de Lagrange L4" : "Point de Lagrange L5";
                const label = createLabel(name, info);
                const trojanData = { name, mesh: points, pivot: pivot, period: jupiterData.period, semiMajorAxis: jupiterData.semiMajorAxis, semiMinorAxis: jupiterData.semiMinorAxis, angleOffset: angleOffset, label: label, data: { size: 80, info: info }, isCluster: true };
                celestialBodies.set(name, trojanData);
            };
            createCluster('Troyens L4', Math.PI / 3);
            createCluster('Troyens L5', -Math.PI / 3);
        }

        function createProbe(name, data) {
            const material = new THREE.MeshBasicMaterial({ color: ORANGE_COLOR });
            const probe = new THREE.Mesh(new THREE.SphereGeometry(1, 8, 8), material);
            probe.name = name;
            const startPos = data.direction.clone().multiplyScalar(data.startDistance);
            probe.position.copy(startPos);
            scene.add(probe);
            const lineMat = new THREE.LineBasicMaterial({ color: ORANGE_COLOR, transparent: true, opacity: 0.5 });
            const points = [new THREE.Vector3(0,0,0), startPos];
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeo, lineMat);
            scene.add(line);
            const label = createLabel(name, data.info);
            celestialBodies.set(name, { mesh: probe, label: label, data: data, isProbe: true, speed: data.speed, direction: data.direction });
        }
        
        // --- INTERFACE UTILISATEUR ---
        function setupUI() {
            const selector = document.getElementById('target-selector');
            const options = ['Aucune', ...celestialBodies.keys()];
            options.sort();
            options.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selector.appendChild(option);
            });
            selector.addEventListener('change', (e) => setTarget(e.target.value));

            const speedSlider = document.getElementById('speed-slider');
            const speedValue = document.getElementById('speed-value');
            speedSlider.addEventListener('input', (e) => {
                timeScale = parseInt(e.target.value);
                speedValue.textContent = `x${timeScale}`;
            });
            
            document.getElementById('pause-btn').addEventListener('click', () => isPaused = true);
            document.getElementById('play-btn').addEventListener('click', () => isPaused = false);

            document.getElementById('radial-target-btn').addEventListener('click', () => {
                if (targetedObject) {
                    const bodyData = celestialBodies.get(targetedObject.name);
                    if (bodyData) {
                        setTarget(bodyData.name);
                    }
                }
                radialMenuContainer.style.display = 'none';
            });
            document.getElementById('radial-info-btn').addEventListener('click', () => {
                const bodyData = celestialBodies.get(targetedObject.name);
                if (bodyData && bodyData.data) {
                    alert(`${bodyData.name.toUpperCase()}\n${bodyData.data.info}`);
                } else {
                    console.error("Impossible de trouver les informations de l'objet ciblé.");
                }
                radialMenuContainer.style.display = 'none';
            });
        }

        function setTarget(name) {
            const selector = document.getElementById('target-selector');
            if (name === 'Aucune' || !celestialBodies.has(name)) {
                cameraTarget = null;
                controls.target.set(0, 0, 0);
                selector.value = 'Aucune';
            } else {
                const body = celestialBodies.get(name);
                cameraTarget = body.mesh;
                selector.value = name;
            }
        }
        
        // --- GESTIONNAIRES D'ÉVÉNEMENTS ---
        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('contextmenu', onRightClick, false);
            window.addEventListener('click', onLeftClick, false);
        }

        function onRightClick(event) {
            event.preventDefault(); // Empêche le menu contextuel par défaut du navigateur
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Array.from(celestialBodies.values()).map(b => b.mesh));
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                targetedObject = object;
                radialMenuContainer.style.display = 'block';
                radialMenuContainer.style.left = `${event.clientX}px`;
                radialMenuContainer.style.top = `${event.clientY}px`;
            } else {
                radialMenuContainer.style.display = 'none';
            }
        }

        function onLeftClick(event) {
            // Cacher le menu radial si l'utilisateur clique ailleurs
            if (!event.target.closest('#radial-menu-container') && !event.target.closest('.hud-panel')) {
                radialMenuContainer.style.display = 'none';
                targetedObject = null;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- BOUCLE D'ANIMATION ---
        const positionVector = new THREE.Vector3();
        function animate() {
            requestAnimationFrame(animate);
            
            if (!isPaused) {
                simulationTime += timeScale / 60.0;
            }

            // Mettre à jour la date
            const currentDate = new Date(simulationStartDate.getTime());
            currentDate.setDate(currentDate.getDate() + simulationTime);
            datePanel.textContent = `DATE : ${currentDate.toLocaleDateString('fr-FR')}`;

            for (const [name, body] of celestialBodies.entries()) {
                if (body.isProbe) {
                    if (!isPaused) {
                        body.mesh.position.add(body.direction.clone().multiplyScalar(body.speed * timeScale / 60.0));
                    }
                } else if (name === 'Soleil') {
                    body.mesh.rotation.y += 0.0005;
                } else {
                    body.mesh.rotation.y += 0.01;
                    if (body.pivot) {
                        const speed = (2 * Math.PI) / (body.period * 365.25);
                        const angle = simulationTime * speed + (body.angleOffset || 0);
                        const focus = body.semiMajorAxis ? Math.sqrt(body.semiMajorAxis**2 - body.semiMinorAxis**2) : 0;
                        body.pivot.position.x = body.semiMajorAxis * Math.cos(angle) - focus;
                        body.pivot.position.z = body.semiMinorAxis * Math.sin(angle);
                    }
                    body.moons?.forEach(moon => {
                        const speed = (2 * Math.PI) / (moon.period * 365.25);
                        const moonAngle = simulationTime * speed;
                        const moonFocus = Math.sqrt(moon.semiMajorAxis**2 - moon.semiMinorAxis**2);
                        moon.pivot.position.x = moon.semiMajorAxis * Math.cos(moonAngle) - moonFocus;
                        moon.pivot.position.z = moon.semiMinorAxis * Math.sin(moonAngle);
                    });
                    if (body.tail) {
                        const cometPos = new THREE.Vector3();
                        body.mesh.getWorldPosition(cometPos);
                        const sunPos = new THREE.Vector3(0, 0, 0);
                        const distanceToSun = cometPos.distanceTo(sunPos);
                        body.tail.lookAt(sunPos);
                        const tailLength = Math.min(200, 4000 / distanceToSun);
                        body.tail.scale.z = tailLength;
                        body.tail.material.opacity = Math.min(0.8, 200 / distanceToSun);
                    }
                }

                if (body.label) {
                    body.mesh.getWorldPosition(positionVector);
                    const distance = camera.position.distanceTo(positionVector);
                    const visibilityDistance = body.isCluster ? 1200 : Math.max(150, body.data.size * 50);
                    if (distance < visibilityDistance) {
                        positionVector.project(camera);
                        if (positionVector.z < 1) {
                            const x = (positionVector.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (positionVector.y * -0.5 + 0.5) * window.innerHeight;
                            body.label.style.display = 'block';
                            body.label.style.left = `${x}px`;
                            body.label.style.top = `${y}px`;
                        } else {
                            body.label.style.display = 'none';
                        }
                    } else {
                        body.label.style.display = 'none';
                    }
                }
            }

            if (cameraTarget) {
                const targetPosition = new THREE.Vector3();
                cameraTarget.getWorldPosition(targetPosition);
                controls.target.lerp(targetPosition, 0.05);
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        // --- DÉMARRAGE ---
        document.getElementById('start-button').addEventListener('click', () => {
            const splash = document.getElementById('splash-screen');
            splash.classList.add('hidden');
            splash.addEventListener('transitionend', () => {
                splash.remove();
            });
            main(); // CORRECTION : Appeler main() immédiatement
        }, { once: true });

    </script>
</body>
</html>
