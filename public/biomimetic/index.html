<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio-Mimetic Market v7</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { margin: 0; background-color: #111827; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useEffect, useRef, useState } = React;

        // Configuration
        const SYMBOL = 'btcusdt';
        const WS_URL = `wss://stream.binance.com:9443/stream?streams=${SYMBOL}@aggTrade/${SYMBOL}@depth20@100ms`;
        const DUST_THRESHOLD = 0.05; 
        const WHALE_THRESHOLD = 2.0; 
        const MAX_PARTICLES = 200;
        const MAX_DEBRIS = 100;
        const BASE_RADIUS = 60;
        const TRAIL_LENGTH = 100;
        const NETWORK_DISTANCE = 120;

        function App() {
            const canvasRef = useRef(null);
            const wsRef = useRef(null);
            const audioCtxRef = useRef(null);
            const droneOscRef = useRef(null);
            const droneGainRef = useRef(null);
            
            const [price, setPrice] = useState(0);
            const [vwapDisplay, setVwapDisplay] = useState(0);
            const [isConnected, setIsConnected] = useState(false);
            const [audioEnabled, setAudioEnabled] = useState(false);
            const [networkEnabled, setNetworkEnabled] = useState(true);
            const [stats, setStats] = useState({ vol: 0, trades: 0, whales: 0, erosion: 0 });

            const systemRef = useRef({
                particles: [], debris: [], impacts: [], shockwaves: [],
                depth: { bids: [], asks: [] },
                core: { radius: BASE_RADIUS, targetRadius: BASE_RADIUS, shake: { x: 0, y: 0 }, price: 0, prevPrice: 0, y: 0, anchorPrice: 0, trail: [] },
                vwap: { cumPV: 0, cumVol: 0, current: 0, y: 0 },
                width: 0, height: 0
            });

            const initAudio = () => {
                if (audioCtxRef.current) return;
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                audioCtxRef.current = ctx;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = 50; 
                gain.gain.value = 0.05; 
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                droneOscRef.current = osc;
                droneGainRef.current = gain;
                setAudioEnabled(true);
            };

            const toggleAudio = () => {
                if (!audioCtxRef.current) initAudio();
                else if (audioCtxRef.current.state === 'suspended') { audioCtxRef.current.resume(); setAudioEnabled(true); }
                else { audioCtxRef.current.suspend(); setAudioEnabled(false); }
            };

            const playSound = (type) => {
                if (!audioCtxRef.current || audioCtxRef.current.state !== 'running') return;
                const ctx = audioCtxRef.current;
                const t = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);

                if (type === 'whale') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(60, t);
                    osc.frequency.exponentialRampToValueAtTime(30, t + 1.5);
                    gain.gain.setValueAtTime(0.5, t); 
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
                    osc.start(t); osc.stop(t + 1.5);
                } else if (type === 'buy') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(800 + Math.random() * 400, t);
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                    osc.start(t); osc.stop(t + 0.1);
                } else if (type === 'sell') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150 + Math.random() * 50, t);
                    gain.gain.setValueAtTime(0.08, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                    osc.start(t); osc.stop(t + 0.1);
                }
            };

            useEffect(() => {
                const connect = () => {
                    wsRef.current = new WebSocket(WS_URL);
                    wsRef.current.onopen = () => setIsConnected(true);
                    wsRef.current.onclose = () => { setIsConnected(false); setTimeout(connect, 3000); };
                    wsRef.current.onmessage = (event) => {
                        const message = JSON.parse(event.data);
                        if (message.stream.includes('aggTrade')) handleTradeData(message.data);
                        else if (message.stream.includes('depth20')) handleDepthData(message.data);
                    };
                };
                connect();
                return () => wsRef.current?.close();
            }, []);

            const handleDepthData = (data) => {
                systemRef.current.depth = { bids: data.bids.slice(0, 15), asks: data.asks.slice(0, 15) };
            };

            const handleTradeData = (data) => {
                const currentPrice = parseFloat(data.p);
                const quantity = parseFloat(data.q);
                const isSell = data.m; 
                setPrice(currentPrice);
                const system = systemRef.current;
                if (system.core.anchorPrice === 0) {
                    system.core.anchorPrice = currentPrice;
                    system.vwap.current = currentPrice;
                    system.vwap.cumPV = currentPrice * quantity;
                    system.vwap.cumVol = quantity;
                } else {
                    system.vwap.cumPV += currentPrice * quantity;
                    system.vwap.cumVol += quantity;
                    system.vwap.current = system.vwap.cumPV / system.vwap.cumVol;
                }
                setVwapDisplay(system.vwap.current);
                system.core.prevPrice = system.core.price || currentPrice;
                system.core.price = currentPrice;
                const isWhale = quantity >= WHALE_THRESHOLD;
                const isDust = quantity < DUST_THRESHOLD;

                if (isWhale) playSound('whale'); else if (!isDust) playSound(isSell ? 'sell' : 'buy');
                if (droneOscRef.current && audioCtxRef.current?.state === 'running') {
                    droneOscRef.current.frequency.setTargetAtTime(50 + (system.core.radius - BASE_RADIUS), audioCtxRef.current.currentTime, 0.5);
                }

                if (isWhale) {
                    system.core.targetRadius = BASE_RADIUS + Math.min(quantity * 40, 100);
                    system.shockwaves.push({ x: system.width / 2, y: system.core.y, radius: 10, maxRadius: Math.max(system.width, system.height) * 0.8, force: quantity * 5, life: 1.0, color: isSell ? '239, 68, 68' : '34, 197, 94' });
                    system.core.shake = { x: (Math.random() - 0.5) * 20, y: (Math.random() - 0.5) * 20 };
                } else system.core.targetRadius = BASE_RADIUS + Math.min(quantity * 20, 40);

                const baseAngle = isSell ? Math.PI / 2 : -Math.PI / 2;
                const angle = baseAngle + (Math.random() - 0.5) * (Math.PI / 2);
                system.particles.push({
                    x: system.width / 2, y: system.core.y,
                    vx: Math.cos(angle) * (isWhale ? 3 : (isDust ? 10 : 5)),
                    vy: Math.sin(angle) * (isWhale ? 3 : (isDust ? 10 : 5)),
                    size: isWhale ? 20 : (isDust ? 1 : Math.max(2, quantity * 5)),
                    alpha: isWhale ? 1 : (isDust ? 0.3 : 0.8), 
                    color: isSell ? '#ef4444' : '#22c55e',
                    type: isSell ? 'sell' : 'buy',
                    isWhale, isDust, hasHit: false
                });
                if (system.particles.length > MAX_PARTICLES) system.particles.shift();
                setStats(prev => ({ ...prev, vol: prev.vol + quantity, trades: prev.trades + 1, whales: isWhale ? prev.whales + 1 : prev.whales }));
            };

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                let animationFrameId;

                const resize = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    systemRef.current.width = canvas.width;
                    systemRef.current.height = canvas.height;
                    systemRef.current.core.y = canvas.height / 2;
                };
                window.addEventListener('resize', resize);
                resize();

                const render = () => {
                    const system = systemRef.current;
                    const { width, height } = canvas;
                    if (system.core.anchorPrice === 0) system.core.anchorPrice = system.core.price;
                    const SCALE = 10;
                    const targetCoreY = (height / 2) - ((system.core.price - system.core.anchorPrice) * SCALE);
                    const targetVwapY = (height / 2) - ((system.vwap.current - system.core.anchorPrice) * SCALE);
                    system.core.y += (targetCoreY - system.core.y) * 0.1;
                    system.vwap.y += (targetVwapY - system.vwap.y) * 0.1;
                    system.core.anchorPrice += (system.core.price - system.core.anchorPrice) * 0.005;

                    const coreX = (width / 2) + (system.core.shake.x *= 0.8);
                    const coreY = system.core.y + (system.core.shake.y *= 0.8);
                    ctx.fillStyle = 'rgba(17, 24, 39, 0.25)';
                    ctx.fillRect(0, 0, width, height);

                    if (networkEnabled) {
                        ctx.beginPath();
                        for (let i = 0; i < system.particles.length; i++) {
                            for (let j = i + 1; j < system.particles.length; j++) {
                                const p1 = system.particles[i], p2 = system.particles[j];
                                if (p1.hasHit || p2.hasHit) continue;
                                const dist = Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
                                if (dist < NETWORK_DISTANCE) {
                                    ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                                    ctx.strokeStyle = p1.type === p2.type ? `rgba(${p1.type === 'buy' ? '34, 197, 94' : '239, 68, 68'}, ${(1 - dist/NETWORK_DISTANCE) * 0.3})` : `rgba(100, 200, 255, 0.1)`;
                                }
                            }
                        }
                        ctx.lineWidth = 1; ctx.stroke();
                    }

                    const distVwap = Math.abs(coreY - system.vwap.y);
                    const tension = Math.min(distVwap / (height/3), 1);
                    if (distVwap > 5) {
                        ctx.beginPath(); ctx.moveTo(coreX, coreY);
                        ctx.quadraticCurveTo(width/2 + (Math.random()-0.5)*(tension*20), (coreY+system.vwap.y)/2, width/2, system.vwap.y);
                        ctx.strokeStyle = `rgba(${Math.floor(34 + 205*tension)}, ${Math.floor(197 - 197*tension)}, ${Math.floor(94 - 94*tension)}, ${0.5 + tension*0.5})`;
                        ctx.lineWidth = Math.max(1, 4*(1-tension)); if (tension > 0.8) ctx.setLineDash([5, 5]); else ctx.setLineDash([]);
                        ctx.stroke(); ctx.setLineDash([]);
                    }

                    const minRingRadius = system.core.radius + 20;
                    const ringStep = (Math.min(width,height)/2*0.8 - minRingRadius) / 10;
                    const drawRings = (orders, isAsks, color) => {
                        orders.forEach((order, index) => {
                            const radius = minRingRadius + (index * ringStep);
                            ctx.beginPath(); ctx.arc(coreX, coreY, radius, isAsks ? Math.PI+0.2 : 0.2, isAsks ? Math.PI*2-0.2 : Math.PI-0.2);
                            ctx.strokeStyle = `rgba(${color}, ${0.6 - index*0.04})`;
                            ctx.lineWidth = Math.min(parseFloat(order[1])*2, 8) + 1; ctx.stroke();
                        });
                    };
                    drawRings(system.depth.asks, true, '239, 68, 68');
                    drawRings(system.depth.bids, false, '34, 197, 94');

                    for (let i = system.particles.length - 1; i >= 0; i--) {
                        const p = system.particles[i]; p.x += p.vx; p.y += p.vy;
                        const dist = Math.sqrt((p.x-coreX)**2 + (p.y-coreY)**2);
                        if (!p.hasHit && dist > minRingRadius) {
                            p.hasHit = true; p.alpha = 0;
                            system.impacts.push({ angle: Math.atan2(p.y-coreY, p.x-coreX), radius: minRingRadius, life: 1.0, type: p.type });
                            setStats(s => ({ ...s, erosion: s.erosion + 1 }));
                        }
                        if (dist > width) system.particles.splice(i, 1);
                        else { ctx.globalAlpha = p.alpha; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fillStyle = p.color; ctx.fill(); ctx.globalAlpha = 1; }
                    }

                    system.core.radius += (system.core.targetRadius - system.core.radius) * 0.1;
                    system.core.targetRadius += (BASE_RADIUS - system.core.targetRadius) * 0.05;
                    const grad = ctx.createRadialGradient(coreX, coreY, system.core.radius*0.2, coreX, coreY, system.core.radius*2);
                    grad.addColorStop(0, `rgba(${system.core.price > system.core.prevPrice ? '34, 197, 94' : '239, 68, 68'}, 0.9)`);
                    grad.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.beginPath(); ctx.arc(coreX, coreY, system.core.radius, 0, Math.PI*2); ctx.fillStyle = grad; ctx.fill();

                    ctx.font = 'bold 24px monospace'; ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.fillText(system.core.price.toFixed(2), coreX, coreY);
                    animationFrameId = requestAnimationFrame(render);
                };
                render();
                return () => cancelAnimationFrame(animationFrameId);
            }, [networkEnabled]);

            return (
                <div className="relative w-full h-screen bg-gray-900 overflow-hidden font-mono text-white">
                    <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full block" />
                    <div className="absolute top-0 left-0 w-full h-full pointer-events-none p-6 flex flex-col justify-between">
                        <div className="flex justify-between items-start pointer-events-auto">
                            <div>
                                <h1 className="text-2xl font-bold tracking-tighter flex items-center gap-2">
                                    <i data-lucide="activity" className="text-blue-500"></i> BIO-MIMETIC MARKET v7
                                </h1>
                            </div>
                            <div className="flex items-center gap-4">
                                <button onClick={() => setNetworkEnabled(!networkEnabled)} className={`px-4 py-2 rounded-full border ${networkEnabled ? 'bg-purple-500/20 border-purple-500' : 'bg-gray-800 border-gray-600'}`}>NETWORK</button>
                                <button onClick={toggleAudio} className={`px-4 py-2 rounded-full border ${audioEnabled ? 'bg-blue-500/20 border-blue-500' : 'bg-gray-800 border-gray-600 animate-pulse'}`}>AUDIO</button>
                                <div className={`px-3 py-1 rounded-full border ${isConnected ? 'border-green-500 text-green-400' : 'border-red-500 text-red-400'}`}>{isConnected ? 'LIVE' : 'OFF'}</div>
                            </div>
                        </div>
                        <div className="pointer-events-auto w-full max-w-xs space-y-4">
                            <div className="bg-gray-800/60 backdrop-blur-md border border-gray-700 p-4 rounded-xl">
                                <div className="space-y-3">
                                    <div className="flex justify-between border-b border-gray-700 pb-2"><span>Wall Impacts</span><span className="text-orange-500">{stats.erosion}</span></div>
                                    <div className="flex justify-between border-b border-gray-700 pb-2"><span>Whales</span><span className="text-yellow-400">{stats.whales}</span></div>
                                    <div className="flex justify-between"><span>VWAP</span><span className="text-teal-400">{vwapDisplay.toFixed(2)}</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        setTimeout(() => lucide.createIcons(), 500);
    </script>
</body>
</html>
