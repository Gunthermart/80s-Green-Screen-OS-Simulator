<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aquarium R√©tro 3D - Simulation de Vie Artificielle</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Explorez un aquarium 3D interactif de style terminal r√©tro des ann√©es 80. Observez des bancs de poissons color√©s, g√©rez l'√©cosyst√®me et introduisez des pr√©dateurs dans cette simulation de vie artificielle.">
    <meta name="keywords" content="simulation 3d, aquarium, boids, vie artificielle, three.js, webgl, retro, terminal, poisson, pr√©dateur, cichla, erpetoichthys, sous-marin, interactif">
    <meta name="author" content="Simulation Interactive">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://leonce-equity.com/aquarium/">
    <meta property="og:title" content="Aquarium R√©tro 3D - Simulation de Vie Artificielle">
    <meta property="og:description" content="Plongez dans un √©cosyst√®me num√©rique et contr√¥lez la vie de poissons virtuels dans un style wireframe unique.">
    <meta property="og:image" content="https://leonce-equity.com/aquarium/aquarium.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://leonce-equity.com/aquarium/">
    <meta property="twitter:title" content="Aquarium R√©tro 3D - Simulation de Vie Artificielle">
    <meta property="twitter:description" content="Plongez dans un √©cosyst√®me num√©rique et contr√¥lez la vie de poissons virtuels dans un style wireframe unique.">
    <meta property="twitter:image" content="https://leonce-equity.com/aquarium/aquarium.png">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(0, 40, 60, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(0, 60, 40, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at center, #0a0a0a 0%, #000000 100%);
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            text-align: center;
            position: relative;
        }
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1000 1000"><defs><filter id="noise"><feTurbulence type="turbulence" baseFrequency="0.9" numOctaves="1" seed="2"/><feColorMatrix values="0 0 0 0 0 0 0 0 0 0.2 0 0 0 0 0 0 0 0 0.03 0"/></filter></defs><rect width="100%" height="100%" filter="url(%23noise)"/></svg>');
            opacity: 0.6;
            pointer-events: none;
            z-index: -1;
        }
        #info {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 92%;
            padding: 20px;
            box-sizing: border-box;
            z-index: 100;
            display: block;
            text-shadow: 
                0 0 8px #00ff41, 
                0 0 16px #00ff41, 
                0 0 24px rgba(0, 255, 65, 0.6);
            pointer-events: none;
            background: linear-gradient(135deg, rgba(0, 20, 15, 0.85) 0%, rgba(0, 10, 8, 0.85) 100%);
            border: 2px solid rgba(0, 255, 65, 0.6);
            border-radius: 8px;
            backdrop-filter: blur(10px);
            box-shadow: 
                0 0 30px rgba(0, 255, 65, 0.3),
                inset 0 1px 0 rgba(0, 255, 65, 0.1);
        }
        canvas {
            display: block;
        }
        #exit-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 104;
            cursor: pointer;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff41;
            color: #00ff41;
        }
        #exit-btn:hover {
            color: #ff4141;
        }
        #main-controls-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 101;
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 200px;
            background: rgba(0, 15, 8, 0.85);
            border: 1px solid #00ff41;
            border-radius: 4px;
            padding: 8px;
            backdrop-filter: blur(5px);
        }
        .control-group-header {
            background: rgba(0, 255, 65, 0.1);
            color: #00ff41;
            padding: 8px 10px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 2px;
            transition: background 0.3s;
        }
        .control-group-header:hover {
            background: rgba(0, 255, 65, 0.2);
        }
        .control-group-header .caret {
            transition: transform 0.3s ease;
        }
        .control-group.active .control-group-header .caret {
            transform: rotate(90deg);
        }
        .control-group-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out;
            padding-left: 10px;
        }
        .settings-btn {
            cursor: pointer;
            background: rgba(0, 20, 0, 0.7);
            border: 1px solid #00ff41;
            color: #00ff41;
            padding: 8px 10px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            text-shadow: 0 0 5px #00ff41;
            transition: all 0.3s ease;
            width: 100%;
            text-align: left;
            border-radius: 2px;
            box-shadow: 0 0 0 rgba(0, 255, 65, 0);
            margin-top: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative; /* For tooltip */
        }
        .settings-btn:hover {
            background: rgba(0, 255, 65, 0.15);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.6);
            transform: translateY(-1px);
        }
        .btn-icon {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        /* Tooltip */
        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 105%;
            top: 50%;
            transform: translateY(-50%);
            background: #000;
            color: #00ff41;
            border: 1px solid #00ff41;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            white-space: nowrap;
            z-index: 1000;
        }
        .settings-btn:disabled {
            cursor: not-allowed;
            background: rgba(50, 50, 50, 0.5);
            color: #555;
            text-shadow: none;
            border-color: #555;
        }
        #feed-btn {
            border-color: #ffff00;
            color: #ffff00;
            text-shadow: 0 0 8px #ffff00;
        }
        .settings-panel {
            position: absolute;
            width: 380px;
            background: linear-gradient(145deg, rgba(0, 20, 0, 0.95), rgba(0, 10, 0, 0.95));
            border: 2px solid #00ff41;
            box-shadow: 0 0 25px rgba(0, 255, 65, 0.4), inset 0 0 20px rgba(0, 255, 65, 0.05);
            z-index: 102;
            border-radius: 4px;
            backdrop-filter: blur(10px);
        }
        .settings-panel.hidden {
            display: none;
        }
        .panel-header {
            color: #00ff41;
            padding: 8px 10px;
            cursor: move;
            font-weight: bold;
            border-bottom: 1px solid #00ff41;
            text-shadow: 0 0 5px #00ff41;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-header .close-btn {
            cursor: pointer;
            font-weight: bold;
        }
        .panel-header .close-btn:hover {
            color: #ff4141;
        }
        .panel-content {
            padding: 15px;
            max-height: 60vh;
            overflow-y: auto;
        }
        .panel-content fieldset {
            border: 1px dashed #00ff41;
            padding: 10px;
            margin: 0;
            margin-bottom: 10px;
        }
        .panel-content fieldset:disabled {
            opacity: 0.5;
            border-color: #555;
        }
        .panel-content label {
            display: block;
            margin-bottom: 5px;
            margin-top: 10px;
        }
        #stats-panel-content p {
            margin: 4px 0;
            text-align: left;
        }
        #welcome-lang-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            padding: 8px;
            background: rgba(0, 255, 65, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(0, 255, 65, 0.2);
        }
        .lang-btn {
            flex-grow: 1;
            font-size: 0.85em;
            padding: 8px 12px;
            background: rgba(0, 30, 20, 0.8);
            border: 2px solid #00ff41;
            color: #00ff41;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .lang-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.2), transparent);
            transition: left 0.4s;
        }
        .lang-btn:hover::before {
            left: 100%;
        }
        .lang-btn:hover:not(.active) {
            background: rgba(0, 255, 65, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 65, 0.3);
        }
        .lang-btn.active {
            background: linear-gradient(145deg, #00ff41, #00cc33);
            color: #000;
            text-shadow: none;
            box-shadow: 
                0 0 15px rgba(0, 255, 65, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }
        /* Style de base des curseurs */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: #00ff41;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            border: 1px solid #00ff41;
            height: 16px;
            width: 16px;
            background: #00ff41;
            cursor: pointer;
            margin-top: -7px;
        }
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: #00ff41;
        }
        input[type=range]::-moz-range-thumb {
            border: 1px solid #00ff41;
            height: 16px;
            width: 16px;
            background: #00ff41;
            cursor: pointer;
        }

        /* Responsive Design for Mobile */
        @media (max-width: 768px) {
            #info {
                padding: 10px;
                font-size: 0.9em;
            }
            #info h1 {
                font-size: 1.3em;
                margin: 0 0 8px 0;
            }
            #info p {
                margin: 0 0 5px 0;
            }
            #stats {
                font-size: 0.75em !important;
            }
            #main-controls-container {
                top: auto;
                bottom: 15px;
                left: 15px;
                flex-direction: column;
                width: calc(100vw - 30px);
                max-width: 300px;
                gap: 5px;
            }
            .settings-btn {
                font-size: 0.8em;
                padding: 8px 10px;
            }
            .settings-panel {
                width: 95vw;
                max-width: 400px;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%);
                max-height: 80vh;
                overflow-y: auto;
            }
            .panel-content {
                padding: 10px;
            }
            .panel-content label {
                font-size: 0.85em;
            }
             .modal-footer {
                flex-direction: column;
                align-items: stretch;
            }
            #welcome-lang-selector {
                order: 1;
            }
            .start-btn {
                order: 2;
            }
            .checkbox-container {
                order: 3;
                justify-content: center;
            }
        }

        /* Accessibility improvements */
        .settings-btn:focus,
        .settings-panel:focus-within {
            outline: 2px solid #00ff41;
            outline-offset: 2px;
        }
        
        input[type=range]:focus {
            outline: 2px solid #00ff41;
            outline-offset: 2px;
        }
        
        /* Am√©lioration du contraste pour l'accessibilit√© */
        .panel-content fieldset legend {
            color: #00ff41;
            font-weight: bold;
        }

        /* Welcome Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(0, 30, 40, 0.98) 0%, rgba(0, 0, 0, 0.98) 100%);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
            animation: overlayFadeIn 1s ease-out;
        }
        .modal-overlay.hidden {
            display: none;
        }
        .modal-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><filter id="turbulence"><feTurbulence type="turbulence" baseFrequency="0.02" numOctaves="3" result="noise"/><feDisplacementMap in="SourceGraphic" in2="noise" scale="2"/></filter></defs><rect width="100" height="100" fill="rgba(0,255,65,0.02)" filter="url(%23turbulence)"/></svg>') repeat;
            opacity: 0.3;
            animation: waterFlow 20s linear infinite;
        }
        @keyframes overlayFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes waterFlow {
            0% { transform: translateX(0) translateY(0); }
            25% { transform: translateX(-20px) translateY(-10px); }
            50% { transform: translateX(-40px) translateY(20px); }
            75% { transform: translateX(-20px) translateY(30px); }
            100% { transform: translateX(0) translateY(0); }
        }
        .modal-content {
            background: linear-gradient(145deg, rgba(0, 25, 15, 0.96), rgba(0, 15, 10, 0.96));
            border: 3px solid #00ff41;
            border-radius: 12px;
            padding: 0;
            max-width: 650px;
            width: 92%;
            max-height: 92vh;
            overflow-y: auto;
            box-shadow: 
                0 0 60px rgba(0, 255, 65, 0.7), 
                inset 0 0 40px rgba(0, 255, 65, 0.12),
                0 20px 40px rgba(0, 0, 0, 0.6);
            animation: modalSlideIn 1s ease-out;
            position: relative;
        }
        .modal-content::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ff41, #00cc33, #00ff41, #00aa22);
            border-radius: 12px;
            z-index: -1;
            animation: borderGlow 3s ease-in-out infinite alternate;
        }
        @keyframes modalSlideIn {
            from { 
                transform: translateY(-80px) scale(0.9); 
                opacity: 0; 
                filter: blur(5px);
            }
            to { 
                transform: translateY(0) scale(1); 
                opacity: 1; 
                filter: blur(0);
            }
        }
        @keyframes borderGlow {
            0% { opacity: 0.6; }
            100% { opacity: 1; }
        }
        .modal-header {
            padding: 25px 30px 20px;
            border-bottom: 2px solid #00ff41;
            position: relative;
            background: linear-gradient(90deg, rgba(0, 255, 65, 0.08) 0%, rgba(0, 255, 65, 0.03) 100%);
        }
        .modal-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, #00ff41, transparent);
            animation: scanLine 2s ease-in-out infinite;
        }
        @keyframes scanLine {
            0%, 100% { opacity: 0.3; transform: translateX(-100%); }
            50% { opacity: 1; transform: translateX(100%); }
        }
        .modal-header h2 {
            color: #00ff41;
            margin: 0;
            font-size: 1.6em;
            text-shadow: 
                0 0 10px #00ff41,
                0 0 20px #00ff41,
                0 0 30px rgba(0, 255, 65, 0.5);
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            letter-spacing: 2px;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        @keyframes titleGlow {
            0% { text-shadow: 0 0 10px #00ff41, 0 0 20px #00ff41, 0 0 30px rgba(0, 255, 65, 0.5); }
            100% { text-shadow: 0 0 15px #00ff41, 0 0 25px #00ff41, 0 0 35px rgba(0, 255, 65, 0.8); }
        }
        .typing-indicator {
            color: #00ff41;
            animation: blink 1.2s infinite;
            font-size: 1.4em;
            position: absolute;
            right: 30px;
            top: 28px;
            text-shadow: 0 0 8px #00ff41;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        .modal-body {
            padding: 25px 30px;
            position: relative;
        }
        .modal-body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><circle cx="50" cy="50" r="2" fill="rgba(0,255,65,0.1)"><animate attributeName="cy" values="50;150;50" dur="8s" repeatCount="indefinite"/></circle><circle cx="150" cy="100" r="1.5" fill="rgba(0,255,65,0.08)"><animate attributeName="cy" values="100;50;100" dur="6s" repeatCount="indefinite"/></circle><circle cx="100" cy="150" r="1" fill="rgba(0,255,65,0.06)"><animate attributeName="cy" values="150;25;150" dur="10s" repeatCount="indefinite"/></circle></svg>') repeat;
            opacity: 0.4;
            pointer-events: none;
        }
        .terminal-text {
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.7;
            position: relative;
            z-index: 1;
        }
        .terminal-text p {
            margin: 12px 0;
            animation: typeIn 0.8s ease-out;
            text-shadow: 0 0 5px rgba(0, 255, 65, 0.3);
        }
        .terminal-text p:first-child {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 18px;
        }
        @keyframes typeIn {
            from { 
                opacity: 0; 
                transform: translateX(-15px); 
                filter: blur(2px);
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
                filter: blur(0);
            }
        }
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 18px;
            margin: 25px 0;
            padding: 20px;
            border: 2px dashed #00ff41;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.08) 0%, rgba(0, 255, 65, 0.03) 100%);
            position: relative;
            overflow: hidden;
        }
        .features-grid::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 255, 65, 0.03) 0%, transparent 70%);
            animation: rotateGlow 10s linear infinite;
        }
        @keyframes rotateGlow {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .feature-item {
            display: flex;
            align-items: center;
            gap: 12px;
            animation: fadeInUp 0.8s ease-out;
            position: relative;
            z-index: 1;
            padding: 8px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        .feature-item:hover {
            background: rgba(0, 255, 65, 0.1);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 255, 65, 0.2);
        }
        @keyframes fadeInUp {
            from { 
                opacity: 0; 
                transform: translateY(30px); 
                filter: blur(3px);
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
                filter: blur(0);
            }
        }
        .feature-icon {
            font-size: 1.4em;
            filter: hue-rotate(120deg) drop-shadow(0 0 5px rgba(0, 255, 65, 0.6));
            animation: iconFloat 3s ease-in-out infinite;
        }
        @keyframes iconFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        .quick-tips {
            margin-top: 25px;
            padding: 20px;
            border: 2px solid #00ff41;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.1) 0%, rgba(0, 255, 65, 0.05) 100%);
            position: relative;
            overflow: hidden;
        }
        .quick-tips::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        .quick-tips h3 {
            color: #00ff41;
            margin: 0 0 15px 0;
            font-size: 1.2em;
            text-shadow: 
                0 0 8px #00ff41,
                0 0 16px rgba(0, 255, 65, 0.5);
            position: relative;
            z-index: 1;
            font-weight: bold;
        }
        .quick-tips ul {
            margin: 0;
            padding-left: 0;
            list-style: none;
            position: relative;
            z-index: 1;
        }
        .quick-tips li {
            margin: 10px 0;
            animation: slideInLeft 0.6s ease-out;
            padding: 5px 0;
            border-left: 3px solid transparent;
            padding-left: 10px;
            transition: all 0.3s ease;
        }
        .quick-tips li:hover {
            border-left-color: #00ff41;
            padding-left: 15px;
            background: rgba(0, 255, 65, 0.05);
            border-radius: 4px;
        }
        @keyframes slideInLeft {
            from { 
                opacity: 0; 
                transform: translateX(-30px); 
                filter: blur(2px);
            }
            to { 
                opacity: 1; 
                transform: translateX(0); 
                filter: blur(0);
            }
        }
        .modal-footer {
            padding: 20px 30px 25px;
            border-top: 2px solid #00ff41;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 18px;
            background: linear-gradient(90deg, rgba(0, 255, 65, 0.05) 0%, rgba(0, 255, 65, 0.02) 100%);
            position: relative;
        }
        .modal-footer::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, #00ff41, rgba(0, 255, 65, 0.3), #00ff41);
        }
        .start-btn {
            background: linear-gradient(145deg, #00ff41, #00cc33);
            border: 2px solid #00ff41;
            color: #000;
            padding: 15px 30px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.4s ease;
            text-shadow: none;
            box-shadow: 
                0 0 20px rgba(0, 255, 65, 0.6),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        .start-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s;
        }
        .start-btn:hover::before {
            left: 100%;
        }
        .start-btn:hover {
            background: linear-gradient(145deg, #00cc33, #009925);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 8px 25px rgba(0, 255, 65, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border-color: #00cc33;
        }
        .start-btn:active {
            transform: translateY(-1px) scale(1);
            box-shadow: 0 3px 12px rgba(0, 255, 65, 0.6);
        }
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #00ff41;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 8px;
            border-radius: 4px;
        }
        .checkbox-container:hover {
            background: rgba(0, 255, 65, 0.05);
            text-shadow: 0 0 8px rgba(0, 255, 65, 0.6);
        }
        .checkbox-container input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #00ff41;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .checkbox-container input[type="checkbox"]:hover {
            transform: scale(1.1);
            filter: drop-shadow(0 0 5px rgba(0, 255, 65, 0.8));
        }
        
        /* Scrollbar Styles */
        .panel-content::-webkit-scrollbar {
            width: 8px;
        }
        .panel-content::-webkit-scrollbar-track {
            background: rgba(10, 10, 10, 0.8);
            border-radius: 10px;
        }
        .panel-content::-webkit-scrollbar-thumb {
            background-color: #ffff00;
            border-radius: 10px;
            border: 1px solid #00ff41;
        }
        .panel-content::-webkit-scrollbar-thumb:hover {
            background-color: #ff0;
        }
        
        #auto-mode-timer {
            color: #ff69b4;
            text-shadow: 0 0 8px #ff69b4, 0 0 16px #ff69b4;
        }

        #exjv-modal .modal-content {
            width: 500px;
            height: 200px;
            padding: 0;
            overflow: hidden;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.5), inset 0 0 20px rgba(0, 255, 65, 0.3);
        }
        #exjv-modal .modal-content::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }
        #exjv-modal .modal-content::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(transparent 0%, rgba(0, 255, 65, 0.1) 50%, transparent 100%);
            opacity: .1;
            z-index: 2;
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker {
            0% { opacity: 0.1; }
            20% { opacity: 1; }
            40% { opacity: 0.1; }
            60% { opacity: 1; }
            80% { opacity: 0.1; }
            100% { opacity: 1; }
        }
        #chase-canvas {
            width: 100%;
            height: calc(100% - 38px);
            display: block;
        }
    </style>
</head>
<body>
    <!-- Welcome Modal -->
    <div id="welcome-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 data-lang-key="welcome_title">BIENVENUE DANS AQUARIUM_TERMINAL.EXE</h2>
                <div class="typing-indicator">_</div>
            </div>
            <div class="modal-body">
                <div class="terminal-text">
                    <p data-lang-key="welcome_intro">>>> INITIALISATION DE LA SIMULATION DE VIE ARTIFICIELLE...</p>
                    <p data-lang-key="welcome_description">Cette simulation interactive pr√©sente un √©cosyst√®me aquatique 3D dynamique. Observez les poissons na√Ætre, grandir, se reproduire et mourir, tout en g√©rant les param√®tres de leur environnement.</p>
                    
                    <div class="features-grid">
                        <div class="feature-item">
                            <span class="feature-icon">üåø</span>
                            <span data-lang-key="feature_lifecycle">Cycle de vie complet</span>
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">üéØ</span>
                            <span data-lang-key="feature_predation">Syst√®me de pr√©dation</span>
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">‚öôÔ∏è</span>
                            <span data-lang-key="feature_controls">Contr√¥les avanc√©s</span>
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">üåê</span>
                            <span data-lang-key="feature_multilingual">Interface multilingue</span>
                        </div>
                    </div>

                    <div class="quick-tips">
                        <h3 data-lang-key="quick_tips_title">>>> GUIDE RAPIDE:</h3>
                        <ul>
                            <li data-lang-key="tip_explore">‚Ä¢ Faites glisser pour explorer l'aquarium 3D</li>
                            <li data-lang-key="tip_fertility">‚Ä¢ Ajustez la 'F√©condit√©' pour contr√¥ler la population</li>
                            <li data-lang-key="tip_predator">‚Ä¢ Lib√©rez l'Erpetoichthys pour observer le chaos</li>
                            <li data-lang-key="tip_submarine">‚Ä¢ Changez de vue avec la cam√©ra du sous-marin</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <div id="welcome-lang-selector">
                    <button class="lang-btn active" data-lang="en">EN</button>
                    <button class="lang-btn" data-lang="fr">FR</button>
                    <button class="lang-btn" data-lang="es">ES</button>
                    <button class="lang-btn" data-lang="de">DE</button>
                    <button class="lang-btn" data-lang="zh">ZH</button>
                </div>
                <button id="start-simulation-btn" class="start-btn" data-lang-key="start_simulation">D√âMARRER LA SIMULATION</button>
                <label class="checkbox-container">
                    <input type="checkbox" id="dont-show-again">
                    <span data-lang-key="dont_show_again">Ne plus afficher</span>
                </label>
            </div>
        </div>
    </div>

    <div id="info">
        <h1 data-lang-key="title">AQUARIUM_TERMINAL.EXE</h1>
        <p data-lang-key="subtitle">üê† Simulation de vie artificielle ‚Ä¢ Glissez pour explorer ‚Ä¢ Cliquez sur les esp√®ces pour configurer</p>
        <div id="stats" style="font-size: 0.9em; margin-top: 8px; opacity: 0.8;">
            <span id="fish-count-label" data-lang-key="fish_count_label">Poissons</span>: <span id="fish-count">0</span> | 
            <span id="predator-count-label" data-lang-key="predator_count_label">Pr√©dateurs</span>: <span id="predator-count">0</span> | 
            <span id="ropefish-status-label" data-lang-key="ropefish_status_label">Erpetoichthys</span>: <span id="ropefish-status" data-lang-key="inactive">INACTIF</span> |
            <span id="auto-mode-status" style="display: none;">Mode Auto: <span id="auto-mode-status-value">INACTIF</span> | </span>
            <span id="auto-mode-timer" style="display: none;"></span>
            <span id="fps">FPS: 60</span>
        </div>
    </div>

    <div id="exit-btn" title="Retourner au r√©pertoire parent">[X]</div>
    <div id="main-controls-container"></div>
    <div id="settings-container"></div>
    
    <div id="exjv-modal" class="modal-overlay hidden">
        <div class="modal-content">
             <div class="panel-header">
                <span>(C) EXJV</span>
                <span class="close-btn">[X]</span>
            </div>
            <canvas id="chase-canvas"></canvas>
        </div>
    </div>

    <script type="module">
        // Importation des modules n√©cessaires de Three.js
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls, superPredator, submarine, isSubmarineViewActive = false, isWireframeMode = true;
        let boids = [];
        let eggs = [];
        let food = [];
        const rocks = [];
        const plants = [];
        let particles = [];
        const worldSize = { width: 500, height: 250, depth: 350 };
        let aquariumBox;
        let lastFrameTime = 0;
        let highestZIndex = 102; // For panel management
        let lastHiddenTime = 0; // For background simulation
        let isAutoModeActive = false;
        let autoModeManager;
        let isImmortalMode = false;
        let chaseAnimationId;

        // --- Statistics ---
        const simulationStats = {
            preyEaten: 0,
            eggsLaid: {},
            babiesHatched: {},
            maxGeneration: {}
        };

        // --- Global Behavior Parameters ---
        const flockingForces = {
            alignment: 0.4,
            cohesion: 0.3,
            separation: 1.2
        };
        
        const environmentSettings = {
            rockCount: 15,
            plantCount: 60
        };

        // --- Fish Species Configuration ---
        const fishSpecies = {
            'cichla': {
                type: 'predator',
                count: 2, color: 0xff4444, scale: 1.4, maxSpeed: 0.7, perceptionRadius: 120,
                riskAssessment: { maxDistance: 150, maxGroupSize: 5 },
                vertices: new Float32Array([0,0,0, -18,0,0, -5,4,0, -5,-4,0, -18,0,0, -25,2,0, -25,-2,0])
            },
            'tetra': {
                type: 'prey',
                count: 50, color: 0xff69b4, scale: 0.45, maxSpeed: 0.4, perceptionRadius: 35, fearRadius: 80, fertility: 0.03,
                vertices: new Float32Array([0,0,0, -6,2.5,0, -12,0,0, 0,0,0, -12,0,0, -6,-2.5,0, -12,0,0, -16,4,0, -16,-4,0])
            },
            'guppy': {
                type: 'prey',
                count: 65, color: 0x00ddff, scale: 0.4, maxSpeed: 0.45, perceptionRadius: 40, fearRadius: 85, fertility: 0.03,
                vertices: new Float32Array([0,0,0, -5,2,0, -10,0,0, 0,0,0, -10,0,0, -5,-2,0, -10,0,0, -14,5,0, -14,-5,0])
            },
            'puffer': {
                type: 'prey',
                count: 30, color: 0xffaa00, scale: 0.5, maxSpeed: 0.3, perceptionRadius: 30, fearRadius: 70, fertility: 0.015,
                vertices: new Float32Array([3,0,0, 0,3,0, -6,0,0, 3,0,0, -6,0,0, 0,-3,0, -6,0,0, -9,0,0, -4,3,0, -6,0,0, -4,-3,0])
            },
            'angel': {
                type: 'prey',
                count: 25, color: 0xaa44ff, scale: 0.6, maxSpeed: 0.35, perceptionRadius: 35, fearRadius: 75, fertility: 0.024,
                vertices: new Float32Array([0,0,0, -5,5,0, -10,0,0, 0,0,0, -10,0,0, -5,-5,0, -10,0,0, -13,3,0, -10,0,0, -13,-3,0])
            }
        };
        
        // --- Internationalization ---
        const translations = {
            fr: {
                title: "AQUARIUM_TERMINAL.EXE",
                subtitle: "üê† Simulation de vie artificielle ‚Ä¢ Glissez pour explorer ‚Ä¢ Cliquez sur les esp√®ces pour configurer",
                fish_count_label: "Poissons",
                predator_count_label: "Pr√©dateurs",
                ropefish_status_label: "Erpetoichthys",
                active: "ACTIF",
                inactive: "INACTIF",
                auto_mode: "MODE AUTOMATIQUE",
                random_mode: "MODE AL√âATOIRE",
                immortal_mode: "MODE IMMORTEL",
                exjv_credit: "(C) EXJV",
                mode_wireframe: "MODE: WIREFRAME",
                mode_solid: "MODE: PLEIN",
                view_sub: "VUE SOUS-MARIN",
                view_orbital: "VUE ORBITALE",
                release_ropefish: "LIB√âRER L'ERPETOICHTHYS",
                forces: "FORCES",
                environment: "ENVIRONNEMENT",
                statistics: "STATISTIQUES",
                help_title: "AIDE",
                help_content: `
                    <div style="text-align: left; line-height: 1.6; font-size: 0.9em;">
                        <h4 style="text-align: center; text-decoration: underline;">Aquarium R√©tro 3D - Guide de Simulation</h4>
                        <p>Plongez dans un monde aquatique fascinant avec "Aquarium R√©tro 3D", une simulation de vie artificielle dynamique au style "terminal" distinctif des ann√©es 80. Ce programme interactif vous offre une fen√™tre sur un √©cosyst√®me virtuel o√π vous pouvez observer, interagir et m√™me influencer le cycle de vie de diverses esp√®ces aquatiques.</p>
                        
                        <strong style="display: block; margin-top: 15px;">Caract√©ristiques G√©n√©rales :</strong>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>√âcosyst√®me 3D Dynamique :</strong> Explorez un aquarium en trois dimensions, visualis√© avec des graphiques en "wireframe" pour une ambiance r√©tro unique.</li>
                            <li><strong>Simulation de Vie Artificielle :</strong> Observez des poissons virtuels √©voluer selon un cycle de vie complet : ils naissent, grandissent, se reproduisent et meurent.</li>
                            <li><strong>Interface R√©tro Multilingue :</strong> L'interface imite un terminal des ann√©es 80 et supporte plusieurs langues.</li>
                        </ul>

                        <strong style="display: block; margin-top: 15px;">Interactions et Contr√¥les :</strong>
                        
                        <h5 style="margin-top: 10px; text-decoration: underline;">Exploration de l'Aquarium :</h5>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>Glisser la Souris :</strong> Faites pivoter la cam√©ra pour explorer l'aquarium.</li>
                            <li><strong>Molette de la Souris :</strong> Zoomez et d√©zoomez.</li>
                            <li><strong>Vue Sous-Marin :</strong> Activez cette vue pour une perspective immersive.</li>
                        </ul>
                        
                        <h5 style="margin-top: 10px; text-decoration: underline;">Utilisation sur Mobile et Tablette :</h5>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>Rotation :</strong> Glissez avec un doigt sur l'√©cran.</li>
                            <li><strong>Zoom :</strong> Pincez avec deux doigts pour zoomer ou d√©zoomer.</li>
                            <li><strong>Interface :</strong> Les contr√¥les sont adapt√©s pour une utilisation tactile.</li>
                        </ul>

                        <h5 style="margin-top: 10px; text-decoration: underline;">Gestion des Esp√®ces :</h5>
                        <p>Cliquez sur le nom d'une esp√®ce pour ajuster ses param√®tres comme le <strong>Nombre</strong>, la <strong>Taille</strong>, la <strong>Vitesse</strong>, la <strong>Perception</strong>, la <strong>Peur</strong> et la <strong>F√©condit√©</strong>.</p>

                        <h5 style="margin-top: 10px; text-decoration: underline;">Param√®tres Globaux :</h5>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>Panneau "FORCES" :</strong> Contr√¥lez l'<strong>Alignement</strong>, la <strong>Coh√©sion</strong>, et la <strong>S√©paration</strong> des bancs de poissons.</li>
                            <li><strong>Panneau "ENVIRONNEMENT" :</strong> Personnalisez le d√©cor en ajustant le nombre de <strong>Rochers</strong> et de <strong>Plantes</strong>.</li>
                        </ul>

                        <h5 style="margin-top: 10px; text-decoration: underline;">Actions Directes :</h5>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>NOURRIR :</strong> Stimule la reproduction des proies.</li>
                            <li><strong>LIB√âRER L'ERPETOICHTHYS :</strong> Introduit un super-pr√©dateur.</li>
                            <li><strong>MODE :</strong> Basculez entre l'affichage "wireframe" et "plein".</li>
                        </ul>

                        <h5 style="margin-top: 10px; text-decoration: underline;">Suivi et Gestion :</h5>
                        <ul style="margin-top: 5px; padding-left: 20px;">
                            <li><strong>STATISTIQUES :</strong> Suivez les donn√©es d√©taill√©es de l'√©cosyst√®me.</li>
                            <li><strong>SAUVEGARDER / R√âINITIALISER :</strong> G√©rez vos configurations.</li>
                        </ul>
                    </div>
                `,
                prey_eaten: "Proies mang√©es",
                eggs_laid: "Oeufs pondus",
                babies_hatched: "B√©b√©s n√©s",
                taux_fecondite: "Taux F√©condit√©",
                count: "Nombre", scale: "Taille", max_speed: "Vitesse Max", perception_radius: "Rayon Perception", fear_radius: "Rayon Fuite", max_hunt_dist: "Distance Chasse Max", max_group_size: "Taille Groupe Max", rock_count: "Nombre Rochers", plant_count: "Nombre Plantes",
                alignment: "Alignement", cohesion: "Coh√©sion", separation: "S√©paration",
                welcome_title: "BIENVENUE DANS AQUARIUM_TERMINAL.EXE",
                welcome_intro: ">>> INITIALISATION DE LA SIMULATION DE VIE ARTIFICIELLE...",
                welcome_description: "Cette simulation interactive pr√©sente un √©cosyst√®me aquatique 3D dynamique. Observez les poissons na√Ætre, grandir, se reproduire et mourir, tout en g√©rant les param√®tres de leur environnement.",
                feature_lifecycle: "Cycle de vie complet",
                feature_predation: "Syst√®me de pr√©dation",
                feature_controls: "Contr√¥les avanc√©s",
                feature_multilingual: "Interface multiling√ºe",
                quick_tips_title: ">>> GUIDE RAPIDE:",
                tip_explore: "‚Ä¢ Faites glisser pour explorer l'aquarium 3D",
                tip_fertility: "‚Ä¢ Ajustez la 'F√©condit√©' pour contr√¥ler la population",
                tip_predator: "‚Ä¢ Lib√©rez l'Erpetoichthys pour observer le chaos",
                tip_submarine: "‚Ä¢ Changez de vue avec la cam√©ra du sous-marin",
                start_simulation: "D√âMARRER LA SIMULATION",
                dont_show_again: "Ne plus afficher",
                save: "SAUVEGARDER",
                reset: "R√âINITIALISER",
                feed: "NOURRIR",
                generation: "G√©n√©ration Max"
            },
            en: {
                title: "AQUARIUM_TERMINAL.EXE",
                subtitle: "üê† Artificial life simulation ‚Ä¢ Drag to explore ‚Ä¢ Click on species to configure",
                fish_count_label: "Fish",
                predator_count_label: "Predators",
                ropefish_status_label: "Ropefish",
                active: "ACTIVE",
                inactive: "INACTIVE",
                auto_mode: "AUTO MODE",
                random_mode: "RANDOM MODE",
                immortal_mode: "IMMORTAL MODE",
                exjv_credit: "(C) EXJV",
                mode_wireframe: "MODE: WIREFRAME",
                mode_solid: "MODE: SOLID",
                view_sub: "SUBMARINE VIEW",
                view_orbital: "ORBITAL VIEW",
                release_ropefish: "RELEASE THE ROPEFISH",
                forces: "FORCES",
                environment: "ENVIRONMENT",
                statistics: "STATISTICS",
                help_title: "HELP",
                help_content: `<p>Welcome to AQUARIUM_TERMINAL.EXE. Use the buttons to adjust parameters. Click on species names to change their behavior, including their fertility rate. Observe the complete life cycle of the fish, from egg to adult. Release the super-predator to observe chaos. Switch views with the submarine camera.</p>`,
                prey_eaten: "Prey Eaten",
                eggs_laid: "Eggs Laid",
                babies_hatched: "Babies Hatched",
                taux_fecondite: "Fertility Rate",
                count: "Count", scale: "Scale", max_speed: "Max Speed", perception_radius: "Perception Radius", fear_radius: "Fear Radius", max_hunt_dist: "Max Hunt Distance", max_group_size: "Max Group Size", rock_count: "Rock Count", plant_count: "Plant Count",
                alignment: "Alignment", cohesion: "Cohesion", separation: "Separation",
                welcome_title: "WELCOME TO AQUARIUM_TERMINAL.EXE",
                welcome_intro: ">>> INITIALIZING ARTIFICIAL LIFE SIMULATION...",
                welcome_description: "This interactive simulation features a dynamic 3D aquatic ecosystem. Watch fish be born, grow, reproduce, and die, while managing their environmental parameters.",
                feature_lifecycle: "Complete life cycle",
                feature_predation: "Predation system",
                feature_controls: "Advanced controls",
                feature_multilingual: "Multilingual interface",
                quick_tips_title: ">>> QUICK GUIDE:",
                tip_explore: "‚Ä¢ Drag to explore the 3D aquarium",
                tip_fertility: "‚Ä¢ Adjust 'Fertility' to control population growth",
                tip_predator: "‚Ä¢ Release the Erpetoichthys to observe chaos",
                tip_submarine: "‚Ä¢ Switch views with submarine camera",
                start_simulation: "START SIMULATION",
                dont_show_again: "Don't show again",
                save: "SAVE",
                reset: "RESET",
                feed: "FEED",
                generation: "Max Generation"
            },
            es: {
                title: "ACUARIO_TERMINAL.EXE",
                subtitle: "üê† Simulaci√≥n de vida artificial ‚Ä¢ Arrastra para explorar ‚Ä¢ Haz clic en las especies para configurar",
                fish_count_label: "Peces",
                predator_count_label: "Depredadores",
                ropefish_status_label: "Pez Cuerda",
                active: "ACTIVO",
                inactive: "INACTIVO",
                auto_mode: "MODO AUTOM√ÅTICO",
                random_mode: "MODO ALEATORIO",
                immortal_mode: "MODO INMORTAL",
                exjv_credit: "(C) EXJV",
                mode_wireframe: "MODO: ALAMBRE",
                mode_solid: "MODO: S√ìLIDO",
                view_sub: "VISTA SUBMARINO",
                view_orbital: "VISTA ORBITAL",
                release_ropefish: "LIBERAR AL PEZ CUERDA",
                forces: "FUERZAS",
                environment: "ENTORNO",
                statistics: "ESTAD√çSTICAS",
                help_title: "AYUDA",
                help_content: `<p>Bienvenido a ACUARIO_TERMINAL.EXE. Usa los botones para ajustar par√°metros. Haz clic en los nombres de las especies para cambiar su comportamiento, incluida su tasa de fertilidad. Observa el ciclo de vida completo de los peces, desde el huevo hasta el adulto. Libera al superdepredador para observar el caos. Cambia de vista con la c√°mara del submarino.</p>`,
                prey_eaten: "Presas comidas",
                eggs_laid: "Huevos puestos",
                babies_hatched: "Beb√©s nacidos",
                taux_fecondite: "Tasa de Fertilidad",
                count: "Cantidad", scale: "Tama√±o", max_speed: "Vel. M√°xima", perception_radius: "Radio de Percepci√≥n", fear_radius: "Radio de Miedo", max_hunt_dist: "Dist. Caza M√°x.", max_group_size: "Tama√±o Grupo M√°x.", rock_count: "N¬∫ de Rocas", plant_count: "N¬∫ de Plantas",
                alignment: "Alineaci√≥n", cohesion: "Cohesi√≥n", separation: "Separaci√≥n",
                welcome_title: "BIENVENIDO A ACUARIO_TERMINAL.EXE",
                welcome_intro: ">>> INICIALIZANDO SIMULACI√ìN DE VIDA ARTIFICIEL...",
                welcome_description: "Esta simulaci√≥n interactiva presenta un ecosistema acu√°tico 3D din√°mico. Observa a los peces nacer, crecer, reproducirse y morir, mientras gestionas los par√°metros de su entorno.",
                feature_lifecycle: "Ciclo de vida completo",
                feature_predation: "Sistema de depredaci√≥n",
                feature_controls: "Controles avanzados",
                feature_multilingual: "Interfaz multiling√ºe",
                quick_tips_title: ">>> GU√çA R√ÅPIDA:",
                tip_explore: "‚Ä¢ Arrastra para explorar el acuario 3D",
                tip_fertility: "‚Ä¢ Ajusta la 'Fertilidad' para controlar la poblaci√≥n",
                tip_predator: "‚Ä¢ Libera al Pez Cuerda para observar el caos",
                tip_submarine: "‚Ä¢ Cambia de vista con la c√°mara del submarino",
                start_simulation: "INICIAR SIMULACI√ìN",
                dont_show_again: "No mostrar de nuevo",
                save: "GUARDAR",
                reset: "REINICIAR",
                feed: "ALIMENTAR",
                generation: "Generaci√≥n M√°x"
            },
            de: {
                title: "AQUARIUM_TERMINAL.EXE",
                subtitle: "üê† Simulation k√ºnstlichen Lebens ‚Ä¢ Ziehen zum Erkunden ‚Ä¢ Auf Arten klicken zum Konfigurieren",
                fish_count_label: "Fische",
                predator_count_label: "Raubtiere",
                ropefish_status_label: "Fl√∂sselaal",
                active: "AKTIV",
                inactive: "INAKTIV",
                auto_mode: "AUTO-MODUS",
                random_mode: "ZUFALLSMODUS",
                immortal_mode: "UNSTERBLICHER MODUS",
                exjv_credit: "(C) EXJV",
                mode_wireframe: "MODUS: DRAHTGITTER",
                mode_solid: "MODUS: VOLL",
                view_sub: "U-BOOT-ANSICHT",
                view_orbital: "ORBITALANSICHT",
                release_ropefish: "FL√ñSSELAAL FREILASSEN",
                forces: "KR√ÑFTE",
                environment: "UMGEBUNG",
                statistics: "STATISTIKEN",
                help_title: "HILFE",
                help_content: `<p>Willkommen bei AQUARIUM_TERMINAL.EXE. Verwenden Sie die Schaltfl√§chen, um Parameter anzupassen. Klicken Sie auf die Artnamen, um ihr Verhalten zu √§ndern, einschlie√ülich ihrer Fruchtbarkeitsrate. Beobachten Sie den gesamten Lebenszyklus der Fische, vom Ei bis zum Erwachsenen. Lassen Sie den Super-Raubfisch frei, um Chaos zu beobachten. Wechseln Sie die Ansicht mit der U-Boot-Kamera.</p>`,
                prey_eaten: "Beute gefressen",
                eggs_laid: "Eier gelegt",
                babies_hatched: "Babys geschl√ºpft",
                taux_fecondite: "Fruchtbarkeitsrate",
                count: "Anzahl", scale: "Gr√∂√üe", max_speed: "Max. Geschw.", perception_radius: "Wahrnehmungsradius", fear_radius: "Fluchtradius", max_hunt_dist: "Max. Jagddistanz", max_group_size: "Max. Gruppengr√∂√üe", rock_count: "Anz. Felsen", plant_count: "Anz. Pflanzen",
                alignment: "Ausrichtung", cohesion: "Zusammenhalt", separation: "Trennung",
                welcome_title: "WILLKOMMEN BEI AQUARIUM_TERMINAL.EXE",
                welcome_intro: ">>> INITIALISIERE SIMULATION K√úNSTLICHEN LEBENS...",
                welcome_description: "Diese interaktive Simulation zeigt ein dynamisches 3D-Wasser√∂kosystem. Beobachten Sie, wie Fische geboren werden, wachsen, sich vermehren und sterben, w√§hrend Sie ihre Umgebungsparameter verwalten.",
                feature_lifecycle: "Vollst√§ndiger Lebenszyklus",
                feature_predation: "Raubtiersystem",
                feature_controls: "Erweiterte Steuerung",
                feature_multilingual: "Mehrsprachige Oberfl√§che",
                quick_tips_title: ">>> KURZANLEITUNG:",
                tip_explore: "‚Ä¢ Ziehen, um das 3D-Aquarium zu erkunden",
                tip_fertility: "‚Ä¢ Passen Sie die 'Fruchtbarkeit' an, um die Population zu steuern",
                tip_predator: "‚Ä¢ Lassen Sie den Fl√∂sselaal frei, um Chaos zu beobachten",
                tip_submarine: "‚Ä¢ Wechseln Sie die Ansicht mit der U-Boot-Kamera",
                start_simulation: "SIMULATION STARTEN",
                dont_show_again: "Nicht erneut anzeigen",
                save: "SPEICHERN",
                reset: "ZUR√úCKSETZEN",
                feed: "F√úTTERN",
                generation: "Max. Generation"
            },
            zh: {
                title: "Ê∞¥ÊóèÈ¶ÜÁªàÁ´Ø.EXE",
                subtitle: "üê† ‰∫∫Â∑•ÁîüÂëΩÊ®°Êãü ‚Ä¢ ÊãñÂä®Êé¢Á¥¢ ‚Ä¢ ÁÇπÂáªÁâ©ÁßçËøõË°åÈÖçÁΩÆ",
                fish_count_label: "È±ºÁ±ª",
                predator_count_label: "ÊçïÈ£üËÄÖ",
                ropefish_status_label: "Â§öÈ≥çÈ±º",
                active: "Ê¥ªÂä®",
                inactive: "‰∏çÊ¥ªÂä®",
                auto_mode: "Ëá™Âä®Ê®°Âºè",
                random_mode: "ÈöèÊú∫Ê®°Âºè",
                immortal_mode: "‰∏çÊúΩÊ®°Âºè",
                exjv_credit: "(C) EXJV",
                mode_wireframe: "Ê®°ÂºèÔºöÁ∫øÊ°Ü",
                mode_solid: "Ê®°ÂºèÔºöÂÆû‰Ωì",
                view_sub: "ÊΩúËâáËßÜËßí",
                view_orbital: "ËΩ®ÈÅìËßÜËßí",
                release_ropefish: "ÈáäÊîæÂ§öÈ≥çÈ±º",
                forces: "Âäõ",
                environment: "ÁéØÂ¢É",
                statistics: "ÁªüËÆ°",
                help_title: "Â∏ÆÂä©",
                help_content: `<p>Ê¨¢ËøéÊù•Âà∞ Ê∞¥ÊóèÈ¶ÜÁªàÁ´Ø.EXE„ÄÇ‰ΩøÁî®ÊåâÈíÆË∞ÉÊï¥ÂèÇÊï∞„ÄÇÁÇπÂáªÁâ©ÁßçÂêçÁß∞‰ª•ÊîπÂèòÂÆÉ‰ª¨ÁöÑË°å‰∏∫ÔºåÂåÖÊã¨ÂÆÉ‰ª¨ÁöÑÁπÅÊÆñÁéá„ÄÇËßÇÂØüÈ±º‰ªéÂçµÂà∞ÊàêÈ±ºÁöÑÂÆåÊï¥ÁîüÂëΩÂë®Êúü„ÄÇÈáäÊîæË∂ÖÁ∫ßÊçïÈ£üËÄÖÊù•ËßÇÂØüÊ∑∑‰π±„ÄÇ‰ΩøÁî®ÊΩúËâáÊëÑÂÉèÂ§¥ÂàáÊç¢ËßÜËßí„ÄÇ</p>`,
                prey_eaten: "Ë¢´ÊçïÈ£ü",
                eggs_laid: "‰∫ßÂçµÊï∞",
                babies_hatched: "Â≠µÂåñÊï∞",
                taux_fecondite: "ÁπÅÊÆñÁéá",
                count: "Êï∞Èáè", scale: "Â§ßÂ∞è", max_speed: "ÊúÄÂ§ßÈÄüÂ∫¶", perception_radius: "ÊÑüÁü•ÂçäÂæÑ", fear_radius: "ÊÅêÊÉßÂçäÂæÑ", max_hunt_dist: "ÊúÄÂ§ßËøΩÊçïË∑ùÁ¶ª", max_group_size: "ÊúÄÂ§ßÁæ§‰ΩìËßÑÊ®°", rock_count: "Â≤©Áü≥Êï∞Èáè", plant_count: "Ê§çÁâ©Êï∞Èáè",
                alignment: "ÈòüÂàó", cohesion: "ËÅöÈõÜ", separation: "ÂàÜÁ¶ª",
                welcome_title: "Ê¨¢ËøéÊù•Âà∞ Ê∞¥ÊóèÈ¶ÜÁªàÁ´Ø.EXE",
                welcome_intro: ">>> Ê≠£Âú®ÂàùÂßãÂåñ‰∫∫Â∑•ÁîüÂëΩÊ®°Êãü...",
                welcome_description: "Ëøô‰∏™‰∫íÂä®Ê®°ÊãüÂ±ïÁ§∫‰∫Ü‰∏Ä‰∏™Âä®ÊÄÅÁöÑ3DÊ∞¥ÁîüÁîüÊÄÅÁ≥ªÁªü„ÄÇËßÇÂØüÈ±ºÁ±ªÁöÑÂá∫Áîü„ÄÅÊàêÈïø„ÄÅÁπÅÊÆñÂíåÊ≠ª‰∫°ÔºåÂêåÊó∂ÁÆ°ÁêÜÂÆÉ‰ª¨ÁöÑÁéØÂ¢ÉÂèÇÊï∞„ÄÇ",
                feature_lifecycle: "ÂÆåÊï¥ÁöÑÁîüÂëΩÂë®Êúü",
                feature_predation: "ÊçïÈ£üÁ≥ªÁªü",
                feature_controls: "È´òÁ∫ßÊéßÂà∂",
                feature_multilingual: "Â§öËØ≠Ë®ÄÁïåÈù¢",
                quick_tips_title: ">>> Âø´ÈÄüÊåáÂçóÔºö",
                tip_explore: "‚Ä¢ ÊãñÂä®Êé¢Á¥¢3DÊ∞¥ÊóèÈ¶Ü",
                tip_fertility: "‚Ä¢ Ë∞ÉÊï¥‚ÄúÁπÅÊÆñÁéá‚Äù‰ª•ÊéßÂà∂ÁßçÁæ§",
                tip_predator: "‚Ä¢ ÈáäÊîæÂ§öÈ≥çÈ±ºËßÇÂØüÊ∑∑‰π±",
                tip_submarine: "‚Ä¢ ‰ΩøÁî®ÊΩúËâáÊëÑÂÉèÂ§¥ÂàáÊç¢ËßÜËßí",
                start_simulation: "ÂºÄÂßãÊ®°Êãü",
                dont_show_again: "‰∏çÂÜçÊòæÁ§∫",
                save: "‰øùÂ≠ò",
                reset: "ÈáçÁΩÆ",
                feed: "ÂñÇÈ£ü",
                generation: "ÊúÄÂ§ß‰ª£Êï∞"
            }
        };

        // Check if modal should be shown
        function shouldShowModal() {
            try {
                return !localStorage.getItem('aquarium-welcome-dismissed');
            } catch (e) {
                console.warn("localStorage is not available. Welcome modal will always show.");
                return true;
            }
        }

        // Modal functionality
        function initModal() {
            const modal = document.getElementById('welcome-modal');
            const startBtn = document.getElementById('start-simulation-btn');
            const dontShowCheckbox = document.getElementById('dont-show-again');
            const welcomeLangSelector = document.getElementById('welcome-lang-selector');

            if (!shouldShowModal()) {
                modal.classList.add('hidden');
                return;
            }

            welcomeLangSelector.addEventListener('click', (e) => {
                if(e.target.tagName === 'BUTTON') {
                    setLanguage(e.target.dataset.lang);
                }
            });

            startBtn.addEventListener('click', () => {
                try {
                    if (dontShowCheckbox.checked) {
                        localStorage.setItem('aquarium-welcome-dismissed', 'true');
                    }
                } catch (e) {
                    console.warn("Could not save preference to localStorage.");
                }
                modal.classList.add('hidden');
            });
        }

        function setLanguage(lang) {
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.getAttribute('data-lang-key');
                if (translations[lang] && translations[lang][key]) {
                    if (key === 'help_content') {
                        el.innerHTML = translations[lang][key];
                    } else {
                        el.textContent = translations[lang][key];
                    }
                }
            });
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.lang === lang);
            });
        }

        // --- Submarine Class ---
        class Submarine {
            constructor() {
                this.mesh = new THREE.Group();
                const material = new THREE.MeshBasicMaterial({ color: 0xcccccc, wireframe: isWireframeMode });

                const body = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 20, 8), material);
                body.rotation.z = Math.PI / 2;
                this.mesh.add(body);

                const cockpit = new THREE.Mesh(new THREE.SphereGeometry(5, 8, 6), material);
                cockpit.position.x = 5;
                this.mesh.add(cockpit);

                const tail = new THREE.Mesh(new THREE.BoxGeometry(1, 8, 8), material);
                tail.position.x = -12;
                this.mesh.add(tail);

                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(8, 0, 0); 
                this.mesh.add(this.camera);

                this.position = new THREE.Vector3(0, worldSize.height / 2 + 20, 0);
                this.velocity = new THREE.Vector3(0.3, 0, 0);
                this.acceleration = new THREE.Vector3();
                this.mesh.position.copy(this.position);

                this.maxSpeed = 0.4;
                this.maxForce = 0.01;
                this.target = this.getNewTarget();
            }

            getNewTarget() {
                return new THREE.Vector3(
                    (Math.random() - 0.5) * (worldSize.width - 40),
                    Math.random() * (worldSize.height - 40) + 20,
                    (Math.random() - 0.5) * (worldSize.depth - 40)
                );
            }

            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.setLength(this.maxSpeed);
                let steer = new THREE.Vector3().subVectors(desired, this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }

            update() {
                if (this.position.distanceTo(this.target) < 50) {
                    this.target = this.getNewTarget();
                }

                const seekForce = this.seek(this.target);
                this.acceleration.add(seekForce);

                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.multiplyScalar(0);

                this.checkBounds(); 

                this.mesh.position.lerp(this.position, 0.1);
                
                const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), this.velocity.clone().normalize());
                this.mesh.quaternion.slerp(targetQuaternion, 0.05);
            }

            checkBounds() {
                const margin = 20;
                if (this.position.x < -worldSize.width/2+margin || this.position.x > worldSize.width/2-margin ||
                    this.position.y < margin || this.position.y > worldSize.height-margin ||
                    this.position.z < -worldSize.depth/2+margin || this.position.z > worldSize.depth/2-margin) {
                    this.target = new THREE.Vector3(0, worldSize.height / 2, 0);
                }
            }
        }

        // --- SuperPredator Class (Erpetoichthys calabaricus) ---
        class Ropefish {
            constructor() {
                this.segmentCount = 30;
                this.segmentSpacing = 3.5;
                this.speed = 0.9;
                this.turnSpeed = 0.04;
                this.attackRadius = 10;
                this.body = new THREE.Group();
                this.segments = [];
                this.path = [];
                this.pathLength = 120;
                this.target = null;
                this.isActive = false;

                const headMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFF00, wireframe: isWireframeMode });
                const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff41, wireframe: isWireframeMode });
                const headGeometry = new THREE.SphereGeometry(4, 6, 4);
                const bodyGeometry = new THREE.SphereGeometry(2.5, 6, 4);

                const head = new THREE.Mesh(headGeometry, headMaterial);
                this.segments.push(head);
                this.body.add(head);

                for (let i = 1; i < this.segmentCount; i++) {
                    const segment = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    this.segments.push(segment);
                    this.body.add(segment);
                }
                
                this.velocity = new THREE.Vector3(Math.random() * 2 - 1, 0, Math.random() * 2 - 1);
                this.velocity.normalize().multiplyScalar(this.speed);
            }

            spawn() {
                if (this.isActive) return;
                this.isActive = true;
                const startPos = new THREE.Vector3((Math.random() - 0.5) * worldSize.width * 0.8, 15, (Math.random() - 0.5) * worldSize.depth * 0.8);
                this.segments.forEach(seg => seg.position.copy(startPos));
                this.path = Array(this.pathLength).fill(startPos);
                scene.add(this.body);
                document.getElementById('ropefish-status').setAttribute('data-lang-key', 'active');
                setLanguage(document.documentElement.lang);
            }

            update(boids) {
                if (!this.isActive) return;
                this.findTarget(boids);
                this.move();
                this.checkBounds();
            }

            findTarget(allBoids) {
                if (this.target && this.target.isEaten) this.target = null;
                if (!this.target || Math.random() < 0.01) {
                    let closestBoid = null;
                    let minDistance = Infinity;
                    const aliveBoids = allBoids.filter(b => !b.isEaten && !b.isPredator);
                    if (aliveBoids.length === 0) {
                        this.target = null;
                        return;
                    }
                    for (const boid of aliveBoids) {
                        const d = this.segments[0].position.distanceTo(boid.position);
                        if (d < minDistance) {
                            minDistance = d;
                            closestBoid = boid;
                        }
                    }
                    this.target = closestBoid;
                }
            }

            move() {
                let desiredVelocity = new THREE.Vector3();
                if (this.target) {
                    desiredVelocity.subVectors(this.target.position, this.segments[0].position);
                } else {
                    desiredVelocity.copy(this.velocity);
                    if (Math.random() < 0.05) {
                        desiredVelocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), (Math.random() - 0.5) * Math.PI / 2);
                    }
                }
                
                desiredVelocity.normalize().multiplyScalar(this.speed);
                this.velocity.lerp(desiredVelocity, this.turnSpeed);

                const newHeadPos = this.segments[0].position.clone().add(this.velocity);
                this.path.unshift(newHeadPos);
                if (this.path.length > this.pathLength) this.path.pop();

                for (let i = 0; i < this.segments.length; i++) {
                    const index = Math.floor(Math.min(i * this.segmentSpacing, this.path.length - 1));
                    const point = this.path[index];
                    if (point) this.segments[i].position.lerp(point, 0.5);
                }

                if (this.target && this.segments[0].position.distanceTo(this.target.position) < this.attackRadius) {
                    if (!isImmortalMode) {
                        createEatEffect(this.target.position, 0xFFFF00);
                        this.target.isEaten = true;
                        simulationStats.preyEaten++;
                    }
                    this.target = null;
                }
            }
            
            checkBounds() {
                const head = this.segments[0];
                const margin = 10;
                if (head.position.x < -worldSize.width/2+margin) { head.position.x = -worldSize.width/2+margin; this.velocity.x *= -1; }
                else if (head.position.x > worldSize.width/2-margin) { head.position.x = worldSize.width/2-margin; this.velocity.x *= -1; }
                if (head.position.y < margin) { head.position.y = margin; this.velocity.y *= -1; }
                else if (head.position.y > worldSize.height-margin) { head.position.y = worldSize.height-margin; this.velocity.y *= -1; }
                if (head.position.z < -worldSize.depth/2+margin) { head.position.z = -worldSize.depth/2+margin; this.velocity.z *= -1; }
                else if (head.position.z > worldSize.depth/2-margin) { head.position.z = worldSize.depth/2-margin; this.velocity.z *= -1; }
            }
        }

        // --- FoodParticle Class ---
        class FoodParticle {
            constructor(position) {
                // Food particle parameters
                this.position = position.clone();
                this.velocity = new THREE.Vector3(0, -0.1, 0); // Sinks slowly
                this.lifetime = 1000 + Math.random() * 500; // ~16-25 seconds before disappearing
                
                // Visual appearance
                const geometry = new THREE.SphereGeometry(1.2, 8, 6);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    wireframe: isWireframeMode, 
                    transparent: true, 
                    opacity: 0.9 
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
                
                // Glow effect
                const glowGeometry = new THREE.SphereGeometry(2, 8, 6);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00, 
                    transparent: true, 
                    opacity: 0.3, 
                    side: THREE.BackSide 
                });
                this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
                this.mesh.add(this.glow);
            }

            update() {
                // Movement and lifetime logic
                this.position.add(this.velocity);
                this.mesh.position.copy(this.position);
                
                // Add a slight oscillating movement for a realistic effect
                this.mesh.position.x += Math.sin(Date.now() * 0.002) * 0.05;
                this.mesh.position.z += Math.cos(Date.now() * 0.002) * 0.05;
                
                // Vertical bounds check
                if (this.position.y < 1) {
                    this.position.y = 1;
                    this.velocity.y = 0; // Stop at the bottom
                }
                
                // Decrease lifetime
                this.lifetime--;
                
                // Opacity fades out towards the end of life
                if (this.lifetime < 100) {
                    const opacity = this.lifetime / 100;
                    this.mesh.material.opacity = opacity * 0.9;
                    this.glow.material.opacity = opacity * 0.3;
                }
                
                return this.lifetime <= 0;
            }
        }

        // --- Egg Class ---
        class Egg {
            constructor(species, position, color, parentGeneration = 1) {
                this.species = species;
                this.parentGeneration = parentGeneration;
                this.hatchTime = 500 + Math.random() * 200; // ~8-12 seconds
                const geometry = new THREE.SphereGeometry(1.5, 6, 4);
                const material = new THREE.MeshBasicMaterial({ color: color, wireframe: isWireframeMode, transparent: true, opacity: 0.8 });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                scene.add(this.mesh);
                simulationStats.eggsLaid[this.species] = (simulationStats.eggsLaid[this.species] || 0) + 1;
            }

            update() {
                this.hatchTime--;
                if (this.hatchTime <= 0) {
                    return this.hatch();
                }
                return null;
            }

            hatch() {
                const baby = new Boid(this.species, true, this.parentGeneration); // Create one baby fish with parent's generation
                baby.position.copy(this.mesh.position);
                simulationStats.babiesHatched[this.species] = (simulationStats.babiesHatched[this.species] || 0) + 1;
                return [baby]; // Return as an array
            }
        }

        // --- Boid Class ---
        class Boid {
            constructor(species, isBaby = false, parentGeneration = 0) {
                this.species = species;
                const config = fishSpecies[species];
                this.isPredator = config.type === 'predator';
                this.maxSpeed = config.maxSpeed;
                this.maxForce = 0.05;
                this.perceptionRadius = config.perceptionRadius;
                this.fearRadius = config.fearRadius || 0;
                this.baseFertility = config.fertility || 0;
                this.fertility = this.baseFertility;
                this.fertilityBoostTimer = 0;
                
                // Generation system
                this.generation = isBaby ? parentGeneration + 1 : 1;
                if (this.generation > (simulationStats.maxGeneration[species] || 0)) {
                    simulationStats.maxGeneration[species] = this.generation;
                }
                
                this.satiation = 0;
                if (this.isPredator) this.satiation = 300;
                this.isEaten = false;

                // Life Cycle properties
                this.adultAge = 800; // ~13 seconds
                this.maxAge = 6000; // ~100 seconds
                this.age = isBaby ? 0 : Math.random() * this.maxAge;
                this.isAdult = this.age >= this.adultAge;
                this.wantsToMate = false;
                this.matingCooldown = Math.random() * 500;
                this.isMating = false;
                this.matingPartner = null;
                this.matingTimer = 0;

                const material = new THREE.MeshBasicMaterial({ color: config.color, wireframe: isWireframeMode, side: THREE.DoubleSide });
                this.mesh = new THREE.Mesh(new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(config.vertices, 3)), material);
                
                const initialScale = isBaby ? config.scale * 0.3 : config.scale;
                this.mesh.scale.set(initialScale, initialScale, initialScale);
                
                if (this.isPredator) {
                    const glowGeometry = new THREE.SphereGeometry(8, 8, 6);
                    const glowMaterial = new THREE.MeshBasicMaterial({ color: config.color, transparent: true, opacity: 0.1, side: THREE.BackSide });
                    this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.mesh.add(this.glow);
                }
                
                this.position = new THREE.Vector3(Math.random()*worldSize.width-worldSize.width/2, Math.random()*(worldSize.height-10)+5, Math.random()*worldSize.depth-worldSize.depth/2);
                this.velocity = new THREE.Vector3(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1);
                this.velocity.setLength(Math.random() * this.maxSpeed * 0.5 + 0.1);
                this.acceleration = new THREE.Vector3();
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
            }

            applyForce(force) { this.acceleration.add(force); }
            
            // Finds the nearest food particle
            findNearestFood() {
                if (this.isPredator) return null; // Predators are not interested in food pellets
                
                let closestFood = null;
                let minDistance = Infinity;
                
                for (const particle of food) {
                    const distance = this.position.distanceTo(particle.position);
                    
                    // Check if food is within perception radius
                    if (distance < this.perceptionRadius && distance < minDistance) {
                        minDistance = distance;
                        closestFood = particle;
                    }
                }
                
                return closestFood;
            }

            update(allBoids) {
                if (this.isEaten) return;

                if (this.fertilityBoostTimer > 0) {
                    this.fertilityBoostTimer--;
                    if (this.fertilityBoostTimer === 0) {
                        this.fertility = this.baseFertility;
                    }
                }

                this.age++;
                if (!this.isAdult && this.age > this.adultAge) {
                    this.isAdult = true;
                }
                if (!this.isAdult) {
                    const scale = fishSpecies[this.species].scale * (0.3 + 0.7 * (this.age / this.adultAge));
                    this.mesh.scale.set(scale, scale, scale);
                }

                if (!isImmortalMode && this.age > this.maxAge) {
                    this.isEaten = true; // Die of old age
                    return;
                }

                if (this.matingCooldown > 0) {
                    this.matingCooldown--;
                } else if (this.isAdult && !this.isMating && !this.isPredator && !this.wantsToMate) {
                    let mateChance = this.fertility;
                    if (this.fertilityBoostTimer > 0) {
                        mateChance = 0.25; // 25% chance when boost is active
                    }
                    if (Math.random() < mateChance) {
                        this.wantsToMate = true;
                    } else {
                        this.matingCooldown = 200 + Math.random() * 200; // Wait a bit before trying again
                    }
                }

                if (this.isMating) {
                    this.mate();
                } else {
                    // Search for food for non-predator fish that are not fleeing
                    const nearestFood = this.findNearestFood();
                    
                    if (nearestFood) {
                        // Calculate a direction vector towards the food
                        const foodDirection = new THREE.Vector3().subVectors(nearestFood.position, this.position);
                        
                        // Check if the fish is close enough to eat
                        if (foodDirection.length() < 5) {
                            // Eat the food
                            const foodIndex = food.indexOf(nearestFood);
                            if (foodIndex !== -1) {
                                scene.remove(nearestFood.mesh);
                                food.splice(foodIndex, 1);
                                
                                this.matingCooldown = 0;

                                // Apply fertility boost
                                const boost = 2; // 100% boost
                                this.fertility = Math.min(1.0, this.baseFertility * boost); // Cap at max fertility
                                this.fertilityBoostTimer = 500; // Boost lasts for ~8 seconds

                                // Increase max age by 20%
                                this.maxAge *= 1.2;

                                // Temporary visual effect (glow)
                                const currentColor = this.mesh.material.color.clone();
                                this.mesh.material.color.set(0xffff00);
                                
                                setTimeout(() => {
                                    this.mesh.material.color.copy(currentColor);
                                }, 300);
                            }
                        } else {
                            // Steer towards the food
                            const steerForce = this.seek(nearestFood.position);
                            steerForce.multiplyScalar(1.5); // Prioritize food
                            this.applyForce(steerForce);
                        }
                    } else {
                        // Normal behavior if no food is nearby
                        if (this.wantsToMate) {
                            this.findPartner(allBoids);
                        }
                        if (this.isPredator) this.hunt(allBoids);
                        else this.schoolAndFlee(allBoids);
                    }
                }

                this.velocity.add(this.acceleration);
                this.velocity.clampLength(0, this.maxSpeed);
                this.position.add(this.velocity);
                this.acceleration.multiplyScalar(0);

                this.checkBounds();
                this.mesh.position.copy(this.position);
                
                if (this.velocity.lengthSq() > 0.0001) {
                    const lookAtPoint = new THREE.Vector3().addVectors(this.position, this.velocity);
                    this.mesh.lookAt(lookAtPoint);
                    this.mesh.rotateY(-Math.PI / 2);
                }
            }

            findPartner(allBoids) {
                for (const other of allBoids) {
                    if (other !== this && !other.isPredator && other.species === this.species && other.wantsToMate && !other.isMating) {
                        const d = this.position.distanceTo(other.position);
                        if (d < this.perceptionRadius) {
                            this.isMating = true;
                            this.wantsToMate = false;
                            this.matingPartner = other;
                            this.matingTimer = 300; // 5 seconds

                            other.isMating = true;
                            other.wantsToMate = false;
                            other.matingPartner = this;
                            other.matingTimer = 300;
                            return;
                        }
                    }
                }
            }

            mate() {
                this.matingTimer--;

                if (this.matingTimer <= 0 || this.matingPartner.isEaten || !this.matingPartner) {
                    if (this.matingPartner) {
                        this.matingPartner.isMating = false;
                        this.matingPartner.matingCooldown = 1500 + Math.random() * 500;
                    }
                    this.isMating = false;
                    this.matingPartner = null;
                    this.matingCooldown = 1500 + Math.random() * 500;
                    return;
                }
                
                const directionToPartner = new THREE.Vector3().subVectors(this.matingPartner.position, this.position);
                const distance = directionToPartner.length();
                directionToPartner.normalize();

                const tangent = new THREE.Vector3(-directionToPartner.z, 0, directionToPartner.x);
                
                let steerForce = new THREE.Vector3();
                if (distance > 20) {
                    steerForce.add(this.seek(this.matingPartner.position));
                } else {
                    steerForce.add(tangent);
                }
                
                this.applyForce(steerForce.multiplyScalar(0.5));

                if (this.matingTimer === 1) {
                    const eggPosition = new THREE.Vector3().addVectors(this.position, this.matingPartner.position).multiplyScalar(0.5);
                    eggPosition.y = 2;
                    // Use the maximum generation between the two parents
                    const parentGeneration = Math.max(this.generation, this.matingPartner.generation);
                    eggs.push(new Egg(this.species, eggPosition, fishSpecies[this.species].color, parentGeneration));
                }
            }


            hunt(allBoids) {
                if (this.schoolAndFlee(allBoids, true)) return;
                if (this.satiation > 0) {
                    this.satiation--;
                    this.schoolAndFlee(allBoids, true);
                    return;
                }

                let bestTarget = null;
                let minDistance = Infinity;
                const preyBoids = allBoids.filter(b => !b.isPredator && !b.isEaten);
                const riskConfig = fishSpecies[this.species].riskAssessment;

                for (const potentialTarget of preyBoids) {
                    const d = this.position.distanceTo(potentialTarget.position);
                    if (d > riskConfig.maxDistance || d > minDistance) continue;
                    let groupSize = 0;
                    for (const otherPrey of preyBoids) {
                        if (potentialTarget.position.distanceTo(otherPrey.position) < 25) groupSize++;
                    }
                    if (groupSize > riskConfig.maxGroupSize) continue;
                    minDistance = d;
                    bestTarget = potentialTarget;
                }

                if (bestTarget) {
                    let pursuitForce = this.seek(bestTarget.position);
                    this.applyForce(pursuitForce);
                    if (this.position.distanceTo(bestTarget.position) < 5) {
                        if (!isImmortalMode) {
                            createEatEffect(bestTarget.position, fishSpecies[this.species].color);
                            bestTarget.isEaten = true;
                            simulationStats.preyEaten++;
                        }
                        this.satiation = 300;
                    }
                } else {
                    this.schoolAndFlee(allBoids, true);
                }
            }

            schoolAndFlee(allBoids, ignorePredators = false) {
                if (superPredator && superPredator.isActive) {
                    const d = this.position.distanceTo(superPredator.segments[0].position);
                    const superFearRadius = 200;
                    if (d < superFearRadius) {
                        let diff = new THREE.Vector3().subVectors(this.position, superPredator.segments[0].position);
                        diff.normalize().divideScalar(d);
                        let steer = this.seek(this.position.clone().add(diff));
                        steer.multiplyScalar(5.0);
                        this.applyForce(steer);
                        return true;
                    }
                }
                
                if (!this.isPredator && !ignorePredators) {
                    let fleeVector = new THREE.Vector3();
                    let predatorCount = 0;
                    for (const other of allBoids) {
                        if (other.isPredator) {
                            const d = this.position.distanceTo(other.position);
                            if (d > 0 && d < this.fearRadius) {
                                let diff = new THREE.Vector3().subVectors(this.position, other.position);
                                diff.normalize().divideScalar(d);
                                fleeVector.add(diff);
                                predatorCount++;
                            }
                        }
                    }
                    if (predatorCount > 0) {
                        fleeVector.divideScalar(predatorCount);
                        let steer = this.seek(this.position.clone().add(fleeVector));
                        steer.multiplyScalar(2.5);
                        this.applyForce(steer);
                        return true;
                    }
                }
                
                let separation = this.separate(allBoids);
                let alignment = this.align(allBoids);
                let cohesion = this.cohere(allBoids);

                separation.multiplyScalar(flockingForces.separation);
                alignment.multiplyScalar(flockingForces.alignment);
                cohesion.multiplyScalar(flockingForces.cohesion);

                this.applyForce(separation);
                this.applyForce(alignment);
                this.applyForce(cohesion);
                return false;
            }
            
            seek(target) {
                let desired = new THREE.Vector3().subVectors(target, this.position);
                desired.setLength(this.maxSpeed);
                let steer = new THREE.Vector3().subVectors(desired, this.velocity);
                steer.clampLength(0, this.maxForce);
                return steer;
            }

            separate(boids) {
                let desiredSeparation = 15.0;
                let steer = new THREE.Vector3();
                let count = 0;
                for (let other of boids) {
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < desiredSeparation)) {
                        let diff = new THREE.Vector3().subVectors(this.position, other.position);
                        diff.normalize();
                        diff.divideScalar(d);
                        steer.add(diff);
                        count++;
                    }
                }
                if (count > 0) steer.divideScalar(count);
                if (steer.length() > 0) {
                    steer.setLength(this.maxSpeed);
                    steer.sub(this.velocity);
                    steer.clampLength(0, this.maxForce);
                }
                return steer;
            }

            align(boids) {
                let sum = new THREE.Vector3();
                let count = 0;
                for (let other of boids) {
                    if (other.species !== this.species) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < this.perceptionRadius)) {
                        sum.add(other.velocity);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.divideScalar(count);
                    sum.setLength(this.maxSpeed);
                    let steer = new THREE.Vector3().subVectors(sum, this.velocity);
                    steer.clampLength(0, this.maxForce);
                    return steer;
                } else {
                    return new THREE.Vector3();
                }
            }

            cohere(boids) {
                let sum = new THREE.Vector3();
                let count = 0;
                for (let other of boids) {
                    if (other.species !== this.species) continue;
                    let d = this.position.distanceTo(other.position);
                    if ((d > 0) && (d < this.perceptionRadius)) {
                        sum.add(other.position);
                        count++;
                    }
                }
                if (count > 0) {
                    sum.divideScalar(count);
                    return this.seek(sum);
                } else {
                    return new THREE.Vector3();
                }
            }

            checkBounds() {
                const margin = 2;
                if (this.position.x < -worldSize.width/2+margin) { this.position.x = -worldSize.width/2+margin; this.velocity.x *= -1; }
                else if (this.position.x > worldSize.width/2-margin) { this.position.x = worldSize.width/2-margin; this.velocity.x *= -1; }
                if (this.position.y < margin) { this.position.y = margin; this.velocity.y *= -1; }
                else if (this.position.y > worldSize.height-margin) { this.position.y = worldSize.height-margin; this.velocity.y *= -1; }
                if (this.position.z < -worldSize.depth/2+margin) { this.position.z = -worldSize.depth/2+margin; this.velocity.z *= -1; }
                else if (this.position.z > worldSize.depth/2-margin) { this.position.z = worldSize.depth/2-margin; this.velocity.z *= -1; }
            }
        }

        // --- Auto Mode Manager ---
        class AutoModeManager {
            constructor() {
                this.updateInterval = 3000; // Check every 3 seconds
                this.lastUpdateTime = 0;
                this.targets = {
                    minPrey: 80,
                    maxPrey: 150,
                    superPredatorThreshold: 180,
                };
                this.startTime = 0;
                this.timerInterval = null;
                this.timerDisplayElement = document.getElementById('auto-mode-timer');
                this.lastPreyCount = 0;
            }

            start() {
                this.startTime = performance.now();
                this.timerDisplayElement.style.display = 'inline';
                if (this.timerInterval) clearInterval(this.timerInterval);
                this.timerInterval = setInterval(() => {
                    const elapsedTime = Math.floor((performance.now() - this.startTime) / 1000);
                    const minutes = String(Math.floor(elapsedTime / 60)).padStart(2, '0');
                    const seconds = String(elapsedTime % 60).padStart(2, '0');
                    this.timerDisplayElement.textContent = ` | Survie: ${minutes}:${seconds}`;
                }, 1000);
                const prey = boids.filter(b => !b.isEaten && !b.isPredator);
                this.lastPreyCount = prey.length;
            }

            stop(freeze = false) {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
                if (!freeze) {
                    this.timerDisplayElement.style.display = 'none';
                    this.timerDisplayElement.textContent = '';
                }
            }

            update() {
                const now = performance.now();
                if (now - this.lastUpdateTime < this.updateInterval) {
                    return;
                }
                this.lastUpdateTime = now;

                const aliveBoids = boids.filter(b => !b.isEaten);
                const prey = aliveBoids.filter(b => !b.isPredator);
                const predators = aliveBoids.filter(b => b.isPredator);
                const totalFish = prey.length + predators.length;

                if (totalFish === 0 && this.startTime > 0) {
                    this.stop(true); // Stop and freeze the timer
                    return;
                }

                const populationChangeRate = (this.lastPreyCount > 0) ? (prey.length - this.lastPreyCount) / this.lastPreyCount : 0;
                if (populationChangeRate < -0.10) { // More than 10% drop
                    generateFood(); // Emergency feeding
                    generateFood(); // Double dose
                }
                
                // Manage prey population based on thresholds
                if (prey.length < this.targets.minPrey) {
                    this.increaseFertility();
                    if (prey.length < this.targets.minPrey / 2) {
                        generateFood();
                    }
                } else if (prey.length > this.targets.maxPrey) {
                    this.decreaseFertility();
                }

                // Manage super predator
                if (prey.length > this.targets.superPredatorThreshold && !superPredator.isActive) {
                    superPredator.spawn();
                } else if (prey.length < this.targets.maxPrey && superPredator.isActive) {
                    scene.remove(superPredator.body);
                    superPredator.isActive = false;
                    document.getElementById('ropefish-status').setAttribute('data-lang-key', 'inactive');
                    setLanguage(document.documentElement.lang);
                }

                // Update the count for the next cycle
                this.lastPreyCount = prey.length;
            }

            increaseFertility() {
                for (const species in fishSpecies) {
                    if (fishSpecies[species].type === 'prey') {
                        fishSpecies[species].fertility = Math.min(0.1, fishSpecies[species].fertility + 0.002);
                        this.updateSlider(`${species}-fertility`, fishSpecies[species].fertility);
                    }
                }
            }

            decreaseFertility() {
                for (const species in fishSpecies) {
                    if (fishSpecies[species].type === 'prey') {
                        fishSpecies[species].fertility = Math.max(0.001, fishSpecies[species].fertility - 0.002);
                        this.updateSlider(`${species}-fertility`, fishSpecies[species].fertility);
                    }
                }
            }
            
            updateSlider(sliderId, value) {
                const slider = document.getElementById(sliderId);
                if (slider) {
                    slider.value = value;
                    const valueSpan = document.getElementById(`${sliderId}-value`);
                    if (valueSpan) {
                       valueSpan.textContent = value.toFixed(3);
                    }
                }
            }
        }

        function toggleAutoModeUI(isActive) {
            const statusEl = document.getElementById('auto-mode-status');
            const statusValueEl = document.getElementById('auto-mode-status-value');
            if (isActive) {
                statusEl.style.display = 'inline';
                statusValueEl.textContent = translations[document.documentElement.lang].active;
                autoModeManager.start();
            } else {
                statusEl.style.display = 'none';
                autoModeManager.stop();
            }

            document.querySelectorAll('.settings-panel fieldset').forEach(fieldset => {
                fieldset.disabled = isActive;
            });
        }
        
        function randomizeSettings() {
            // Randomize flocking forces
            flockingForces.alignment = (Math.random() * 2).toFixed(1);
            flockingForces.cohesion = (Math.random() * 2).toFixed(1);
            flockingForces.separation = (Math.random() * 2).toFixed(1);

            // Randomize environment
            environmentSettings.rockCount = Math.floor(Math.random() * 50);
            environmentSettings.plantCount = Math.floor(Math.random() * 100);

            // Randomize species parameters
            for (const species in fishSpecies) {
                const config = fishSpecies[species];
                config.count = Math.floor(Math.random() * 100) + 10; // 10 to 110 fish
                config.scale = (Math.random() * 1.5 + 0.2).toFixed(1);
                config.maxSpeed = (Math.random() * 1.5 + 0.2).toFixed(1);
                config.perceptionRadius = Math.floor(Math.random() * 150) + 20;

                if (config.type === 'prey') {
                    config.fearRadius = Math.floor(Math.random() * 150) + 30;
                    config.fertility = (Math.random() * 0.05).toFixed(3);
                }
                if (config.type === 'predator') {
                    config.riskAssessment.maxDistance = Math.floor(Math.random() * 200) + 50;
                    config.riskAssessment.maxGroupSize = Math.floor(Math.random() * 15) + 1;
                }
            }

            // Update UI sliders to reflect new values
            document.querySelectorAll('input[type=range]').forEach(slider => {
                const { category, species, property } = slider.dataset;
                let newValue;
                if (category === 'species') {
                    if (property.includes('.')) {
                        const [prop, subProp] = property.split('.');
                        newValue = fishSpecies[species][prop][subProp];
                    } else {
                        newValue = fishSpecies[species][property];
                    }
                } else if (category === 'flocking') {
                    newValue = flockingForces[property];
                } else if (category === 'environment') {
                    newValue = environmentSettings[property];
                }
                
                if (newValue !== undefined) {
                    slider.value = newValue;
                    const valueSpan = document.getElementById(`${slider.id}-value`);
                    if (valueSpan) {
                        valueSpan.textContent = newValue;
                    }
                }
            });

            // Re-initialize decor and simulation
            createDecor();
            createPlants();
            resetSimulation();
        }

        function startChaseAnimation() {
            const canvas = document.getElementById('chase-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            let leonceX = -200;
            let equityX = -350;
            const y = canvas.height / 2;
            
            function drawLightning(ctx, x1, y1, x2, y2) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                let lastX = x1;
                let lastY = y1;
                for(let i=1; i<10; i++) {
                    const newX = x1 + (x2 - x1) * (i / 10);
                    const newY = y1 + (y2 - y1) * (i / 10) + (Math.random() - 0.5) * 20;
                    ctx.lineTo(newX, newY);
                }
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = `rgba(0, 255, 255, ${Math.random() * 0.5 + 0.5})`;
                ctx.lineWidth = Math.random() * 2 + 1;
                ctx.stroke();
            }

            function animateChase() {
                chaseAnimationId = requestAnimationFrame(animateChase);
                
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                leonceX += 3;
                equityX += 3.2;

                if (equityX > canvas.width + 150) {
                    leonceX = -200;
                    equityX = -350;
                }

                ctx.font = 'bold 30px "Courier New", Courier, monospace';
                ctx.fillStyle = '#00ff41';
                ctx.shadowColor = '#00ff41';
                ctx.shadowBlur = 10;
                ctx.fillText("LEONCE", leonceX, y);
                ctx.fillText("EQUITY", equityX, y);
                ctx.shadowBlur = 0;

                if (Math.random() < 0.1) {
                    drawLightning(ctx, Math.random() * canvas.width, 0, Math.random() * canvas.width, canvas.height);
                }
            }
            animateChase();
        }

        function stopChaseAnimation() {
            cancelAnimationFrame(chaseAnimationId);
        }

        // --- Initialization ---
        init();
        loadSettings();
        setupUI();
        initModal();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020308);
            
            const ambientLight = new THREE.AmbientLight(0x001122, 0.3);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0x004488, 0.5);
            directionalLight.position.set(0, worldSize.height, worldSize.depth/2);
            scene.add(directionalLight);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 100, 600);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 1500;
            controls.target.set(0, worldSize.height / 2, 0);

            createAquariumBox();
            createFloorGrid();
            createDecor();
            createPlants();
            superPredator = new Ropefish();
            submarine = new Submarine();
            scene.add(submarine.mesh);
            autoModeManager = new AutoModeManager();
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('visibilitychange', handleVisibilityChange, false);
            document.getElementById('exit-btn').addEventListener('click', () => {
                document.querySelectorAll('.settings-panel').forEach(p => p.classList.add('hidden'));
                document.querySelectorAll('.control-group').forEach(g => {
                    g.classList.remove('active');
                    g.querySelector('.control-group-content').style.maxHeight = null;
                });
            });
        }

        // --- Scene Element Creation ---
        function createEatEffect(position, color) {
            const particleCount = 20;
            const material = new THREE.LineBasicMaterial({ color: color });
            for (let i = 0; i < particleCount; i++) {
                const vertices = [0,0,0, (Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)];
                const geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const particle = new THREE.Line(geometry, material);
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2, (Math.random() - 0.5) * 2),
                    life: 1.0
                };
                particles.push(particle);
                scene.add(particle);
            }
        }

        function createAquariumBox() {
            const geometry = new THREE.BoxGeometry(worldSize.width, worldSize.height, worldSize.depth);
            const wireMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff41, wireframe: true, transparent: true, opacity: 0.4 });
            const solidMaterial = new THREE.MeshBasicMaterial({ color: 0x004488, transparent: true, opacity: 0.1, side: THREE.BackSide });
            aquariumBox = new THREE.Mesh(geometry, wireMaterial);
            aquariumBox.userData.materials = [wireMaterial, solidMaterial];
            aquariumBox.position.set(0, worldSize.height / 2, 0);
            scene.add(aquariumBox);
            createBubbles();
        }
        function createFloorGrid() {
            const gridHelper = new THREE.GridHelper(worldSize.width, 15, 0x00ff41, 0x004411);
            gridHelper.material.opacity = 0.4;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            const topGrid = new THREE.GridHelper(worldSize.width, 15, 0x0088ff, 0x002244);
            topGrid.position.y = worldSize.height;
            topGrid.material.opacity = 0.2;
            topGrid.material.transparent = true;
            scene.add(topGrid);
        }
        function createDecor() {
            while(rocks.length) {
                const rock = rocks.pop();
                scene.remove(rock);
                rock.geometry.dispose();
            }
            const rockMaterial = new THREE.MeshBasicMaterial({ color: 0x00aa33, wireframe: isWireframeMode, transparent: true, opacity: 0.7 });
            for(let i=0; i < environmentSettings.rockCount; i++) {
                const size = Math.random() * 35 + 15;
                const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(size, 1), rockMaterial);
                rock.position.set((Math.random() - 0.5) * (worldSize.width - size * 2), size / 2, (Math.random() - 0.5) * (worldSize.depth - size * 2));
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                scene.add(rock);
                rocks.push(rock);
            }
        }
        function createPlants() {
            while(plants.length) {
                const plant = plants.pop();
                scene.remove(plant);
                plant.geometry.dispose();
            }
            const material = new THREE.LineBasicMaterial({ color: 0x00dd44, transparent: true, opacity: 0.8, linewidth: 2 });
            for (let i = 0; i < environmentSettings.plantCount; i++) {
                const vertices = [];
                const height = Math.random() * 80 + 30;
                vertices.push(0, 0, 0, 0, height, 0);
                for (let j = 0; j < Math.floor(Math.random() * 6) + 4; j++) {
                    const leafH = Math.random() * height * 0.8 + height * 0.2;
                    const leafL = Math.random() * 25 + 15;
                    const angle = Math.random() * Math.PI * 2;
                    const wave = Math.sin(leafH * 0.1) * 5;
                    vertices.push(0, leafH, 0, Math.cos(angle) * leafL + wave, leafH + (Math.random() - 0.5) * 8, Math.sin(angle) * leafL);
                }
                const geometry = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const plant = new THREE.LineSegments(geometry, material);
                plant.position.set((Math.random() - 0.5) * worldSize.width * 0.9, 0, (Math.random() - 0.5) * worldSize.depth * 0.9);
                scene.add(plant);
                plants.push(plant);
            }
        }
        function createBubbles() {
            const bubbleGeometry = new THREE.SphereGeometry(2, 6, 4);
            const bubbleMaterial = new THREE.MeshBasicMaterial({ color: 0x88ddff, transparent: true, opacity: 0.3, wireframe: isWireframeMode });
            for (let i = 0; i < 20; i++) {
                const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                bubble.position.set((Math.random() - 0.5) * worldSize.width * 0.8, Math.random() * worldSize.height * 0.3, (Math.random() - 0.5) * worldSize.depth * 0.8);
                bubble.userData = { velocity: Math.random() * 0.5 + 0.2, oscillation: Math.random() * 0.02 + 0.01 };
                scene.add(bubble);
            }
        }
        function createBoids() {
            while(boids.length) {
                const boid = boids.pop();
                scene.remove(boid.mesh);
            }
            boids = [];
            for (const species in fishSpecies) {
                for (let i = 0; i < fishSpecies[species].count; i++) {
                    boids.push(new Boid(species));
                }
            }
        }
        function updateStats() {
            const aliveBoids = boids.filter(b => !b.isEaten);
            const predators = aliveBoids.filter(b => b.isPredator);
            const prey = aliveBoids.filter(b => !b.isPredator);
            document.getElementById('fish-count').textContent = prey.length;
            document.getElementById('predator-count').textContent = predators.length;
            updateStatsPanel();
        }

        function updateStatsPanel() {
            const preyEatenEl = document.getElementById('stats-prey-eaten');
            if (preyEatenEl) preyEatenEl.textContent = simulationStats.preyEaten;

            for (const species in fishSpecies) {
                const countEl = document.getElementById(`stats-${species}-count`);
                if (countEl) countEl.textContent = boids.filter(b => b.species === species && !b.isEaten).length;
                
                const eggsEl = document.getElementById(`stats-${species}-eggs`);
                if (eggsEl) eggsEl.textContent = simulationStats.eggsLaid[species] || 0;

                const babiesEl = document.getElementById(`stats-${species}-babies`);
                if (babiesEl) babiesEl.textContent = simulationStats.babiesHatched[species] || 0;
                
                const generationEl = document.getElementById(`stats-${species}-generation`);
                if (generationEl) generationEl.textContent = simulationStats.maxGeneration[species] || 1;
            }
        }
        
        function resetSimulation() {
            simulationStats.preyEaten = 0;
            for(const species in fishSpecies) {
                simulationStats.eggsLaid[species] = 0;
                simulationStats.babiesHatched[species] = 0;
            }

            if(superPredator) {
                scene.remove(superPredator.body);
                superPredator.isActive = false;
                document.getElementById('ropefish-status').setAttribute('data-lang-key', 'inactive');
            }
            
            // Remove existing food particles
            for (const particle of food) {
                scene.remove(particle.mesh);
            }
            food = [];
            
            createBoids();
            setLanguage(document.documentElement.lang);
        }

        // --- Save/Load/Reset Settings ---
        function saveSettings() {
            const settings = {
                fishSpecies: fishSpecies,
                flockingForces: flockingForces,
                environmentSettings: environmentSettings
            };
            try {
                localStorage.setItem('aquarium-settings', JSON.stringify(settings));
                const saveBtn = document.getElementById('save-btn');
                if (saveBtn) {
                    saveBtn.style.backgroundColor = '#ff4141';
                    saveBtn.style.borderColor = '#ff4141';
                    setTimeout(() => {
                        saveBtn.style.backgroundColor = ''; // Revert to CSS default
                        saveBtn.style.borderColor = ''; // Revert to CSS default
                    }, 1000);
                }
            } catch(e) {
                console.error("Failed to save settings to localStorage", e);
            }
        }

        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('aquarium-settings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    // Deep merge utility
                    const isObject = (item) => (item && typeof item === 'object' && !Array.isArray(item));
                    const mergeDeep = (target, source) => {
                        if (isObject(target) && isObject(source)) {
                            for (const key in source) {
                                if (isObject(source[key])) {
                                    if (!target[key]) Object.assign(target, { [key]: {} });
                                    mergeDeep(target[key], source[key]);
                                } else {
                                    Object.assign(target, { [key]: source[key] });
                                }
                            }
                        }
                        return target;
                    }

                    mergeDeep(fishSpecies, settings.fishSpecies);
                    mergeDeep(flockingForces, settings.flockingForces);
                    mergeDeep(environmentSettings, settings.environmentSettings);
                }
            } catch(e) {
                console.error("Failed to load settings from localStorage", e);
            }
        }

        function resetSettings() {
            try {
                localStorage.removeItem('aquarium-settings');
                location.reload();
            } catch(e) {
                console.error("Failed to reset settings", e);
            }
        }

        // --- UI & Settings ---
        function updateSliderColor(slider, color) {
            const sliderId = slider.id;
            let styleTag = document.getElementById(`style-${sliderId}`);
            if (!styleTag) {
                styleTag = document.createElement('style');
                styleTag.id = `style-${sliderId}`;
                document.head.appendChild(styleTag);
            }
            styleTag.innerHTML = `
                #${sliderId}::-webkit-slider-thumb { background: ${color}; border-color: ${color}; }
                #${sliderId}::-moz-range-thumb { background: ${color}; border-color: ${color}; }
                #${sliderId}::-webkit-slider-runnable-track { background: ${color}; }
                #${sliderId}::-moz-range-track { background: ${color}; }
            `;
        }
        
        function createSlider(id, labelKey, min, max, step, value, dataAttributes) {
            const valueId = `${id}-value`;
            const lang = document.documentElement.lang || 'en';
            const labelText = (translations[lang] && translations[lang][labelKey]) ? translations[lang][labelKey] : labelKey.replace(/_/g, ' ');
            const dataAttrString = Object.entries(dataAttributes).map(([key, val]) => `data-${key}="${val}"`).join(' ');
            return `
                <label for="${id}" data-lang-key="${labelKey}">${labelText}: <span id="${valueId}">${value}</span></label>
                <input type="range" id="${id}" min="${min}" max="${max}" step="${step}" value="${value}" ${dataAttrString}>
            `;
        }

        function setupUI() {
            const mainControlsContainer = document.getElementById('main-controls-container');
            const settingsContainer = document.getElementById('settings-container');
            mainControlsContainer.innerHTML = '';
            settingsContainer.innerHTML = '';

            const icons = {
                species: `<svg class="btn-icon" viewBox="0 0 24 24"><path d="M14.2,18.5L12.9,19.8L12.2,19.1L12.5,17.8L11.5,17.2L10.5,17.8L10.2,19.1L9.5,19.8L8.2,18.5L8.5,17.2L7.5,16.5L8.2,15.2L9.5,15.5L10.2,14.2L10.5,15.5L11.5,16.2L12.5,15.5L12.2,14.2L12.9,15.2L14.2,16.5L13.5,17.2L14.2,18.5M19.1,12.2L17.8,12.5L17.2,11.5L17.8,10.5L19.1,10.2L19.8,9.5L18.5,8.2L17.2,8.5L16.5,7.5L15.2,8.2L15.5,9.5L14.2,10.2L15.2,10.5L15.5,11.5L16.2,12.2L17.2,12.9L18.5,14.2L19.1,12.9L19.8,12.2M19.8,4.3L19.1,5L18.5,4.3L17.2,5L17.8,3.5L17.2,2.9L18.5,2.2L19.1,3.5L19.8,2.9L20.5,3.5L19.8,4.3M9.5,5L8.2,4.3L7.5,5L8.5,3.5L8.2,2.9L9.5,2.2L10.2,3.5L10.5,2.9L11.2,3.5L10.5,4.3L11.2,5L9.5,5M5,10.2L4.3,9.5L3.5,10.2L2.9,9.5L3.5,8.2L2.9,7.5L4.3,8.2L5,7.5L5.7,8.2L5,10.2M22,22V2L2,22H22Z" /></svg>`,
                params: `<svg class="btn-icon" viewBox="0 0 24 24"><path d="M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z" /></svg>`,
                actions: `<svg class="btn-icon" viewBox="0 0 24 24"><path d="M13,2.05V5.08C16.39,5.57 19,8.47 19,12C19,15.53 16.39,18.43 13,18.92V21.95C18,21.45 22,17.15 22,12C22,6.85 18,2.55 13,2.05M11,2.05C6,2.55 2,6.85 2,12C2,17.15 6,21.45 11,21.95V18.92C7.61,18.43 5,15.53 5,12C5,8.47 7.61,5.57 11,5.08V2.05Z" /></svg>`,
                system: `<svg class="btn-icon" viewBox="0 0 24 24"><path d="M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A9,9 0 0,0 21,12A9,9 0 0,0 12,3M12,5A7,7 0 0,1 19,12A7,7 0 0,1 12,19A7,7 0 0,1 5,12A7,7 0 0,1 12,5M12,6A6,6 0 0,0 6,12A6,6 0 0,0 12,18A6,6 0 0,0 18,12A6,6 0 0,0 12,6M12,8A4,4 0 0,1 16,12A4,4 0 0,1 12,16A4,4 0 0,1 8,12A4,4 0 0,1 12,8Z" /></svg>`
            };
            
            const controlGroups = {
                species: { label: 'Esp√®ces', icon: icons.species, buttons: [] },
                params: { label: 'Param√®tres', icon: icons.params, buttons: [] },
                actions: { label: 'Actions', icon: icons.actions, buttons: [] },
                system: { label: 'Syst√®me', icon: icons.system, buttons: [] }
            };

            for (const species in fishSpecies) {
                controlGroups.species.buttons.push({
                    id: `btn-${species}`,
                    text: species.toUpperCase(),
                    color: `#${fishSpecies[species].color.toString(16).padStart(6, '0')}`,
                    panelId: `${species}-panel`,
                    tooltip: `Ouvre le panneau de ${species}`
                });
            }

            ['forces', 'environment'].forEach(key => {
                controlGroups.params.buttons.push({
                    id: `btn-${key}`,
                    text: key.toUpperCase(),
                    panelId: `${key}-panel`,
                    tooltip: `Ouvre le panneau ${key}`
                });
            });

            ['feed', 'release_ropefish', 'random_mode', 'immortal_mode', 'auto_mode', 'mode_wireframe', 'view_orbital'].forEach(key => {
                controlGroups.actions.buttons.push({
                    id: `btn-${key}`,
                    text: translations.fr[key],
                    key: key,
                    tooltip: `Action: ${translations.fr[key]}`
                });
            });
            
            ['statistics', 'help_title', 'save', 'reset', 'exjv_credit'].forEach(key => {
                 controlGroups.system.buttons.push({
                    id: `btn-${key}`,
                    text: translations.fr[key] || key.replace('_', ' ').toUpperCase(),
                    key: key,
                    tooltip: `Ouvre ${translations.fr[key] || key}`
                });
            });

            for (const groupKey in controlGroups) {
                const group = controlGroups[groupKey];
                const groupDiv = document.createElement('div');
                groupDiv.className = 'control-group';
                groupDiv.innerHTML = `
                    <div class="control-group-header">
                        ${group.icon}
                        <span>${group.label}</span>
                        <span class="caret">‚ñ∂</span>
                    </div>
                    <div class="control-group-content"></div>
                `;
                mainControlsContainer.appendChild(groupDiv);
                
                const contentDiv = groupDiv.querySelector('.control-group-content');
                group.buttons.forEach(btnData => {
                    const btn = document.createElement('button');
                    btn.id = btnData.id;
                    btn.className = 'settings-btn';
                    btn.innerHTML = `<span>${btnData.text}</span>`;
                    if (btnData.color) {
                        btn.style.color = btnData.color;
                        btn.style.borderColor = btnData.color;
                    }
                    btn.setAttribute('data-tooltip', btnData.tooltip);
                    contentDiv.appendChild(btn);
                });
            }
            
            mainControlsContainer.addEventListener('click', e => {
                const header = e.target.closest('.control-group-header');
                if (header) {
                    const group = header.parentElement;
                    group.classList.toggle('active');
                    const content = group.querySelector('.control-group-content');
                    if (group.classList.contains('active')) {
                        content.style.maxHeight = content.scrollHeight + "px";
                    } else {
                        content.style.maxHeight = null;
                    }
                }
            });


            function makeDraggable(panel) {
                const header = panel.querySelector('.panel-header');
                if (!header) return;
                let isDragging = false;
                let offset = { x: 0, y: 0 };
                
                const onMouseDown = (e) => {
                    panel.style.zIndex = ++highestZIndex;
                    isDragging = true;
                    let event = e.touches ? e.touches[0] : e;
                    offset.x = event.clientX - panel.offsetLeft;
                    offset.y = event.clientY - panel.offsetTop;
                    panel.style.cursor = 'grabbing';
                    document.body.style.userSelect = 'none';
                };

                const onMouseMove = (e) => {
                    if (!isDragging) return;
                    let event = e.touches ? e.touches[0] : e;
                    panel.style.left = `${event.clientX - offset.x}px`;
                    panel.style.top = `${event.clientY - offset.y}px`;
                };

                const onMouseUp = () => {
                    isDragging = false;
                    panel.style.cursor = 'default';
                    document.body.style.userSelect = '';
                };

                header.addEventListener('mousedown', onMouseDown);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
                header.addEventListener('touchstart', onMouseDown);
                document.addEventListener('touchmove', onMouseMove);
                document.addEventListener('touchend', onMouseUp);
            }

            function createPanel(id, titleKey, contentHtml, position, color) {
                const panel = document.createElement('div');
                panel.id = id;
                panel.className = 'settings-panel hidden';
                panel.style.left = `${position.x}px`;
                panel.style.top = `${position.y}px`;
                const lang = document.documentElement.lang || 'en';
                const titleText = (translations[lang] && translations[lang][titleKey]) ? translations[lang][titleKey] : titleKey;
                
                const headerStyle = color ? `style="color: ${color}; text-shadow: 0 0 5px ${color};"` : '';

                panel.innerHTML = `
                    <div class="panel-header">
                        <span data-lang-key="${titleKey}" ${headerStyle}>${titleText}</span>
                        <span class="close-btn">[X]</span>
                    </div>
                    <div class="panel-content">${contentHtml}</div>
                `;
                settingsContainer.appendChild(panel);
                panel.addEventListener('mousedown', () => {
                    panel.style.zIndex = ++highestZIndex;
                });
                panel.querySelector('.close-btn').addEventListener('click', () => panel.classList.add('hidden'));
                makeDraggable(panel);
                return panel;
            }
            
            let panelY = 100;
            let panelX = 230;

            for (const species in fishSpecies) {
                const config = fishSpecies[species];
                const colorString = `#${config.color.toString(16).padStart(6, '0')}`;
                
                let content = '<fieldset>';
                content += createSlider(`${species}-count`, 'count', 0, 150, 1, config.count, { category: 'species', species: species, property: 'count', reset: 'true' });
                content += createSlider(`${species}-scale`, 'scale', 0.1, 3, 0.1, config.scale, { category: 'species', species: species, property: 'scale', reset: 'true' });
                content += createSlider(`${species}-maxSpeed`, 'max_speed', 0.1, 2, 0.1, config.maxSpeed, { category: 'species', species: species, property: 'maxSpeed' });
                content += createSlider(`${species}-perceptionRadius`, 'perception_radius', 10, 200, 1, config.perceptionRadius, { category: 'species', species: species, property: 'perceptionRadius' });
                if (config.type === 'prey') {
                    content += createSlider(`${species}-fertility`, 'taux_fecondite', 0, 0.1, 0.001, config.fertility, { category: 'species', species: species, property: 'fertility' });
                }
                if (config.type === 'predator') {
                    content += createSlider(`${species}-maxHuntDist`, 'max_hunt_dist', 50, 300, 5, config.riskAssessment.maxDistance, { category: 'species', species: species, property: 'riskAssessment.maxDistance' });
                    content += createSlider(`${species}-maxGroupSize`, 'max_group_size', 1, 20, 1, config.riskAssessment.maxGroupSize, { category: 'species', species: species, property: 'riskAssessment.maxGroupSize' });
                }
                content += '</fieldset>';

                const panel = createPanel(`${species}-panel`, species, content, { x: panelX, y: panelY }, colorString);
                panel.querySelector('.panel-header > span').textContent = species.toUpperCase();
                panel.querySelectorAll('input[type=range]').forEach(slider => {
                    updateSliderColor(slider, colorString);
                });
                document.getElementById(`btn-${species}`).addEventListener('click', () => {
                    panel.classList.toggle('hidden');
                    panel.style.zIndex = ++highestZIndex;
                });
            }
            
            const generalPanels = ['forces', 'environment', 'statistics', 'help_title'];
            generalPanels.forEach(key => {
                let content = '';
                if(key === 'forces') {
                    content += '<fieldset>';
                    content += createSlider('alignment', 'alignment', 0, 2, 0.1, flockingForces.alignment, { category: 'flocking', property: 'alignment' });
                    content += createSlider('cohesion', 'cohesion', 0, 2, 0.1, flockingForces.cohesion, { category: 'flocking', property: 'cohesion' });
                    content += createSlider('separation', 'separation', 0, 2, 0.1, flockingForces.separation, { category: 'flocking', property: 'separation' });
                    content += '</fieldset>';
                } else if (key === 'environment') {
                    content += '<fieldset>';
                    content += createSlider('rockCount', 'rock_count', 0, 50, 1, environmentSettings.rockCount, { category: 'environment', property: 'rockCount', reset: 'decor' });
                    content += createSlider('plantCount', 'plant_count', 0, 100, 1, environmentSettings.plantCount, { category: 'environment', property: 'plantCount', reset: 'plants' });
                    content += '</fieldset>';
                } else if (key === 'statistics') {
                    let speciesStatsHtml = '';
                    for (const s in fishSpecies) {
                        if (fishSpecies[s].type === 'prey') {
                            const color = '#' + fishSpecies[s].color.toString(16).padStart(6, '0');
                            speciesStatsHtml += `
                                <fieldset style="border-color: ${color};">
                                    <legend style="color: ${color};">${s.toUpperCase()}</legend>
                                    <p>Population: <span id="stats-${s}-count">0</span></p>
                                    <p><span data-lang-key="eggs_laid">Oeufs</span>: <span id="stats-${s}-eggs">0</span></p>
                                    <p><span data-lang-key="babies_hatched">B√©b√©s</span>: <span id="stats-${s}-babies">0</span></p>
                                    <p><span data-lang-key="generation">G√©n√©ration Max</span>: <span id="stats-${s}-generation">1</span></p>
                                </fieldset>
                            `;
                        }
                    }
                    content = `<div id="stats-panel-content">
                        <p><span data-lang-key="prey_eaten">Proies mang√©es</span>: <span id="stats-prey-eaten">0</span></p>
                        <hr>
                        ${speciesStatsHtml}
                    </div>`;
                } else if (key === 'help_title') {
                    content = `<div data-lang-key="help_content"></div>`;
                }

                const panel = createPanel(`${key}-panel`, key, content, { x: panelX, y: panelY });
                document.getElementById(`btn-${key}`).addEventListener('click', () => {
                    panel.classList.toggle('hidden');
                    panel.style.zIndex = ++highestZIndex;
                });
            });
            
            const otherControlActions = {
                'auto_mode': (event) => {
                    isAutoModeActive = !isAutoModeActive;
                    toggleAutoModeUI(isAutoModeActive);
                    event.currentTarget.style.borderColor = isAutoModeActive ? '#ff4141' : '';
                },
                'random_mode': () => {
                    randomizeSettings();
                },
                'immortal_mode': (event) => {
                    isImmortalMode = !isImmortalMode;
                    event.currentTarget.style.borderColor = isImmortalMode ? '#00ffff' : '';
                    event.currentTarget.style.color = isImmortalMode ? '#00ffff' : '';
                },
                'mode_wireframe': (event) => {
                    isWireframeMode = !isWireframeMode;
                    const materials = [
                        ...boids.map(b => b.mesh.material),
                        ...rocks.map(r => r.material),
                        superPredator.segments[0].material,
                        ...superPredator.segments.slice(1).map(s => s.material),
                        ...scene.children.filter(c => c.userData.velocity && !c.userData.life).map(b => b.material)
                    ];
                    materials.forEach(m => { if(m) m.wireframe = isWireframeMode; });
                    aquariumBox.material = isWireframeMode ? aquariumBox.userData.materials[0] : aquariumBox.userData.materials[1];
                    event.currentTarget.setAttribute('data-lang-key', isWireframeMode ? 'mode_wireframe' : 'mode_solid');
                    setLanguage(document.documentElement.lang);
                },
                'view_orbital': (event) => {
                    isSubmarineViewActive = !isSubmarineViewActive;
                    submarine.mesh.visible = !isSubmarineViewActive;
                    event.currentTarget.setAttribute('data-lang-key', isSubmarineViewActive ? 'view_sub' : 'view_orbital');
                    setLanguage(document.documentElement.lang);
                },
                'release_ropefish': () => superPredator.spawn(),
                'feed': () => generateFood(),
                'save': saveSettings,
                'reset': resetSettings,
                'exjv_credit': () => {
                    const modal = document.getElementById('exjv-modal');
                    modal.classList.remove('hidden');
                    startChaseAnimation();
                    modal.addEventListener('click', (e) => {
                        if (e.target.classList.contains('modal-overlay') || e.target.classList.contains('close-btn')) {
                            modal.classList.add('hidden');
                            stopChaseAnimation();
                        }
                    });
                }
            };

            for (const key in otherControlActions) {
                 const btn = document.getElementById(`btn-${key}`);
                 if(btn) btn.addEventListener('click', otherControlActions[key]);
            }
            
            settingsContainer.addEventListener('input', (e) => {
                if (e.target.type !== 'range') return;
                const target = e.target;
                const value = parseFloat(target.value);
                const valueSpan = document.getElementById(`${target.id}-value`);
                if (valueSpan) {
                    valueSpan.textContent = value.toFixed(target.id.includes('fertility') ? 3 : (target.step < 1 ? 1 : 0));
                }
                const { category, species, property, reset } = target.dataset;
                if (category === 'species') {
                    if (property.includes('.')) {
                        const [prop, subProp] = property.split('.');
                        fishSpecies[species][prop][subProp] = value;
                    } else {
                        fishSpecies[species][property] = value;
                    }
                } else if (category === 'flocking') {
                    flockingForces[property] = value;
                } else if (category === 'environment') {
                    environmentSettings[property] = value;
                }
                if (reset === 'true') {
                    resetSimulation();
                } else if (reset === 'decor') {
                    createDecor();
                } else if (reset === 'plants') {
                    createPlants();
                }
            });

            setLanguage('en');
            resetSimulation(); // Now call resetSimulation to populate with correct (potentially loaded) settings
        }

        // --- Animation loop and other functions ---
        // Function to generate food
        function generateFood() {
            // Generate 15-25 food particles
            const count = Math.floor(Math.random() * 10) + 15;
            
            for (let i = 0; i < count; i++) {
                // Position particles randomly in the upper part of the aquarium
                const position = new THREE.Vector3(
                    (Math.random() - 0.5) * worldSize.width * 0.8,
                    worldSize.height * (0.8 + Math.random() * 0.15),
                    (Math.random() - 0.5) * worldSize.depth * 0.8
                );
                
                // Create and add the food particle
                food.push(new FoodParticle(position));
            }
            
            // Visual effect - small animation for the "FEED" button
            const feedBtn = document.querySelector('[data-lang-key="feed"]');
            if (feedBtn) {
                feedBtn.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    feedBtn.style.transform = '';
                }, 300);
            }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            
            if (lastFrameTime > 0) {
                const deltaTime = time - lastFrameTime;
                const fps = Math.round(1000 / deltaTime);
                if (isFinite(fps)) {
                    document.getElementById('fps').textContent = `FPS: ${fps}`;
                }
            }
            lastFrameTime = time;

            if (isAutoModeActive) {
                autoModeManager.update();
            }

            // Update eggs and hatch new boids
            let newBoids = [];
            for (let i = eggs.length - 1; i >= 0; i--) {
                const egg = eggs[i];
                const hatchedBoids = egg.update();
                if (hatchedBoids) {
                    newBoids.push(...hatchedBoids);
                    scene.remove(egg.mesh);
                    eggs.splice(i, 1);
                }
            }
            if (newBoids.length > 0) {
                boids.push(...newBoids);
            }
            
            // Update food particles
            for (let i = food.length - 1; i >= 0; i--) {
                const particle = food[i];
                const isDead = particle.update();
                
                if (isDead) {
                    scene.remove(particle.mesh);
                    food.splice(i, 1);
                }
            }

            scene.children.forEach(child => {
                if (child.userData && child.userData.velocity && !child.userData.life) { // Bubbles
                    child.position.y += child.userData.velocity;
                    child.position.x += Math.sin(Date.now() * child.userData.oscillation) * 0.1;
                    if (child.position.y > worldSize.height) {
                        child.position.y = 0;
                        child.position.x = (Math.random() - 0.5) * worldSize.width * 0.8;
                        child.position.z = (Math.random() - 0.5) * worldSize.depth * 0.8;
                    }
                }
            });

            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.position.add(particle.userData.velocity);
                particle.userData.life -= 0.05;
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            }
            
            if (superPredator) superPredator.update(boids);
            if (submarine) submarine.update();
            boids.forEach(boid => boid.update(boids));

            for (let i = boids.length - 1; i >= 0; i--) {
                if (boids[i].isEaten) {
                    scene.remove(boids[i].mesh);
                    boids[i].mesh.geometry.dispose();
                    if(boids[i].mesh.material.dispose) boids[i].mesh.material.dispose();
                    boids.splice(i, 1);
                }
            }

            if (Math.random() < 0.05) {
                updateStats();
            }

            if (!isSubmarineViewActive) {
                controls.update();
            }
            
            const activeCamera = isSubmarineViewActive ? submarine.camera : camera;
            renderer.render(scene, activeCamera);
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            if (submarine) {
                submarine.camera.aspect = window.innerWidth / window.innerHeight;
                submarine.camera.updateProjectionMatrix();
            }
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function catchUpSimulation(seconds) {
            const missedFrames = Math.round(seconds * 60); // Assuming 60fps
            if (missedFrames <= 0) return;

            console.log(`Catching up ${missedFrames} frames...`);

            // Fast-forward life cycle aspects
            boids.forEach(boid => {
                boid.age += missedFrames;
                boid.matingCooldown = Math.max(0, boid.matingCooldown - missedFrames);
                // Approximate movement
                boid.position.addScaledVector(boid.velocity, seconds);
                boid.checkBounds(); // Simple boundary check
            });

            let newBoidsFromHatching = [];
            for (let i = eggs.length - 1; i >= 0; i--) {
                const egg = eggs[i];
                egg.hatchTime -= missedFrames;
                if (egg.hatchTime <= 0) {
                    const hatched = egg.hatch();
                    if(hatched) newBoidsFromHatching.push(...hatched);
                    scene.remove(egg.mesh);
                    eggs.splice(i, 1);
                }
            }
            if(newBoidsFromHatching.length > 0) {
                boids.push(...newBoidsFromHatching);
            }
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                lastHiddenTime = performance.now();
            } else {
                if (lastHiddenTime > 0) {
                    const elapsedTime = (performance.now() - lastHiddenTime) / 1000;
                    catchUpSimulation(elapsedTime);
                }
                lastHiddenTime = 0;
            }
        }
    </script>
</body>
</html>
