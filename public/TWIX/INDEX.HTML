<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TWIX - The Hunter</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <style>
        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { background-color: #050505; color: #eee; font-family: 'Courier New', Courier, monospace; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; height: 100vh; height: 100dvh; margin: 0; overflow: hidden; padding: 10px; transition: background-color 0.5s; }
        :fullscreen { overflow: hidden; }
        :-webkit-full-screen { overflow: hidden; }
        
        #game-wrapper { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; position: relative; }
        
        /* TOP HUD */
        #ui { 
            width: 100%; max-width: 800px; 
            display: grid; 
            grid-template-columns: 50px 1fr; 
            align-items: center; 
            padding: 10px 20px; 
            font-size: clamp(14px, 4vw, 20px); font-weight: bold; 
            background: linear-gradient(180deg, rgba(0,20,40,0.9) 0%, rgba(0,0,0,0) 100%);
            border-top: 2px solid #0ff;
            border-radius: 0 0 15px 15px;
            z-index: 50; margin-bottom: 10px; 
            text-shadow: 0 0 5px #0ff;
        }

        #stats-bar { display: flex; justify-content: space-around; width: 100%; }
        .hud-item { white-space: nowrap; }
        #mode-indicator { color: #f80; text-shadow: 0 0 5px #f00; }
        .hud-percent { opacity: 0.5; font-size: 0.8em; } 
        
        /* SETTINGS BUTTON */
        #settings-toggle {
            background: transparent; border: 1px solid #0ff; color: #0ff;
            width: 40px; height: 40px; font-size: 24px; 
            cursor: pointer; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px #0ff;
        }
        #settings-toggle:hover { background: rgba(0, 255, 255, 0.2); transform: rotate(90deg); box-shadow: 0 0 15px #0ff; }

        /* UNIFIED SETTINGS PANEL */
        #settings-panel {
            position: absolute; top: 70px; left: 20px;
            background: rgba(0, 15, 30, 0.95);
            border: 1px solid #0ff; border-radius: 10px; padding: 15px;
            display: none; flex-direction: column; gap: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8), 0 0 10px rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(5px); z-index: 100;
            animation: slideDown 0.2s ease-out;
        }

        @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }

        .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .ctrl-btn {
            background: rgba(255, 255, 255, 0.05); border: 1px solid #555; color: #ccc;
            padding: 10px; border-radius: 5px; cursor: pointer;
            display: flex; align-items: center; gap: 10px;
            font-family: 'Courier New', Courier, monospace; font-size: 12px; font-weight: bold;
            transition: all 0.2s; width: 140px;
        }
        .ctrl-btn:hover { background: rgba(0, 255, 255, 0.15); border-color: #0ff; color: #fff; }
        .ctrl-btn .icon { font-size: 18px; min-width: 25px; text-align: center; }
        .menu-divider { height: 1px; background: #333; margin: 5px 0; }
        
        /* VERSION DISPLAY */
        .version-tag {
            text-align: right; color: #444; font-size: 10px; margin-top: 5px; font-family: sans-serif;
        }
        #main-menu-version {
            position: absolute; bottom: 10px; right: 10px;
            color: #666; font-size: 14px; font-family: 'Courier New', monospace; font-weight: bold;
            pointer-events: none; opacity: 0.7;
        }
        #update-indicator {
            display: inline-block; width: 8px; height: 8px; background: #f00; border-radius: 50%; margin-left: 5px;
            animation: pulse-red 1s infinite; display: none;
        }
        @keyframes pulse-red { 0% { opacity: 0.5; transform: scale(1); } 50% { opacity: 1; transform: scale(1.5); } 100% { opacity: 0.5; transform: scale(1); } }

        #game-container { position: relative; width: 100%; height: auto; aspect-ratio: 4/3; max-height: 80vh; max-width: 106vh; background: #000; margin: auto; border-radius: 10px; border: 2px solid #333; box-shadow: 0 0 0 2px #111, 0 0 30px rgba(0, 200, 255, 0.1); overflow: hidden; transition: border-color 0.5s; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; filter: contrast(1.2) brightness(1.1); }
        
        #minimap-container { position: absolute; top: 10px; right: 10px; width: 160px; height: 120px; background: rgba(0, 10, 20, 0.8); border: 2px solid #0ff; border-radius: 4px; box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); z-index: 12; pointer-events: none; display: none; }
        #minimap { width: 100%; height: 100%; display: block; image-rendering: pixelated; }

        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; display: none; z-index: 20; }
        #pause-overlay { background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(2px); }
        
        /* NEWS / CHANGELOG OVERLAY */
        #news-overlay { z-index: 150; background: rgba(0, 10, 20, 0.98); }
        #news-content { width: 90%; max-width: 600px; max-height: 70vh; overflow-y: auto; text-align: left; padding: 20px; border: 1px solid #333; background: rgba(0,0,0,0.5); margin-bottom: 20px; }
        .news-entry { margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .news-version { color: #0ff; font-size: 20px; font-weight: bold; margin-bottom: 5px; display: flex; justify-content: space-between; }
        .news-date { color: #555; font-size: 12px; }
        .news-list { list-style: none; padding-left: 0; margin-top: 10px; }
        .news-list li { margin-bottom: 5px; color: #ccc; position: relative; padding-left: 20px; font-size: 14px; }
        .news-list li::before { content: '‚ñ∫'; color: #f0f; position: absolute; left: 0; font-size: 10px; top: 3px; }
        .news-new-badge { background: #f00; color: #fff; padding: 2px 5px; border-radius: 3px; font-size: 10px; vertical-align: middle; margin-left: 10px; }

        /* TITLE & ANIMATIONS */
        #message-title { 
            font-size: clamp(30px, 8vw, 60px); color: #f0f; margin-bottom: 20px; text-shadow: 2px 2px #fff, 0 0 20px #f0f; text-align: center; font-family: 'Courier New', Courier, monospace; letter-spacing: 5px;
            position: relative; display: inline-block; padding: 20px 40px; border: 4px solid #f0f; box-shadow: 0 0 15px #f0f, inset 0 0 15px #f0f; background: rgba(0, 0, 0, 0.8);
            animation: neon-pulse 1.5s infinite alternate;
        }
        @keyframes neon-pulse { from { box-shadow: 0 0 10px #f0f, inset 0 0 10px #f0f; border-color: #a0a; } to { box-shadow: 0 0 25px #f0f, inset 0 0 25px #f0f; border-color: #f0f; } }
        .title-sparx { position: absolute; width: 12px; height: 12px; background: #fff; box-shadow: 0 0 10px #fff, 0 0 20px #f0f; animation: track-border 3s linear infinite; }
        .title-sparx::after { content: ''; position: absolute; top:0; left:0; width:100%; height:100%; background: inherit; transform: rotate(45deg); }
        @keyframes track-border { 0% { top: -6px; left: -6px; } 25% { top: -6px; left: calc(100% - 6px); } 50% { top: calc(100% - 6px); left: calc(100% - 6px); } 75% { top: calc(100% - 6px); left: -6px; } 100% { top: -6px; left: -6px; } }

        #pause-title { font-size: clamp(30px, 8vw, 50px); color: #f0f; margin-bottom: 20px; text-shadow: 2px 2px #fff, 0 0 20px #f0f; text-align: center; font-family: 'Courier New', Courier, monospace; letter-spacing: 5px; }
        #message-subtitle, #pause-subtitle { font-size: clamp(14px, 4vw, 20px); color: #fff; margin-bottom: 30px; text-align: center; padding: 0 20px; text-shadow: 0 0 5px #fff; }
        
        button.main-btn { padding: 15px 40px; font-size: 20px; background: transparent; color: #0ff; border: 2px solid #0ff; cursor: pointer; font-family: inherit; font-weight: bold; text-transform: uppercase; box-shadow: 0 0 10px #0ff, inset 0 0 10px #0ff; text-shadow: 0 0 5px #0ff; transition: all 0.2s; }
        button.main-btn:hover { background: #0ff; color: #000; box-shadow: 0 0 20px #0ff; }
        button.main-btn:disabled { border-color: #555; color: #555; box-shadow: none; cursor: not-allowed; }
        .lvl-completed { color: #555 !important; text-decoration: line-through; text-shadow: none !important; }

        /* UI SELECTION FOR DPAD NAV */
        .ui-selected { 
            border-color: #f0f !important; 
            box-shadow: 0 0 15px #f0f, inset 0 0 10px #f0f !important; 
            transform: scale(1.05); 
            background: rgba(255, 0, 255, 0.2) !important;
            color: #fff !important;
            z-index: 100;
        }
        
        /* SHOP STYLES */
        #shop-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 20px; width: 95%; max-width: 700px; overflow-y: auto; max-height: 60vh; padding: 5px; }
        .shop-item { border: 1px solid #555; padding: 8px; text-align: center; cursor: pointer; transition: all 0.2s; background: rgba(0,0,0,0.5); border-radius: 5px; display: flex; flex-direction: column; align-items: center; min-height: 100px; justify-content: center; }
        .shop-item:hover { border-color: #ff0; background: rgba(50,50,0,0.3); transform: scale(1.05); }
        .shop-item.disabled { opacity: 0.5; cursor: not-allowed; border-color: #333; transform: none; }
        .shop-icon { font-size: 24px; margin-bottom: 5px; }
        .shop-name { color: #0ff; font-size: 12px; font-weight: bold; margin-bottom: 2px; text-transform: uppercase; }
        .shop-cost { color: #ff0; font-size: 11px; }
        .shop-desc { color: #aaa; font-size: 9px; margin-top: 2px; }
        #shop-balance { font-size: 24px; color: #ff0; margin-bottom: 10px; text-shadow: 0 0 10px #ff0; }
        
        #rules-content { width: 90%; max-width: 600px; text-align: left; font-size: 14px; line-height: 1.5; color: #ccc; max-height: 70vh; overflow-y: auto; padding-right: 10px; }
        #rules-content h3 { color: #0ff; border-bottom: 1px solid #0ff; padding-bottom: 5px; margin-top: 20px; }
        #rules-content ul { padding-left: 20px; list-style-type: square; }
        #rules-content li { margin-bottom: 5px; }
        #rules-content strong { color: #fff; }

        #tutorial-overlay { position: absolute; bottom: 20%; left: 0; width: 100%; text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 14px; pointer-events: none; z-index: 15; display: none; }
        #bonus-indicator { position: absolute; top: 50px; left: 50%; transform: translateX(-50%); color: #fff; font-weight: bold; font-size: 20px; text-shadow: 0 0 5px #000; pointer-events: none; z-index: 10; }
        #audio-status { position: absolute; bottom: 60px; right: 20px; color: #555; font-size: 10px; pointer-events: none; text-align: right; }
        
        #boss-warning, #hunter-alert { display: none !important; }
        
        #level-selector { display: flex; align-items: center; justify-content: center; margin-bottom: 20px; gap: 15px; }
        .lvl-btn { padding: 5px 15px; font-size: 20px; min-width: 50px; background: transparent; border: 1px solid #0ff; color: #0ff; cursor: pointer; }
        #start-level-display { font-size: 24px; color: #ff0; min-width: 100px; text-align: center; text-shadow: 0 0 10px #ff0; }
        
        #virtual-controls { position: absolute; bottom: 20px; left: 0; width: 100%; height: 160px; pointer-events: none; display: flex; justify-content: space-between; align-items: flex-end; padding: 0 20px; z-index: 100; opacity: 0.6; }
        .dpad-container { position: relative; width: 150px; height: 150px; pointer-events: auto; }
        .dpad-btn { position: absolute; width: 50px; height: 50px; background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 10px; display: flex; align-items: center; justify-content: center; color: #fff; font-size: 20px; touch-action: manipulation; transition: background 0.1s; }
        .dpad-btn:active, .dpad-btn.active { background: rgba(0, 255, 255, 0.4); border-color: #0ff; box-shadow: 0 0 10px #0ff; }
        #btn-up { top: 0; left: 50px; } #btn-down { bottom: 0; left: 50px; } #btn-left { top: 50px; left: 0; } #btn-right { top: 50px; right: 0; }
        
        .action-btns { position: absolute; right: 20px; bottom: 20px; display: flex; flex-direction: column; gap: 10px; align-items: center; pointer-events: auto; }
        #btn-speed { width: 80px; height: 80px; border-radius: 50%; background: rgba(255, 165, 0, 0.2); border: 2px solid rgba(255, 165, 0, 0.5); display: flex; align-items: center; justify-content: center; color: #ff0; font-weight: bold; font-size: 16px; text-shadow: 0 0 5px #000; }
        #btn-speed:active, #btn-speed.active { background: rgba(255, 165, 0, 0.6); box-shadow: 0 0 15px #f80; color: #fff; }
        
        .ability-btn { width: 60px; height: 60px; border-radius: 50%; border: 2px solid; display: none; align-items: center; justify-content: center; font-weight: bold; font-size: 20px; text-shadow: 0 0 5px #000; margin-bottom: 5px; }
        .ability-btn:active { transform: scale(0.95); }
        #btn-fire { background: rgba(0, 255, 255, 0.2); border-color: rgba(0, 255, 255, 0.5); color: #0ff; }
        #btn-fire:active { background: rgba(0, 255, 255, 0.6); box-shadow: 0 0 15px #0ff; color: #fff; }
        #btn-repulsor { background: rgba(255, 0, 255, 0.2); border-color: rgba(255, 0, 255, 0.5); color: #f0f; }
        #btn-repulsor:active { background: rgba(255, 0, 255, 0.6); box-shadow: 0 0 15px #f0f; color: #fff; }

        @media (min-width: 800px) { #virtual-controls { display: none; } }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="ui">
            <button id="settings-toggle" onclick="toggleSettings()">‚öôÔ∏è<div id="update-indicator"></div></button>
            <div id="settings-panel">
                <div class="control-grid">
                    <button id="nav-btn-resume" class="ctrl-btn" onclick="togglePauseAndMenu()"><span class="icon">‚èØ</span> <span id="m_pause">PAUSE</span></button>
                    <button id="nav-btn-menu" class="ctrl-btn" onclick="returnToMenu()"><span class="icon">üè†</span> <span id="m_menu">MENU</span></button>
                </div>
                <div class="menu-divider"></div>
                <div class="control-grid">
                    <button id="nav-btn-audio" class="ctrl-btn" onclick="toggleSound()"><span class="icon" id="m_snd_icon">üîä</span> <span id="m_snd">AUDIO</span></button>
                    <button id="nav-btn-screen" class="ctrl-btn" onclick="toggleFullScreen()"><span class="icon">‚õ∂</span> <span id="m_fs">SCREEN</span></button>
                </div>
                <div class="menu-divider"></div>
                <div class="control-grid">
                    <button id="nav-btn-lang" class="ctrl-btn" onclick="toggleLanguage()"><span class="icon">üåê</span> <span id="m_lang">LANG: EN</span></button>
                    <button id="nav-btn-rules" class="ctrl-btn" onclick="openRules()"><span class="icon">‚ùì</span> <span id="m_rules">RULES</span></button>
                </div>
                <div class="menu-divider"></div>
                <div class="control-grid">
                     <button id="nav-btn-news" class="ctrl-btn" onclick="VersionManager.showNews()"><span class="icon">üì∞</span> <span id="m_news">NEWS</span></button>
                </div>
                <div id="settings-version" class="version-tag"></div>
            </div>
            <div id="stats-bar">
                <div class="hud-item" style="color: #ff0;">HI: <span id="high-score">0</span></div>
                <div class="hud-item" style="color: #0ff; text-shadow: 0 0 5px #0ff;">LVL: <span id="level-display">1</span></div>
                <div class="hud-item" id="mode-indicator">SLOW</div>
                <div class="hud-item">SCR: <span id="score">0</span></div>
                <div class="hud-item hud-percent"><span id="percent">0</span>%</div>
                <div class="hud-item hud-percent">‚ù§: <span id="lives">3</span></div>
            </div>
        </div>
        
        <div id="game-container">
            <canvas id="gameCanvas" width="600" height="450"></canvas>
            <div id="minimap-container">
                <canvas id="minimap" width="160" height="120"></canvas>
            </div>
            <div id="bonus-indicator"></div>
            <div id="audio-status">AUDIO ON</div>
            <div id="tutorial-overlay">D-PAD to Move<br>HOLD TURBO for Speed<br>SPACE: SHOOT | X: BLAST</div>
            
            <div id="message-overlay" class="overlay">
                <div id="message-title">
                    <div class="title-sparx"></div>
                    <div class="title-sparx" style="animation-delay: -1.5s;"></div>
                    TWIX XL
                </div>
                <div id="message-subtitle">PC: Arrows | Mobile: D-Pad | 4x LARGER WORLD</div>
                <div id="level-selector">
                    <button class="lvl-btn" onclick="adjustStartLevel(-1)">‚óÄ</button>
                    <span id="start-level-display">LEVEL 1</span>
                    <button class="lvl-btn" onclick="adjustStartLevel(1)">‚ñ∂</button>
                </div>
                <button id="action-btn" class="main-btn" onclick="handleAction()">INSERT COIN</button>
                <button id="shop-btn" class="main-btn" style="margin-top: 10px; border-color: #ff0; color: #ff0;" onclick="openShop()">SHOP üõí</button>
                <div style="position: absolute; bottom: 28px; right: 10px; color: #555; font-size: 11px; font-weight: bold; pointer-events: none; font-family: 'Courier New', Courier, monospace;">(c) LEONCE EQUITY</div>
                <div id="main-menu-version"></div>
            </div>

            <div id="shop-overlay" class="overlay" style="display:none; background: rgba(0,10,20,0.95);">
                <div id="shop-title" style="color:#ff0; font-size: 30px; margin-bottom: 10px;">SHOP</div>
                <div id="shop-balance">SCORE: <span id="shop-score-display">0</span></div>
                <div id="shop-grid">
                    <div class="shop-item" onclick="buyUpgrade('life')"><div class="shop-icon">‚ù§</div><div class="shop-name" id="n_life">EXTRA LIFE</div><div class="shop-cost">50000</div><div class="shop-desc" id="d_life">+1 Life</div></div>
                    <div class="shop-item" onclick="buyUpgrade('speed')"><div class="shop-icon">‚ö°</div><div class="shop-name" id="n_speed">SPEED</div><div class="shop-cost">25000</div><div class="shop-desc" id="d_speed">+10% Speed</div></div>
                    <div class="shop-item" onclick="buyUpgrade('shield')"><div class="shop-icon">üõ°Ô∏è</div><div class="shop-name" id="n_shield">SHIELD</div><div class="shop-cost">15000</div><div class="shop-desc" id="d_shield">+2s Duration</div></div>
                    <div class="shop-item" onclick="buyUpgrade('time')"><div class="shop-icon">‚è≥</div><div class="shop-name" id="n_time">TIME</div><div class="shop-cost">20000</div><div class="shop-desc" id="d_time">Delay Super Sparx</div></div>
                    <div class="shop-item" onclick="buyUpgrade('lucky')"><div class="shop-icon">üçÄ</div><div class="shop-name" id="n_lucky">LUCKY</div><div class="shop-cost">30000</div><div class="shop-desc" id="d_lucky">Spawn Bonus x2</div></div>
                    <div class="shop-item" onclick="buyUpgrade('greed')"><div class="shop-icon">üíé</div><div class="shop-name" id="n_greed">GREED</div><div class="shop-cost">37500</div><div class="shop-desc" id="d_greed">Score +20%</div></div>
                    <div class="shop-item" onclick="buyUpgrade('sabotage')"><div class="shop-icon">ü¶†</div><div class="shop-name" id="n_sabotage">SABOTAGE</div><div class="shop-cost">27500</div><div class="shop-desc" id="d_sabotage">Slow Sparx</div></div>
                    <div class="shop-item" onclick="buyUpgrade('decoy')"><div class="shop-icon">üéØ</div><div class="shop-name" id="n_decoy">DECOY</div><div class="shop-cost">22500</div><div class="shop-desc" id="d_decoy">Start with Decoy</div></div>
                    <div class="shop-item" onclick="buyUpgrade('sweeper')"><div class="shop-icon">üßπ</div><div class="shop-name" id="n_sweeper">SWEEPER</div><div class="shop-cost">25000</div><div class="shop-desc" id="d_sweeper">Clear all mines</div></div>
                    <div class="shop-item" onclick="buyUpgrade('alchemy')"><div class="shop-icon">‚öóÔ∏è</div><div class="shop-name" id="n_alchemy">ALCHEMY</div><div class="shop-cost">40000</div><div class="shop-desc" id="d_alchemy">Mines = Gold</div></div>
                    <div class="shop-item" onclick="buyUpgrade('stun')"><div class="shop-icon">üî´</div><div class="shop-name" id="n_stun">MISSILE</div><div class="shop-cost">35000</div><div class="shop-desc" id="d_stun">Stun Shot (Space)</div></div>
                    <div class="shop-item" onclick="buyUpgrade('repulsor')"><div class="shop-icon">üîä</div><div class="shop-name" id="n_repulsor">REPULSOR</div><div class="shop-cost">27500</div><div class="shop-desc" id="d_repulsor">Push Back (X)</div></div>
                </div>
                <button id="btn-shop-back" class="main-btn" onclick="closeShop()">BACK</button>
            </div>

            <div id="rules-overlay" class="overlay" style="display:none; background: rgba(0,10,20,0.98);">
                <div id="rules-title" style="color:#0ff; font-size: 30px; margin-bottom: 20px;">GAME RULES</div>
                <div id="rules-content"></div>
                <button id="btn-rules-back" class="main-btn" style="margin-top: 20px;" onclick="closeRules()">GOT IT!</button>
            </div>

            <div id="news-overlay" class="overlay" style="display:none;">
                <div id="news-title" style="color:#f0f; font-size: 30px; margin-bottom: 20px; text-shadow: 0 0 10px #f0f;">WHAT'S NEW</div>
                <div id="news-content"></div>
                <button id="btn-news-close" class="main-btn" style="margin-top: 10px;" onclick="VersionManager.closeNews()">AWESOME</button>
            </div>

            <div id="pause-overlay" class="overlay">
                <div id="pause-title" style="color: #ff0;">PAUSED</div>
                <div id="pause-subtitle">Press P or Button to Resume</div>
                <button id="btn-resume" class="main-btn" onclick="togglePause()">RESUME</button>
            </div>
        </div>
        
        <div id="virtual-controls">
            <div class="dpad-container">
                <div id="btn-up" class="dpad-btn" ontouchstart="handleDpad('ArrowUp', true)" ontouchend="handleDpad('ArrowUp', false)">‚ñ≤</div>
                <div id="btn-left" class="dpad-btn" ontouchstart="handleDpad('ArrowLeft', true)" ontouchend="handleDpad('ArrowLeft', false)">‚óÄ</div>
                <div id="btn-right" class="dpad-btn" ontouchstart="handleDpad('ArrowRight', true)" ontouchend="handleDpad('ArrowRight', false)">‚ñ∂</div>
                <div id="btn-down" class="dpad-btn" ontouchstart="handleDpad('ArrowDown', true)" ontouchend="handleDpad('ArrowDown', false)">‚ñº</div>
            </div>
            <div class="action-btns">
                <div id="btn-repulsor" class="ability-btn" ontouchstart="handleRepulsor()" onclick="handleRepulsor()">üîä</div>
                <div id="btn-fire" class="ability-btn" ontouchstart="handleFire()" onclick="handleFire()">üî´</div>
                <div id="btn-speed" ontouchstart="handleSpeed(true)" ontouchend="handleSpeed(false)">TURBO</div>
            </div>
        </div>
    </div>

<script>
// --- GLOBAL CONSTANTS FIXED ---
const VIEW_WIDTH = 600;
const VIEW_HEIGHT = 450;
const WORLD_WIDTH = 1200; // 4x Area (2x W, 2x H)
const WORLD_HEIGHT = 900;
const T_EMPTY = 0;
const T_WALL = 1;
const T_TRAIL = 2;
const T_FILLED_BLUE = 3;
const T_FILLED_RED = 4;
const T_FLASH = 5;
const T_MINE = 6;
const T_ELECTRIC_WALL = 8;
const T_FILLED_RAINBOW = 9;

const BASE_QIX_SPEED = 2;
const SPARX_SPEED = 3;
const SUPER_SPARX_SPEED = 6;
const WIN_THRESHOLD = 0.75;
const MAX_PARTICLES = 1500; // Added MAX_PARTICLES
const GAME_VERSION = "1.8.7"; // Updated version

const CHANGELOG = [
    {
        version: "1.8.7",
        date: "2023-11-29",
        features: {
            en: ["Hotfix: Restored missing MAX_PARTICLES constant"],
            fr: ["Correctif : R√©tablissement de la constante MAX_PARTICLES manquante"]
        }
    },
    {
        version: "1.8.6",
        date: "2023-11-29",
        features: {
            en: ["UI: Level number added to HUD", "Visuals: Neon styling for level indicator"],
            fr: ["UI : Num√©ro du niveau ajout√© au HUD", "Visuels : Style n√©on pour l'indicateur"]
        }
    },
    {
        version: "1.8.5",
        date: "2023-11-29",
        features: {
            en: ["Hotfix: Crash due to missing MAX_PARTICLES constant"],
            fr: ["Correctif : Crash d√ª √† une constante manquante"]
        }
    },
    {
        version: "1.8.4",
        date: "2023-11-29",
        features: {
            en: ["Fixed: Shop button missing in Menu/Win screens", "UI: Shop available between levels"],
            fr: ["Correctif : Bouton boutique manquant", "UI : Boutique accessible entre les niveaux"]
        }
    },
    {
        version: "1.8.3",
        date: "2023-11-29",
        features: {
            en: ["UI Fix: Win button is now 'CONTINUE'", "Fixed: Life counter sync"],
            fr: ["UI : Le bouton de victoire est 'CONTINUER'", "Correctif : Synchro compteur de vie"]
        }
    },
    {
        version: "1.8.2",
        date: "2023-11-29",
        features: {
            en: ["Fixed: Life counter UI sync delay", "Fixed: Game Over appearing with lives displayed"],
            fr: ["Correctif : D√©lai d'affichage du compteur de vies", "Correctif : Game Over apparaissant avec des vies restantes"]
        }
    },
    {
        version: "1.8.1",
        date: "2023-11-29",
        features: {
            en: ["Optimization: Relay Anti-Qix Zone visuals", "Fixed: Relay spawn logic in lower levels", "Balanced: Repulsion force smoothed"],
            fr: ["Optimisation : Visuels de la Zone Anti-Qix", "Correctif : Apparition des Relais niveaux bas", "√âquilibrage : Force de r√©pulsion adoucie"]
        }
    },
    {
        version: "1.8.0",
        date: "2023-11-28",
        features: {
            en: ["NEW RELAY MECHANIC: Overcharge Battery!", "Connect or Capture a Relay to trigger Anti-Qix Zone", "Electric Arc repels enemies for 8 seconds"],
            fr: ["NOUVEAU RELAIS : Batterie de Surcharge !", "Connectez ou Capturez un Relais pour activer la Zone Anti-Qix", "Un arc √©lectrique repousse les ennemis pendant 8 secondes"]
        }
    }
];

const STRINGS = {
    en: {
        hud_hi: "HI", hud_scr: "SCR", mode_slow: "SLOW", mode_turbo: "TURBO",
        audio_on: "AUDIO ON", audio_off: "AUDIO OFF",
        boss_warning: "WARNING\nBOSS APPROACHING", hunter_warning: "‚ö† HUNTER SPAWNED ‚ö†",
        tutorial: "D-PAD to Move<br>HOLD TURBO for Speed<br>SPACE: SHOOT | X: BLAST",
        title_main: "TWIX XL", subtitle_main: "PC: Arrows | Mobile: D-Pad | 4x LARGER WORLD",
        btn_play: "INSERT COIN", btn_continue: "CONTINUE", btn_shop: "SHOP üõí",
        shop_title: "SHOP", shop_balance: "SCORE:", btn_back: "BACK",
        btn_resume: "RESUME", btn_newgame: "NEW GAME", btn_menu: "MENU",
        title_paused: "PAUSED", subtitle_paused: "Press P or Button to Resume",
        title_gameover: "GAME OVER", title_win: "LEVEL CLEARED!",
        score_total: "Total Score:", score_final: "Final Score:",
        level_prefix: "LEVEL ", level_done: " (DONE)",
        rules_title: "GAME RULES", btn_gotit: "GOT IT!",
        menu_pause: "PAUSE", menu_resume: "RESUME", menu_menu: "HOME", 
        menu_audio: "AUDIO", menu_screen: "SCREEN", menu_rules: "RULES", menu_news: "NEWS",
        item_life_name: "EXTRA LIFE", item_life_desc: "+1 Life",
        item_speed_name: "SPEED", item_speed_desc: "+10% Speed",
        item_shield_name: "SHIELD", item_shield_desc: "+2s Duration",
        item_time_name: "TEMPS", item_time_desc: "Delay Super Sparx",
        item_lucky_name: "LUCKY", item_lucky_desc: "Spawn Bonus x2",
        item_greed_name: "GREED", item_greed_desc: "Score +20%",
        item_sabotage_name: "SABOTAGE", item_sabotage_desc: "Slow Sparx",
        item_decoy_name: "DECOY", item_decoy_desc: "Start with Decoy",
        item_sweeper_name: "SWEEPER", item_sweeper_desc: "Clear all mines",
        item_alchemy_name: "ALCHEMY", item_alchemy_desc: "Mines = Gold",
        item_stun_name: "MISSILE", item_stun_desc: "Stun Shot (Space)",
        item_repulsor_name: "REPULSOR", item_repulsor_desc: "Push Back (X)",
        float_speed: "+10% SPEED", float_shield: "+2s SHIELD", float_time: "+20% TIME",
        float_chance: "LUCK ++", float_score: "SCORE +20%", float_slow: "SPARX SLOWED",
        float_decoy_bought: "DECOY BOUGHT", float_sweeper: "SWEEPER READY", float_alchemy: "ALCHEMY READY",
        float_missile: "MISSILE EQUIPPED", float_repulsor: "WAVE EQUIPPED",
        float_decoy_active: "DECOY ACTIVE", float_mines_cleared: "MINES CLEARED!",
        float_gold_mines: "GOLD MINES!", float_zap: "ZAP! -X SPARX", float_stunned: "STUNNED!",
        float_repulsor_active: "REPULSOR!", float_multi: "MULTI-CAPTURE! x",
        bonus_shield: "üõ°Ô∏è SHIELD ", bonus_speed: "‚ö° SPEED ", bonus_freeze: "‚ùÑÔ∏è FREEZE ", bonus_decoy: "üéØ DECOY ",
        float_chain: "CHAIN EXPLOSION!", float_relay: "RELAYS CONNECTED!", float_snap: "SNAP!",
        float_warp: "WARP!", float_rhythm: "RHYTHM COMBO!",
        rules_html: `<h3>OBJECTIVE</h3><ul><li>Conquer <strong>75%</strong> of the area.</li><li>Chain captures quickly for <strong>RHYTHM COMBOS</strong> (Rainbow fill & 2x Score)!</li></ul><h3>CONTROLES</h3><ul><li><strong>Move:</strong> Arrows / D-Pad.</li><li><strong>Turbo:</strong> Shift / Button (Fast but risky).</li><li><strong>Skills:</strong> Space (Shoot), X (Repulsor) - <em>Buy in Shop</em>.</li><li><strong>Warp:</strong> Enter Blue Portals to teleport.</li></ul><h3>ENEMIES</h3><ul><li><strong>QIX (Boss):</strong> Don't touch! It learns to use Portals.</li><li><strong>SPARX:</strong> Patrol walls. Lethal.</li><li><strong>MOLE (Brown):</strong> EATS your territory! Crush it quickly.</li><li><strong>PULSAR (Yellow Star):</strong> Pushes you away with shockwaves.</li><li><strong>TESLA (Cyan Orb):</strong> Zaps you! Not lethal, but <strong>-10,000 PTS</strong>.</li></ul><h3>TACTICS</h3><ul><li><strong>Mines:</strong> Capture to trigger a massive chain explosion.</li><li><strong>Relays (‚ö°):</strong> Connect or Capture to trigger <strong>Anti-Qix Zone</strong> (8s protection).</li><li><strong>Magnet:</strong> Release controls near a wall to snap automatically.</li></ul>`
    },
    fr: {
        hud_hi: "HI", hud_scr: "SCR", mode_slow: "LENT", mode_turbo: "TURBO",
        audio_on: "SON ON", audio_off: "SON OFF",
        boss_warning: "ATTENTION\nBOSS EN APPROCHE", hunter_warning: "‚ö† CHASSEUR EN VUE ‚ö†",
        tutorial: "D-PAD pour Bouger<br>MAINTENIR TURBO : Vitesse<br>ESPACE: TIR | X: ONDE",
        title_main: "TWIX XL", subtitle_main: "PC : Fl√®ches | Mobile : D-Pad | MONDE G√âANT (4x)",
        btn_play: "JOUER", btn_continue: "CONTINUER", btn_shop: "BOUTIQUE üõí",
        shop_title: "BOUTIQUE", shop_balance: "SCORE:", btn_back: "RETOUR",
        btn_resume: "REPRENDRE", btn_newgame: "NOUVELLE PARTIE", btn_menu: "MENU",
        title_paused: "PAUSE", subtitle_paused: "Touche P ou Bouton pour Reprendre",
        title_gameover: "PERDU", title_win: "NIVEAU TERMIN√â !",
        score_total: "Score Total :", score_final: "Score Final :",
        level_prefix: "NIVEAU ", level_done: " (FAIT)",
        rules_title: "R√àGLES DU JEU", btn_gotit: "COMPRIS !",
        menu_pause: "PAUSE", menu_resume: "REPRENDRE", menu_menu: "ACCUEIL", 
        menu_audio: "AUDIO", menu_screen: "ECRAN", menu_rules: "R√àGLES", menu_news: "INFOS",
        item_life_name: "VIE EXTRA", item_life_desc: "+1 Vie",
        item_speed_name: "VITESSE", item_speed_desc: "+10% Vitesse",
        item_shield_name: "BOUCLIER", item_shield_desc: "+2s Dur√©e",
        item_time_name: "TEMPS", item_time_desc: "Retard Super Sparx",
        item_lucky_name: "CHANCEUX", item_lucky_desc: "Spawn Bonus x2",
        item_greed_name: "MULTIPLICATEUR", item_greed_desc: "Score +20%",
        item_sabotage_name: "SABOTAGE", item_sabotage_desc: "Sparx Ralentis",
        item_decoy_name: "LEURRE", item_decoy_desc: "D√©marre avec un Leurre",
        item_sweeper_name: "D√âMINEUR", item_sweeper_desc: "D√©truit toutes les mines",
        item_alchemy_name: "ALCHIMISTE", item_alchemy_desc: "Mines = Or (+Score)",
        item_stun_name: "MISSILE", item_stun_desc: "Tir paralysant (Espace)",
        item_repulsor_name: "ONDE CHOC", item_repulsor_desc: "Repousse Tout (X)",
        float_speed: "+10% VITESSE", float_shield: "+2s BOUCLIER", float_time: "+20% TEMPS",
        float_chance: "CHANCE ++", float_score: "SCORE +20%", float_slow: "SPARX RALENTIS",
        float_decoy_bought: "LEURRE ACHET√â", float_sweeper: "D√âMINEUR PR√äT", float_alchemy: "ALCHIMIE PR√äTE",
        float_missile: "MISSILE √âQUIP√â", float_repulsor: "ONDE √âQUIP√âE",
        float_decoy_active: "LEURRE ACTIF", float_mines_cleared: "MINES D√âTRUITES!",
        float_gold_mines: "MINES EN OR !", float_zap: "ZAP! -X SPARX", float_stunned: "PARALYS√â !",
        float_repulsor_active: "REPULSOR !", float_multi: "MULTI-CAPTURE ! x",
        bonus_shield: "üõ°Ô∏è BOUCLIER ", bonus_speed: "‚ö° VITESSE ", bonus_freeze: "‚ùÑÔ∏è GEL ", bonus_decoy: "üéØ LEURRE ",
        float_chain: "EXPLOSION EN CHAINE !", float_relay: "RELAIS CONNECT√âS !", float_snap: "AIMANT !",
        float_warp: "WARP!", float_rhythm: "COMBO RYTHMIQUE !",
        rules_html: `<h3>OBJECTIF</h3><ul><li>Conqu√©rez <strong>75%</strong> of the area.</li><li>Encha√Ænez vite les captures pour un <strong>COMBO RYTHMIQUE</strong> (Arc-en-ciel & Score x2) !</li></ul><h3>CONTROLES</h3><ul><li><strong>Bouger :</strong> Fl√®ches / D-Pad.</li><li><strong>Turbo :</strong> Maj / Bouton (Rapide mais risqu√©).</li><li><strong>Skills :</strong> Espace (Tir), X (Onde) - <em>Acheter en Boutique</em>.</li><li><strong>Portails :</strong> Entrez pour vous t√©l√©porter.</li></ul><h3>ENNEMIS</h3><ul><li><strong>QIX (Boss) :</strong> √âvitez-le ! Il peut utiliser les portails.</li><li><strong>SPARX :</strong> Patrouillent les murs. Mortels.</li><li><strong>TAUPE (Marron) :</strong> MANGE votre territoire ! √âcrasez-la vite.</li><li><strong>PULSAR (√âtoile) :</strong> Vous repousse avec des ondes de choc.</li><li><strong>TESLA (Orbe Cyan) :</strong> Vous √©lectrocute ! Pas mortel, mais <strong>-10 000 PTS</strong>.</li></ul><h3>TACTIQUES</h3><ul><li><strong>Mines :</strong> Capturez pour d√©clencher une explosion en cha√Æne.</li><li><strong>Relays (‚ö°) :</strong> Connectez ou Capturez pour activer la <strong>Zone Anti-Qix</strong> (8s protection).</li><li><strong>Aimant :</strong> L√¢chez les contr√¥les pr√®s d'un mur pour fermer automatiquement.</li></ul>`
    }
};

const THEMES = [
    { name: "Synth City", uiColor: '#101', bg: [0, 0, 0, 255], wall: [255, 255, 255, 255], fillSlow: [200, 50, 0, 255], fillFast: [0, 0, 200, 255], trailSlow: [255, 100, 0, 255], trailFast: [0, 150, 255, 255], player: '#00ff00', qixBase: 0, grid: [255, 0, 255] },
    { name: "Cyber Circuit", uiColor: '#002', bg: [0, 20, 0, 255], wall: [0, 255, 255, 255], fillSlow: [255, 0, 128, 255], fillFast: [100, 0, 200, 255], trailSlow: [255, 100, 200, 255], trailFast: [150, 255, 255, 255], player: '#ffff00', qixBase: 120, grid: [0, 255, 255] },
    { name: "Nebula", uiColor: '#000', bg: [10, 10, 20, 255], wall: [100, 100, 255, 255], fillSlow: [200, 0, 200, 255], fillFast: [0, 200, 200, 255], trailSlow: [255, 0, 255, 255], trailFast: [0, 255, 255, 255], player: '#ff00ff', qixBase: 200, grid: [100, 100, 255] },
    { name: "Op Art", uiColor: '#222', bg: [240, 240, 240, 255], wall: [0, 0, 0, 255], fillSlow: [50, 50, 50, 255], fillFast: [180, 180, 180, 255], trailSlow: [0, 0, 0, 255], trailFast: [100, 100, 100, 255], player: '#ff0000', qixBase: 0, grid: [0, 0, 0] },
    { name: "BOSS I: CORE", uiColor: '#300', bg: [20, 0, 0, 255], wall: [255, 0, 0, 255], fillSlow: [100, 0, 0, 255], fillFast: [200, 50, 0, 255], trailSlow: [255, 100, 0, 255], trailFast: [255, 255, 0, 255], player: '#00ffff', qixBase: 0, grid: [255, 50, 0] },
    
    // NOUVEAUX THEMES (Cycle 6-10)
    { name: "Deep Ocean", uiColor: '#001', bg: [0, 0, 30, 255], wall: [0, 100, 255, 255], fillSlow: [0, 100, 100, 255], fillFast: [0, 0, 150, 255], trailSlow: [0, 255, 255, 255], trailFast: [0, 100, 255, 255], player: '#ff0080', qixBase: 180, grid: [0, 50, 150] },
    { name: "Volcano", uiColor: '#210', bg: [30, 10, 0, 255], wall: [255, 150, 0, 255], fillSlow: [150, 50, 0, 255], fillFast: [100, 0, 0, 255], trailSlow: [255, 255, 0, 255], trailFast: [255, 50, 50, 255], player: '#00ff00', qixBase: 30, grid: [255, 100, 0] },
    { name: "Matrix", uiColor: '#010', bg: [0, 10, 0, 255], wall: [0, 255, 0, 255], fillSlow: [0, 50, 0, 255], fillFast: [0, 100, 0, 255], trailSlow: [150, 255, 150, 255], trailFast: [200, 255, 200, 255], player: '#ffffff', qixBase: 120, grid: [0, 150, 0] },
    { name: "Golden Age", uiColor: '#220', bg: [20, 20, 0, 255], wall: [255, 215, 0, 255], fillSlow: [100, 80, 0, 255], fillFast: [255, 255, 255, 255], trailSlow: [255, 255, 0, 255], trailFast: [255, 255, 200, 255], player: '#000000', qixBase: 60, grid: [200, 180, 0] },
    { name: "BOSS II: VOID", uiColor: '#111', bg: [255, 255, 255, 255], wall: [0, 0, 0, 255], fillSlow: [50, 0, 50, 255], fillFast: [100, 0, 100, 255], trailSlow: [255, 0, 0, 255], trailFast: [0, 0, 255, 255], player: '#000000', qixBase: 0, grid: [100, 100, 100] }
];

const SHOP_PRICES = { life: 50000, speed: 25000, shield: 15000, time: 20000, lucky: 30000, greed: 37500, sabotage: 27500, decoy: 22500, sweeper: 25000, alchemy: 40000, stun: 35000, repulsor: 27500 };

const POWERUPS = { 
    FREEZE: { type: 'FREEZE', color: '#0ff', icon: '‚ùÑÔ∏è', duration: 300 }, 
    SPEED: { type: 'SPEED', color: '#ff0', icon: '‚ö°', duration: 600 }, 
    SHIELD: { type: 'SHIELD', color: '#0f0', icon: 'üõ°Ô∏è', duration: Infinity },
    ZAP: { type: 'ZAP', color: '#f0f', icon: 'üå©Ô∏è', duration: 0 },
    DECOY: { type: 'DECOY', color: '#ff00ff', icon: 'üéØ', duration: 480 }
};

// --- WEB WORKER CODE ---
const WORKER_CODE = `
self.onmessage = function(e) {
    const { gridBuffer, worldWidth, worldHeight, trailPoints, qixEntities, trailRelaysCount } = e.data;
    const grid = new Uint8Array(gridBuffer);
    const WORLD_WIDTH = worldWidth;
    const WORLD_HEIGHT = worldHeight;
    const T_EMPTY = 0, T_WALL = 1, T_TRAIL = 2, T_FILLED_BLUE = 3, T_FILLED_RED = 4, T_FLASH = 5, T_MINE = 6, T_ELECTRIC_WALL = 8, T_FILLED_RAINBOW = 9;

    let wallType = T_WALL;
    if (trailRelaysCount >= 2) wallType = T_ELECTRIC_WALL;

    for (let p of trailPoints) {
        if (p.x >= 0 && p.x < WORLD_WIDTH && p.y >= 0 && p.y < WORLD_HEIGHT) {
            grid[p.y * WORLD_WIDTH + p.x] = wallType;
        }
    }

    let visited = new Uint8Array(WORLD_WIDTH * WORLD_HEIGHT);
    let qixStack = [];
    
    if (qixEntities.length > 0) {
        let q1 = qixEntities[0];
        let qx = Math.floor(q1.x); let qy = Math.floor(q1.y);
        let idx = qx + qy * WORLD_WIDTH;
        if (qx >= 0 && qx < WORLD_WIDTH && qy >= 0 && qy < WORLD_HEIGHT) {
            qixStack.push(idx);
            visited[idx] = 1;
        }
    }

    while (qixStack.length > 0) {
        let idx = qixStack.pop();
        let cx = idx % WORLD_WIDTH;
        let cy = Math.floor(idx / WORLD_WIDTH);
        
        if (cy > 0) { let nIdx = idx - WORLD_WIDTH; if (visited[nIdx] === 0 && (grid[nIdx] === T_EMPTY || grid[nIdx] === T_MINE)) { visited[nIdx] = 1; qixStack.push(nIdx); } }
        if (cy < WORLD_HEIGHT - 1) { let nIdx = idx + WORLD_WIDTH; if (visited[nIdx] === 0 && (grid[nIdx] === T_EMPTY || grid[nIdx] === T_MINE)) { visited[nIdx] = 1; qixStack.push(nIdx); } }
        if (cx > 0) { let nIdx = idx - 1; if (visited[nIdx] === 0 && (grid[nIdx] === T_EMPTY || grid[nIdx] === T_MINE)) { visited[nIdx] = 1; qixStack.push(nIdx); } }
        if (cx < WORLD_WIDTH - 1) { let nIdx = idx + 1; if (visited[nIdx] === 0 && (grid[nIdx] === T_EMPTY || grid[nIdx] === T_MINE)) { visited[nIdx] = 1; qixStack.push(nIdx); } }
    }

    let bonusSplit = false;
    if (qixEntities.length > 1) {
        let q2 = qixEntities[1];
        let q2Idx = Math.floor(q2.x) + Math.floor(q2.y) * WORLD_WIDTH;
        if (visited[q2Idx] === 0) bonusSplit = true;
    }

    let capturedIndices = [];
    let capturedMask = new Uint8Array(WORLD_WIDTH * WORLD_HEIGHT); 
    let capturedRegionsCount = 0;

    for (let i = 0; i < grid.length; i++) {
        if (visited[i] === 0 && (grid[i] === T_EMPTY || grid[i] === T_MINE)) {
            if (capturedMask[i] === 0) {
                capturedRegionsCount++;
                let rStack = [i];
                capturedMask[i] = 1;
                capturedIndices.push(i);

                while(rStack.length > 0) {
                    let idx = rStack.pop();
                    let cx = idx % WORLD_WIDTH;
                    let cy = Math.floor(idx / WORLD_WIDTH);

                    if (cy > 0) { let nIdx = idx - WORLD_WIDTH; if(visited[nIdx] === 0 && capturedMask[nIdx] === 0 && (grid[nIdx]===T_EMPTY || grid[nIdx]===T_MINE)) { capturedMask[nIdx]=1; capturedIndices.push(nIdx); rStack.push(nIdx); } }
                    if (cy < WORLD_HEIGHT - 1) { let nIdx = idx + WORLD_WIDTH; if(visited[nIdx] === 0 && capturedMask[nIdx] === 0 && (grid[nIdx]===T_EMPTY || grid[nIdx]===T_MINE)) { capturedMask[nIdx]=1; capturedIndices.push(nIdx); rStack.push(nIdx); } }
                    if (cx > 0) { let nIdx = idx - 1; if(visited[nIdx] === 0 && capturedMask[nIdx] === 0 && (grid[nIdx]===T_EMPTY || grid[nIdx]===T_MINE)) { capturedMask[nIdx]=1; capturedIndices.push(nIdx); rStack.push(nIdx); } }
                    if (cx < WORLD_WIDTH - 1) { let nIdx = idx + 1; if(visited[nIdx] === 0 && capturedMask[nIdx] === 0 && (grid[nIdx]===T_EMPTY || grid[nIdx]===T_MINE)) { capturedMask[nIdx]=1; capturedIndices.push(nIdx); rStack.push(nIdx); } }
                }
            }
        }
    }

    for (let idx of capturedIndices) {
        grid[idx] = T_FLASH;
    }

    self.postMessage({
        gridBuffer: grid.buffer,
        capturedIndices: capturedIndices,
        bonusSplit: bonusSplit,
        capturedRegionsCount: capturedRegionsCount,
        visitedBuffer: visited.buffer 
    }, [grid.buffer, visited.buffer]);
};
`;

// --- MENU CONTROLLER FOR ELEGANT DPAD NAV ---
const MenuNav = {
    timer: 0,
    targets: [],
    index: 0,
    active: false,
    
    init: function() { this.targets = []; this.index = 0; this.timer = 0; },
    
    refresh: function() {
        document.querySelectorAll('.ui-selected').forEach(el => el.classList.remove('ui-selected'));
        this.targets = [];
        let defaultIndex = 0;
        
        if (document.getElementById('shop-overlay').style.display === 'flex') {
            const items = Array.from(document.querySelectorAll('.shop-item:not(.disabled)'));
            this.targets = [...items, document.getElementById('btn-shop-back')];
        } else if (document.getElementById('rules-overlay').style.display === 'flex') {
            this.targets = [document.getElementById('btn-rules-back')];
        } else if (document.getElementById('news-overlay').style.display === 'flex') {
            this.targets = [document.getElementById('btn-news-close')];
        } else if (document.getElementById('settings-panel').style.display === 'flex') {
            this.targets = [
                document.getElementById('nav-btn-resume'), document.getElementById('nav-btn-menu'),
                document.getElementById('nav-btn-audio'), document.getElementById('nav-btn-screen'),
                document.getElementById('nav-btn-lang'), document.getElementById('nav-btn-rules'),
                document.getElementById('nav-btn-news')
            ];
        } else if (document.getElementById('message-overlay').style.display === 'flex') {
            this.targets = [document.getElementById('settings-toggle'), document.getElementById('action-btn')];
            const shopBtn = document.getElementById('shop-btn');
            if (shopBtn.style.display !== 'none') this.targets.push(shopBtn);
            defaultIndex = 1;
        } else if (document.getElementById('pause-overlay').style.display === 'flex') {
            this.targets = [document.getElementById('settings-toggle'), document.getElementById('btn-resume')];
            defaultIndex = 1;
        }

        this.index = (defaultIndex < this.targets.length) ? defaultIndex : 0;
        this.active = this.targets.length > 0;
        if (this.active) this.highlight();
    },

    update: function() {
        if (!this.active || this.targets.length === 0) return;
        
        if (this.timer > 0) { this.timer--; return; }

        let dx = 0; let dy = 0;
        if (keys.ArrowUp) dy = -1;
        else if (keys.ArrowDown) dy = 1;
        
        if (keys.ArrowLeft) dx = -1;
        else if (keys.ArrowRight) dx = 1;

        if (keys.Shift || kbState.Enter || kbState.Space) {
            this.trigger();
            this.timer = 20;
            return;
        }

        if (dx !== 0 || dy !== 0) {
            const isShop = document.getElementById('shop-grid').contains(this.targets[0]);
            const isSettings = document.getElementById('settings-panel').style.display === 'flex';
            
            if (isShop && dy !== 0) {
                let next = this.index + (dy * 3);
                if (next >= 0 && next < this.targets.length) this.index = next;
                else if (dy > 0 && this.targets[this.targets.length-1].id === 'btn-shop-back') this.index = this.targets.length - 1; 
            } else if (isSettings && dy !== 0) {
                let next = this.index + (dy * 2);
                if (next >= 0 && next < this.targets.length) {
                    this.index = next;
                } else if (dy > 0 && next >= this.targets.length && this.targets.length % 2 !== 0 && this.index === this.targets.length - 1) {
                }
            } else {
                const isMainMenu = document.getElementById('message-overlay').style.display === 'flex';
                if (isMainMenu && this.targets[this.index].id === 'action-btn' && dx !== 0) {
                    adjustStartLevel(dx);
                    this.timer = 10;
                    return;
                }

                let move = dy !== 0 ? dy : dx;
                let next = this.index + move;
                if (next >= 0 && next < this.targets.length) {
                    this.index = next;
                }
            }
            this.highlight();
            this.timer = 15;
            AudioController.playTick();
        }
    },

    highlight: function() {
        document.querySelectorAll('.ui-selected').forEach(el => el.classList.remove('ui-selected'));
        if (this.targets[this.index]) {
            this.targets[this.index].classList.add('ui-selected');
            this.targets[this.index].scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    },

    trigger: function() {
        if (this.targets[this.index]) {
            this.targets[this.index].click();
            AudioController.playShoot();
            setTimeout(() => this.refresh(), 50); 
        }
    }
};

const VersionManager = {
    init: function() {
        const lastVer = localStorage.getItem('qix_last_version');
        const updateIndicator = document.getElementById('update-indicator');
        if (lastVer && lastVer !== GAME_VERSION) {
            this.migrateData(lastVer);
            if (updateIndicator) updateIndicator.style.display = 'inline-block';
            this.showNews();
        } else if (!lastVer) {
            localStorage.setItem('qix_last_version', GAME_VERSION);
        }
        document.getElementById('main-menu-version').innerText = "v" + GAME_VERSION;
        document.getElementById('settings-version').innerText = "VERSION: " + GAME_VERSION;
    },
    migrateData: function(oldVer) { localStorage.setItem('qix_last_version', GAME_VERSION); },
    showNews: function() {
        const overlay = document.getElementById('news-overlay');
        const content = document.getElementById('news-content');
        const title = document.getElementById('news-title');
        title.innerText = (currentLang === 'fr') ? "QUOI DE NEUF ?" : "WHAT'S NEW";
        document.getElementById('btn-news-close').innerText = (currentLang === 'fr') ? "SUPER !" : "AWESOME";
        let html = '';
        CHANGELOG.forEach((log, index) => {
            if (index > 2) return; 
            const isNew = log.version === GAME_VERSION;
            const badge = isNew ? `<span class="news-new-badge">NEW</span>` : '';
            const feats = log.features[currentLang] || log.features['en'];
            html += `<div class="news-entry"><div class="news-version">v${log.version} ${badge} <span class="news-date">${log.date}</span></div><ul class="news-list">${feats.map(f => `<li>${f}</li>`).join('')}</ul></div>`;
        });
        content.innerHTML = html;
        document.getElementById('settings-panel').style.display = 'none'; document.getElementById('message-overlay').style.display = 'none'; overlay.style.display = 'flex';
        const updateIndicator = document.getElementById('update-indicator'); if (updateIndicator) updateIndicator.style.display = 'none';
        MenuNav.refresh();
    },
    closeNews: function() { document.getElementById('news-overlay').style.display = 'none'; document.getElementById('message-overlay').style.display = 'flex'; MenuNav.refresh(); }
};

let currentLang = 'en';

function toggleLanguage() { currentLang = currentLang === 'en' ? 'fr' : 'en'; updateTexts(); MenuNav.refresh(); }
function t(key) { return STRINGS[currentLang][key] || key; }
function toggleSettings() { 
    const panel = document.getElementById('settings-panel'); 
    if(panel.style.display === 'flex') { 
        panel.style.display = 'none'; 
        if(isPaused && gameState === 'PLAYING') togglePause(); 
    } else { 
        panel.style.display = 'flex'; 
        if(!isPaused && gameState === 'PLAYING') togglePause(); 
    } 
    updateTexts(); 
    MenuNav.refresh();
}
function togglePauseAndMenu() { togglePause(); document.getElementById('settings-panel').style.display = 'none'; MenuNav.refresh(); }
function returnToMenu() {
    gameState = 'MENU';
    document.getElementById('settings-panel').style.display = 'none'; document.getElementById('message-overlay').style.display = 'flex';
    document.getElementById('shop-overlay').style.display = 'none'; document.getElementById('rules-overlay').style.display = 'none';
    document.getElementById('pause-overlay').style.display = 'none'; isPaused = false; document.getElementById('news-overlay').style.display = 'none';
    const titleNode = document.getElementById('message-title');
    titleNode.innerHTML = `<div class="title-sparx"></div><div class="title-sparx" style="animation-delay: -1.5s;"></div>${t('title_main')}`;
    
    // FIX: R√©tablissement du bouton boutique
    document.getElementById('shop-btn').style.display = 'inline-block'; 
    document.getElementById('level-selector').style.display = 'flex';
    
    updateTexts();
    MenuNav.refresh();
}

function updateTexts() {
    document.getElementById('m_pause').innerText = isPaused ? t('menu_resume') : t('menu_pause'); document.getElementById('m_menu').innerText = t('menu_menu');
    document.getElementById('m_snd').innerText = t('menu_audio'); document.getElementById('m_fs').innerText = t('menu_screen');
    document.getElementById('m_rules').innerText = t('menu_rules'); document.getElementById('m_lang').innerText = "LANG: " + (currentLang === 'en' ? 'EN' : 'FR');
    document.getElementById('m_news').innerText = t('menu_news');
    const isMuted = AudioController.muted;
    document.getElementById('m_snd_icon').innerText = isMuted ? "üîá" : "üîä"; document.getElementById('audio-status').innerText = isMuted ? t('audio_off') : t('audio_on');
    updateModeIndicator();
    document.getElementById('tutorial-overlay').innerHTML = t('tutorial');
    const titleNode = document.getElementById('message-title'); const sparx = titleNode.getElementsByClassName('title-sparx');
    if(sparx.length > 0) { titleNode.childNodes[2].textContent = t('title_main'); }
    document.getElementById('message-subtitle').innerText = t('subtitle_main'); document.getElementById('shop-btn').innerText = t('btn_shop');
    updateLevelSelectorUI(); 
    document.getElementById('pause-title').innerText = t('title_paused'); document.getElementById('pause-subtitle').innerText = t('subtitle_paused');
    document.getElementById('btn-resume').innerText = t('btn_resume');
    document.getElementById('shop-title').innerText = t('shop_title'); document.getElementById('shop-balance').innerHTML = t('shop_balance') + ' <span id="shop-score-display">' + score + '</span>';
    document.getElementById('btn-shop-back').innerText = t('btn_back');
    document.getElementById('n_life').innerText = t('item_life_name'); document.getElementById('d_life').innerText = t('item_life_desc');
    document.getElementById('n_speed').innerText = t('item_speed_name'); document.getElementById('d_speed').innerText = t('item_speed_desc');
    document.getElementById('n_shield').innerText = t('item_shield_name'); document.getElementById('d_shield').innerText = t('item_shield_desc');
    document.getElementById('n_time').innerText = t('item_time_name'); document.getElementById('d_time').innerText = t('item_time_desc');
    document.getElementById('n_lucky').innerText = t('item_lucky_name'); document.getElementById('d_lucky').innerText = t('item_lucky_desc');
    document.getElementById('n_greed').innerText = t('item_greed_name'); document.getElementById('d_greed').innerText = t('item_greed_desc');
    document.getElementById('n_sabotage').innerText = t('item_sabotage_name'); document.getElementById('d_sabotage').innerText = t('item_sabotage_desc');
    document.getElementById('n_decoy').innerText = t('item_decoy_name'); document.getElementById('d_decoy').innerText = t('item_decoy_desc');
    document.getElementById('n_sweeper').innerText = t('item_sweeper_name'); document.getElementById('d_sweeper').innerText = t('item_sweeper_desc');
    document.getElementById('n_alchemy').innerText = t('item_alchemy_name'); document.getElementById('d_alchemy').innerText = t('item_alchemy_desc');
    document.getElementById('n_stun').innerText = t('item_stun_name'); document.getElementById('d_stun').innerText = t('item_stun_desc');
    document.getElementById('n_repulsor').innerText = t('item_repulsor_name'); document.getElementById('d_repulsor').innerText = t('item_repulsor_desc');
    document.getElementById('rules-title').innerText = t('rules_title'); document.getElementById('rules-content').innerHTML = t('rules_html');
    document.getElementById('btn-rules-back').innerText = t('btn_gotit');
    document.getElementById('main-menu-version').innerText = "v" + GAME_VERSION;
    document.getElementById('settings-version').innerText = "VERSION: " + GAME_VERSION;
    updateBonusUI();
}

function toggleFullScreen() { if (!document.fullscreenElement) enterFullScreen(); else exitFullScreen(); }
function enterFullScreen() { const el = document.documentElement; let p; if (el.requestFullscreen) p = el.requestFullscreen(); else if (el.webkitRequestFullscreen) p = el.webkitRequestFullscreen(); if(p) p.catch(e => console.warn(e)); }
function exitFullScreen() { let p; if (document.exitFullscreen) p = document.exitFullscreen(); else if (document.webkitExitFullscreen) p = document.webkitExitFullscreen(); if(p) p.catch(e => console.warn(e)); }
function toggleSound() { if (!AudioController.initialized) AudioController.init(); const isMuted = AudioController.toggleMute(); document.getElementById('audio-status').innerText = isMuted ? t('audio_off') : t('audio_on'); updateTexts(); }

const AudioController = {
    ctx: null, qixOsc: null, qixGain: null, drawOsc: null, drawGain: null, initialized: false,
    masterFilter: null, 
    nextNoteTime: 0, noteIndex: 0, tempo: 110, baseTempo: 110, isMusicPlaying: false, muted: false,
    init: function() {
        if (this.initialized) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.masterFilter = this.ctx.createBiquadFilter(); this.masterFilter.type = 'lowpass'; this.masterFilter.frequency.value = 22000; this.masterFilter.connect(this.ctx.destination);
        this.qixOsc = this.ctx.createOscillator(); this.qixOsc.type = 'sawtooth';
        this.qixGain = this.ctx.createGain(); this.qixGain.gain.value = 0;
        const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 200;
        this.qixOsc.connect(filter); filter.connect(this.qixGain); this.qixGain.connect(this.masterFilter); this.qixOsc.start();
        this.drawOsc = this.ctx.createOscillator(); this.drawOsc.type = 'square';
        this.drawGain = this.ctx.createGain(); this.drawGain.gain.value = 0;
        this.drawOsc.connect(this.drawGain); this.drawGain.connect(this.masterFilter); this.drawOsc.start();
        this.initialized = true; 
        if (this.muted) { this.qixGain.gain.value = 0; this.drawGain.gain.value = 0; }
    },
    toggleMute: function() { this.muted = !this.muted; if (this.muted) { this.stopQixHum(); if (this.drawGain) { this.drawGain.gain.cancelScheduledValues(this.ctx.currentTime); this.drawGain.gain.value = 0; } } return this.muted; },
    playTick: function() { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'square'; o.frequency.setValueAtTime(800, t); g.gain.setValueAtTime(0.05, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.05); o.start(t); o.stop(t + 0.05); },
    setTurboEffect: function(active) { if(!this.initialized) return; const targetFreq = active ? 600 : 22000; this.masterFilter.frequency.setTargetAtTime(targetFreq, this.ctx.currentTime, 0.1); },
    resume: function() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },
    suspend: function() { if (this.ctx && this.ctx.state === 'running') this.ctx.suspend(); },
    updateAudio: function(tension) { if (!this.initialized) return; const targetVol = this.muted ? 0 : (0.05 + (tension * 0.05)); const targetFreq = 60 + (tension * 240); this.qixOsc.frequency.setTargetAtTime(targetFreq, this.ctx.currentTime, 0.1); this.qixGain.gain.setTargetAtTime(targetVol, this.ctx.currentTime, 0.1); this.tempo = this.baseTempo + (tension * 40); if (this.isMusicPlaying) this.scheduler(); },
    startBGM: function() { if (!this.initialized) this.init(); if (this.isMusicPlaying) return; this.isMusicPlaying = true; this.nextNoteTime = this.ctx.currentTime + 0.1; this.noteIndex = 0; },
    stopBGM: function() { this.isMusicPlaying = false; this.stopQixHum(); },
    stopQixHum: function() { if (this.qixGain) this.qixGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1); },
    setDrawSound: function(active, fastMode) { if (!this.initialized || this.muted) return; if (active) { this.drawGain.gain.setTargetAtTime(0.05, this.ctx.currentTime, 0.02); this.drawOsc.frequency.setTargetAtTime(fastMode ? 300 : 100, this.ctx.currentTime, 0.02); } else { this.drawGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.02); } },
    scheduler: function() { while (this.nextNoteTime < this.ctx.currentTime + 0.1) { this.playPatternStep(this.nextNoteTime); this.advanceNote(); } },
    advanceNote: function() { const secondsPerBeat = 60.0 / this.tempo; this.nextNoteTime += 0.25 * secondsPerBeat; this.noteIndex++; if (this.noteIndex === 16) this.noteIndex = 0; },
    playPatternStep: function(time) {
        if (this.muted) return;
        const root = 65.41; let freq = 0; const pattern = [1, 0, 1, 0, 2, 0, 2, 0, 3, 0, 3, 0, 4, 3, 2, 1]; const note = pattern[this.noteIndex];
        if (note === 1) freq = root; else if (note === 2) freq = root * 1.189; else if (note === 3) freq = root * 1.498; else if (note === 4) freq = root * 2;
        if (freq > 0) { const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain(); osc.connect(gain); gain.connect(this.masterFilter); osc.type = 'sawtooth'; osc.frequency.value = freq; gain.gain.setValueAtTime(0.15, time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15); osc.start(time); osc.stop(time + 0.16); }
        if (this.noteIndex % 4 === 2) { const noise = this.ctx.createOscillator(); const nGain = this.ctx.createGain(); noise.type = 'square'; noise.frequency.value = 800; noise.connect(nGain); nGain.connect(this.masterFilter); nGain.gain.setValueAtTime(0.05, time); nGain.gain.exponentialRampToValueAtTime(0.001, time + 0.05); noise.start(time); noise.stop(time + 0.05); }
    },
    playCapture: function(combo) { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'triangle'; let p = 440 + (combo * 50); o.frequency.setValueAtTime(p, t); o.frequency.setValueAtTime(p*1.5, t+0.1); g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.4); o.start(t); o.stop(t+0.4); },
    playDie: function() { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'sawtooth'; o.frequency.setValueAtTime(800, t); o.frequency.exponentialRampToValueAtTime(50, t+0.5); g.gain.setValueAtTime(0.2, t); g.gain.linearRampToValueAtTime(0, t+0.5); o.start(t); o.stop(t+0.5); },
    playFuse: function() { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'square'; o.frequency.value = 1200; g.gain.setValueAtTime(0.05, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.08); o.start(t); o.stop(t+0.08); },
    playPowerUp: function() { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'sine'; o.frequency.setValueAtTime(600, t); o.frequency.linearRampToValueAtTime(1200, t+0.2); g.gain.setValueAtTime(0.1, t); g.gain.linearRampToValueAtTime(0, t+0.2); o.start(t); o.stop(t+0.2); },
    playSplit: function() { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'square'; o.frequency.setValueAtTime(220, t); o.frequency.linearRampToValueAtTime(880, t+0.3); g.gain.setValueAtTime(0.2, t); g.gain.linearRampToValueAtTime(0, t+1.0); o.start(t); o.stop(t+1.0); },
    playAlarm: function() { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'sawtooth'; o.frequency.setValueAtTime(800, t); o.frequency.linearRampToValueAtTime(400, t+0.3); g.gain.setValueAtTime(0.15, t); g.gain.linearRampToValueAtTime(0, t+0.3); o.start(t); o.stop(t+0.3); },
    playBossCharge: function() { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'square'; o.frequency.setValueAtTime(100, t); o.frequency.linearRampToValueAtTime(800, t+1.0); g.gain.setValueAtTime(0.1, t); g.gain.linearRampToValueAtTime(0, t+1.0); o.start(t); o.stop(t+1.0); },
    playBossShoot: function() { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'triangle'; o.frequency.setValueAtTime(1200, t); o.frequency.exponentialRampToValueAtTime(200, t+0.3); g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0, t+0.3); o.start(t); o.stop(t+0.3); },
    playHunterSpawn: function() { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'sawtooth'; o.frequency.setValueAtTime(200, t); o.frequency.linearRampToValueAtTime(50, t+0.5); g.gain.setValueAtTime(0.2, t); g.gain.linearRampToValueAtTime(0, t+0.5); o.start(t); o.stop(t+0.5); },
    playShoot: function() { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'square'; o.frequency.setValueAtTime(800, t); o.frequency.linearRampToValueAtTime(200, t+0.1); g.gain.setValueAtTime(0.1, t); g.gain.linearRampToValueAtTime(0, t+0.1); o.start(t); o.stop(t+0.1); },
    playRepulse: function() { if (!this.initialized || this.muted) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.connect(g); g.connect(this.masterFilter); o.type = 'sawtooth'; o.frequency.setValueAtTime(100, t); o.frequency.exponentialRampToValueAtTime(800, t+0.5); g.gain.setValueAtTime(0.3, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.5); o.start(t); o.stop(t+0.5); }
};

let currentTheme = THEMES[0];
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const terrainCanvas = document.createElement('canvas');
terrainCanvas.width = WORLD_WIDTH;
terrainCanvas.height = WORLD_HEIGHT;
const terrainCtx = terrainCanvas.getContext('2d');

// --- PERSISTENCE RESTORED ---
let currentRunLives = parseInt(localStorage.getItem('qix_run_lives')) || 3;
let currentRunScore = parseInt(localStorage.getItem('qix_run_score')) || 0;
let highScore = parseInt(localStorage.getItem('qix_hiscore_v2')) || 0;
let completedLevels = JSON.parse(localStorage.getItem('qix_completed')) || [];
let runUpgrades = JSON.parse(localStorage.getItem('qix_run_upgrades')) || { 
    speed: 1.0, shield: 0, time: 1.0, lucky: 1.0, greed: 1.0, sabotage: 1.0, 
    hasDecoy: false, hasSweeper: false, hasAlchemy: false, hasStun: false, hasRepulsor: false 
};

let grid = new Uint8Array(WORLD_WIDTH * WORLD_HEIGHT);
let gameState = 'MENU'; 
let lives = currentRunLives; 
let score = currentRunScore; 
let level = 1; let startLevel = 1;

document.getElementById('high-score').innerText = highScore;
document.getElementById('lives').innerText = lives;
document.getElementById('score').innerText = score;

let currentQixSpeed = BASE_QIX_SPEED;
let filledPixels = 0; let totalPixels = WORLD_WIDTH * WORLD_HEIGHT; let respawnTimer = 0;
let levelTime = 0; let maxLevelTime = 0; let superSparx = []; 
let comboCount = 0; let comboTimer = 0; const COMBO_WINDOW = 180; 
let isPaused = false;
let timeSinceLastCapture = 0;
let shakeIntensity = 0; 
let camera = { x: 0, y: 0, width: VIEW_WIDTH, height: VIEW_HEIGHT };
let floatingTexts = []; 
let decoy = { active: false, x: 0, y: 0, timer: 0 };
let shockwave = { active: false, x: 0, y: 0, radius: 0 }; 

let player = { x: 0, y: 0, dx: 0, dy: 0, isDrawing: false, drawMode: 'SLOW', shield: false, speedBoostTimer: 0, facing: {x: 0, y: -1}, history: [], idleTimer: 0, lastX: 0, lastY: 0, antiQixTimer: 0 };
let globalEffects = { freezeTimer: 0 };
let activePowerUp = null; let powerUpSpawnTimer = 0;
let qixEntities = []; let sparx = []; let mines = []; let projectiles = []; let trailPoints = []; let particles = []; let flashAnimations = []; let fuse = { active: false, timer: 0, index: 0, visibleTimer: 0 };
let playerProjectiles = [];
let relays = []; let currentTrailRelays = []; let portalPairs = []; let portalCooldown = 0; let prisoners = []; let moles = []; let pulsars = []; let teslas = []; let lastCaptureTimestamp = 0; 

let winParticles = [];
let fireworks = [];
let winAnimTimer = 0;
let splashTimer = 0;

let hunter = { active: false, x: 0, y: 0 };

let kbState = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Shift: false, Enter: false, Space: false };
let touchState = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Shift: false };
let gpState = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Shift: false, Pause: false };
let virtualState = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Shift: false }; 
let keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Shift: false };
let moveQueue = []; 
let gpMenuTimer = 0; 
let moveQueueSource = 'keyboard'; 
let gpPauseLocked = false;

// --- INITIALIZATION ---
function initGame() { 
    updateLevelSelectorUI(); 
    BgGenerator.generate(1); 
    document.getElementById('message-overlay').style.display = 'flex'; 
    updateTexts(); 
    VersionManager.init(); 
    MenuNav.init(); 
    MenuNav.refresh(); 
    loop(); 
}

const BgGenerator = {
    canvas: null, ctx: null, width: WORLD_WIDTH, height: WORLD_HEIGHT, pixels: null,
    init: function() { this.canvas = document.createElement('canvas'); this.canvas.width = this.width; this.canvas.height = this.height; this.ctx = this.canvas.getContext('2d'); },
    generate: function(level) {
        if (!this.canvas) this.init();
        const ctx = this.ctx, w = this.width, h = this.height;
        ctx.fillStyle = '#111'; ctx.fillRect(0, 0, w, h);
        
        // Cycle sur 10 niveaux maintenant
        const mode = (level - 1) % 10;
        
        if (mode === 0) { // Synth City
            let grd = ctx.createLinearGradient(0, 0, 0, h); grd.addColorStop(0, "#200020"); grd.addColorStop(0.6, "#600060"); grd.addColorStop(1, "#ff00aa");
            ctx.fillStyle = grd; ctx.fillRect(0, 0, w, h); ctx.beginPath(); ctx.arc(w/2, h*0.6, 160, 0, Math.PI*2); ctx.fillStyle = "#ffcc00"; ctx.fill();
            ctx.fillStyle = "#000"; ctx.beginPath(); ctx.moveTo(0, h); for(let i=0; i<=w; i+=40) ctx.lineTo(i, h - 100 - Math.random()*150); ctx.lineTo(w, h); ctx.fill();
            ctx.strokeStyle = "rgba(255,0,255,0.3)"; ctx.lineWidth = 2; ctx.beginPath(); for (let y = h/2; y < h; y+=40) { ctx.moveTo(0, y); ctx.lineTo(w, y); } for (let x = 0; x < w; x+=80) { ctx.moveTo(w/2, h/2); ctx.lineTo(x, h); } ctx.stroke();
        } else if (mode === 1) { // Cyber Circuit
            ctx.fillStyle = "#002000"; ctx.fillRect(0, 0, w, h); ctx.strokeStyle = "#00ff00"; ctx.lineWidth = 3;
            for(let i=0; i<100; i++) { ctx.beginPath(); let x = Math.random() * w, y = Math.random() * h; ctx.moveTo(x, y); for(let j=0; j<5; j++) { if(Math.random()>0.5) x += (Math.random()-0.5)*150; else y += (Math.random()-0.5)*150; ctx.lineTo(x, y); } ctx.stroke(); ctx.fillStyle = "#005500"; ctx.beginPath(); ctx.arc(x,y, 8, 0, Math.PI*2); ctx.fill(); }
        } else if (mode === 2) { // Nebula
            ctx.fillStyle = "#000"; ctx.fillRect(0, 0, w, h); ctx.fillStyle = "#fff"; for(let i=0; i<400; i++) { ctx.globalAlpha = Math.random(); ctx.fillRect(Math.random()*w, Math.random()*h, 3, 3); }
            ctx.globalAlpha = 0.3; for(let i=0; i<20; i++) { ctx.fillStyle = `hsl(${Math.random()*360}, 100%, 50%)`; ctx.beginPath(); ctx.arc(Math.random()*w, Math.random()*h, 150 + Math.random()*150, 0, Math.PI*2); ctx.fill(); } ctx.globalAlpha = 1.0;
        } else if (mode === 3) { // Op Art
            ctx.fillStyle = "#fff"; ctx.fillRect(0, 0, w, h); ctx.fillStyle = "#000"; let size = 60; for (let y = 0; y < h; y += size) { for (let x = 0; x < w; x += size) { if ((x/size + y/size) % 2 === 0) { let distSq = (x-w/2)**2 + (y-h/2)**2, d = size * (0.5 + 0.5*Math.sin(Math.sqrt(distSq)/100)); ctx.fillRect(x + (size-d)/2, y + (size-d)/2, d, d); } } }
        } else if (mode === 4) { // BOSS I
            ctx.fillStyle = "#300"; ctx.fillRect(0, 0, w, h); ctx.fillStyle = "#f00"; let cx = w/2, cy = h/2; ctx.fillRect(cx - 150, cy - 75, 90, 90); ctx.fillRect(cx + 60, cy - 75, 90, 90);
            for(let i=0; i<5; i++) ctx.fillRect(cx - 120 + i*60, cy + 120, 40, 70); ctx.fillStyle = "rgba(255,0,0,0.1)"; for(let i=0; i<2000; i++) ctx.fillRect(Math.random()*w, Math.random()*h, 5, 5);
        } else if (mode === 5) { // Deep Ocean
            let grd = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w); grd.addColorStop(0, "#002"); grd.addColorStop(1, "#000040"); ctx.fillStyle = grd; ctx.fillRect(0,0,w,h);
            ctx.fillStyle = "rgba(0, 100, 255, 0.1)"; for(let i=0; i<50; i++) { ctx.beginPath(); ctx.arc(Math.random()*w, Math.random()*h, 20 + Math.random()*80, 0, Math.PI*2); ctx.fill(); }
        } else if (mode === 6) { // Volcano
            ctx.fillStyle = "#200"; ctx.fillRect(0,0,w,h); ctx.fillStyle = "#f80"; 
            for(let i=0; i<20; i++) { let x = Math.random()*w; let y = h; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x-50, y-150-Math.random()*100); ctx.lineTo(x+50, y); ctx.fill(); }
            ctx.fillStyle = "rgba(255, 100, 0, 0.2)"; ctx.fillRect(0,0,w,h);
        } else if (mode === 7) { // Matrix
            ctx.fillStyle = "#000"; ctx.fillRect(0,0,w,h); ctx.fillStyle = "#0f0"; ctx.font = "20px monospace";
            for(let i=0; i<100; i++) { let x = Math.floor(Math.random()*(w/20))*20; let len = 5 + Math.random()*20; let speed = 2+Math.random()*5; 
                for(let j=0; j<len; j++) ctx.fillText(String.fromCharCode(0x30A0 + Math.random()*96), x, Math.random()*h);
            }
        } else if (mode === 8) { // Golden Age
             ctx.fillStyle = "#220"; ctx.fillRect(0,0,w,h); ctx.strokeStyle = "#d4af37"; ctx.lineWidth = 5;
             for(let i=0; i<w; i+=100) { ctx.strokeRect(i+10, 10, 80, h-20); ctx.beginPath(); ctx.arc(i+50, h/2, 30, 0, Math.PI*2); ctx.stroke(); }
        } else if (mode === 9) { // BOSS II (Void)
             ctx.fillStyle = "#fff"; ctx.fillRect(0,0,w,h); ctx.fillStyle = "#000"; 
             ctx.beginPath(); ctx.arc(w/2, h/2, 300, 0, Math.PI*2); ctx.fill();
             ctx.strokeStyle = "#000"; ctx.lineWidth = 2; for(let i=0; i<w; i+=50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(w/2, h/2); ctx.stroke(); }
        }
        
        this.pixels = ctx.getImageData(0, 0, w, h).data;
    }
};

let fillWorker = null;
let isCalculating = false;

function initWorker() {
    if (fillWorker) return;
    const blob = new Blob([WORKER_CODE], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    fillWorker = new Worker(url);
    fillWorker.onmessage = handleWorkerMessage;
}

function handleWorkerMessage(e) {
    const { gridBuffer, capturedIndices, bonusSplit, capturedRegionsCount, visitedBuffer } = e.data;
    grid.set(new Uint8Array(gridBuffer));
    isCalculating = false;
    stopPlayer(); 
    
    if (bonusSplit) { AudioController.playSplit(); score += 5 * level; triggerShake(30); gameOver(true, "BONUS SPLIT !"); return; }
    
    if (capturedRegionsCount > 1) {
        let bonus = 10 * capturedRegionsCount * level;
        bonus = Math.ceil(bonus * runUpgrades.greed);
        score += bonus; triggerShake(20);
        showFloatingText(t('float_multi') + capturedRegionsCount, player.x, player.y, '#ff0');
        AudioController.playSplit();
    }
    
    const visited = new Uint8Array(visitedBuffer);
    
    let capturedRelays = relays.filter(r => { 
        let rx = Math.floor(r.x); let ry = Math.floor(r.y);
        let idx = ry * WORLD_WIDTH + rx; 
        return visited[idx] !== 1;
    });

    if (capturedRelays.length > 0) {
        activateAntiQix();
        score += capturedRelays.length * 500;
    }

    sparx = sparx.filter(s => {
        let sx = Math.round(s.x); let sy = Math.round(s.y); let safe = false;
        for(let dy=-1; dy<=1; dy++) { 
            for(let dx=-1; dx<=1; dx++) { 
                let nx = sx + dx; let ny = sy + dy; 
                if (nx>=0 && nx<WORLD_WIDTH && ny>=0 && ny<WORLD_HEIGHT) { 
                    let idx = ny*WORLD_WIDTH + nx; 
                    if ((grid[idx] === T_EMPTY || grid[idx] === T_MINE) && visited[idx] === 1) safe = true; 
                } 
            } 
        }
        if (!safe) { 
            prisoners.push({ x: s.x, y: s.y, vx: (Math.random() - 0.5) * 15, vy: (Math.random() - 0.5) * 15, timer: 600, color: s.color, life: 600 }); 
            showFloatingText("PRISON!", s.x, s.y, "#fff"); 
            AudioController.playPowerUp(); 
            return false; 
        }
        return true;
    });

    moles = moles.filter(m => { let mx = Math.round(m.x); let my = Math.round(m.y); let idx = my*WORLD_WIDTH + mx; if (visited[idx] !== 1) { createExplosion(m.x, m.y, '#8B4513'); score += 1000; showFloatingText("MOLE CRUSHED!", m.x, m.y, "#d2691e"); AudioController.playDie(); return false; } return true; });
    pulsars = pulsars.filter(p => { let px = Math.floor(p.x); let py = Math.floor(p.y); let idx = py*WORLD_WIDTH + px; if (visited[idx] !== 1) { createExplosion(p.x, p.y, '#fff'); for(let i=0; i<50; i++) particles.push({x: p.x, y: p.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 40, color: '#fff', size: 2}); score += 2000; showFloatingText("PULSAR DESTROYED!", p.x, p.y, "#fff"); AudioController.playDie(); triggerShake(20); return false; } return true; });
    teslas = teslas.filter(t => { let tx = Math.floor(t.x); let ty = Math.floor(t.y); let idx = ty*WORLD_WIDTH + tx; if (visited[idx] !== 1) { createExplosion(t.x, t.y, '#0ff'); score += 1500; showFloatingText("TESLA SHORTED!", t.x, t.y, "#0ff"); AudioController.playDie(); return false; } return true; });
    
    let capturedCount = capturedIndices.length;
    let scoreMultiplier = (player.drawMode === 'FAST') ? 1 : 2; if (player.speedBoostTimer > 0) scoreMultiplier = 2;
    let fillType = (player.drawMode === 'FAST') ? T_FILLED_BLUE : T_FILLED_RED;
    
    let now = Date.now();
    if (lastCaptureTimestamp > 0 && (now - lastCaptureTimestamp < 2000)) { scoreMultiplier *= 2; fillType = T_FILLED_RAINBOW; showFloatingText(t('float_rhythm'), player.x, player.y, `hsl(${now % 360}, 100%, 50%)`); AudioController.playPowerUp(); }
    lastCaptureTimestamp = now;
    
    let explodedMines = mines.filter(m => {
        let idx = Math.floor(m.x) + Math.floor(m.y) * WORLD_WIDTH;
        return visited[idx] !== 1;
    });
    
    if (explodedMines.length > 0) {
        showFloatingText(t('float_chain'), player.x, player.y, '#f55'); triggerShake(15); AudioController.playSplit();
        explodedMines.forEach(m => createExplosion(m.x, m.y, '#f00'));
    }

    if (activePowerUp) {
        let idx = Math.floor(activePowerUp.x) + Math.floor(activePowerUp.y) * WORLD_WIDTH;
        if (visited[idx] !== 1) activatePowerUp(activePowerUp.def);
    }
    
    if (capturedCount > 0) {
        flashAnimations.push({ timer: 15, pixels: capturedIndices, finalType: fillType });
        filledPixels += capturedCount;
        let captureScore = Math.ceil(capturedCount * 0.01 * scoreMultiplier * comboCount);
        captureScore = Math.ceil(captureScore * runUpgrades.greed);
        score += captureScore;
        if (capturedCount > 5000) triggerShake(15); else if (capturedCount > 1000) triggerShake(5);
        
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (let idx of capturedIndices) {
             let x = idx % WORLD_WIDTH; let y = Math.floor(idx / WORLD_WIDTH);
             if(x < minX) minX = x; if(x > maxX) maxX = x;
             if(y < minY) minY = y; if(y > maxY) maxY = y;
        }
        
        for(let p of trailPoints) {
            if(p.x < minX) minX = p.x; if(p.x > maxX) maxX = p.x;
            if(p.y < minY) minY = p.y; if(p.y > maxY) maxY = p.y;
        }
        
        renderTerrainPart(minX - 2, minY - 2, maxX + 3, maxY + 3);
    }
    
    mines = mines.filter(m => { let idx = Math.floor(m.x) + Math.floor(m.y) * WORLD_WIDTH; return visited[idx] === 1; });
    relays = relays.filter(r => { let idx = Math.floor(r.x) + Math.floor(r.y) * WORLD_WIDTH; return visited[idx] === 1; });
    
    player.isDrawing = false;
    trailPoints = [];
    resetFuse();
    AudioController.setDrawSound(false, false);
    currentTrailRelays = [];
}

function handleAction() { try { AudioController.init(); AudioController.resume(); } catch(e) {} try { enterFullScreen(); } catch(e) {} if (gameState === 'WIN') { gameState = 'MENU'; updateTexts(); document.getElementById('level-selector').style.display = 'flex'; if (startLevel < 50) startLevel++; updateLevelSelectorUI(); MenuNav.refresh(); return; } if (!completedLevels.includes(startLevel)) { startGame(); } }
function startGame() { if (currentRunLives <= 0) { currentRunLives = 3; currentRunScore = 0; completedLevels = []; runUpgrades = { speed: 1.0, shield: 0, time: 1.0, lucky: 1.0, greed: 1.0, sabotage: 1.0, hasDecoy: false, hasSweeper: false, hasAlchemy: false, hasStun: false, hasRepulsor: false }; localStorage.removeItem('qix_completed'); localStorage.setItem('qix_run_upgrades', JSON.stringify(runUpgrades)); } lives = currentRunLives; score = currentRunScore; level = startLevel; resetLevel(); document.getElementById('message-overlay').style.display = 'none'; document.getElementById('minimap-container').style.display = 'block'; document.getElementById('btn-fire').style.display = runUpgrades.hasStun ? 'flex' : 'none'; document.getElementById('btn-repulsor').style.display = runUpgrades.hasRepulsor ? 'flex' : 'none'; gameState = 'PLAYING'; AudioController.startBGM(); initWorker(); }
function triggerShake(amount) { shakeIntensity = amount; }
function showFloatingText(text, x, y, color) { floatingTexts.push({ x: x, y: y, text: text, color: color, life: 60, dy: -1 }); }

// --- GRID & RENDER HELPERS (RE-ADDED) ---
function initGrid() {
    grid.fill(T_EMPTY);
    for (let x = 0; x < WORLD_WIDTH; x++) { grid[x] = T_WALL; grid[(WORLD_HEIGHT - 1) * WORLD_WIDTH + x] = T_WALL; }
    for (let y = 0; y < WORLD_HEIGHT; y++) { grid[y * WORLD_WIDTH] = T_WALL; grid[y * WORLD_WIDTH + (WORLD_WIDTH - 1)] = T_WALL; }
    filledPixels = 0;
}
function getCell(x, y) { if (x < 0 || x >= WORLD_WIDTH || y < 0 || y >= WORLD_HEIGHT) return T_WALL; return grid[y * WORLD_WIDTH + x]; }
function setCell(x, y, val) { if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) grid[y * WORLD_WIDTH + x] = val; }

function renderStaticTerrain() { renderTerrainPart(0, 0, WORLD_WIDTH, WORLD_HEIGHT); }
function renderTerrainPart(x0, y0, x1, y1) {
    x0 = Math.max(0, x0); y0 = Math.max(0, y0); x1 = Math.min(WORLD_WIDTH, x1); y1 = Math.min(WORLD_HEIGHT, y1);
    const pixels = BgGenerator.pixels;
    const imageData = terrainCtx.getImageData(x0, y0, x1 - x0, y1 - y0);
    const data = imageData.data;
    const w = x1 - x0;
    
    for (let y = 0; y < (y1 - y0); y++) {
        for (let x = 0; x < w; x++) {
            const gx = x0 + x; const gy = y0 + y;
            const idx = (y * w + x) * 4;
            const bgIdx = (gy * WORLD_WIDTH + gx) * 4;
            const cell = grid[gy * WORLD_WIDTH + gx];
            
            if (cell === T_EMPTY || cell === T_MINE) {
                data[idx] = pixels[bgIdx]; data[idx+1] = pixels[bgIdx+1]; data[idx+2] = pixels[bgIdx+2]; data[idx+3] = 255;
            } else if (cell === T_WALL) {
                const c = currentTheme.wall; data[idx] = c[0]; data[idx+1] = c[1]; data[idx+2] = c[2]; data[idx+3] = 255;
            } else if (cell === T_ELECTRIC_WALL) {
                data[idx] = 0; data[idx+1] = 255; data[idx+2] = 255; data[idx+3] = 255; 
            } else if (cell === T_FILLED_BLUE) {
                const c = currentTheme.fillFast; data[idx] = c[0]; data[idx+1] = c[1]; data[idx+2] = c[2]; data[idx+3] = 255;
            } else if (cell === T_FILLED_RED) {
                const c = currentTheme.fillSlow; data[idx] = c[0]; data[idx+1] = c[1]; data[idx+2] = c[2]; data[idx+3] = 255;
            } else if (cell === T_FILLED_RAINBOW) {
                data[idx] = Math.floor(Math.random()*255); data[idx+1] = Math.floor(Math.random()*255); data[idx+2] = Math.floor(Math.random()*255); data[idx+3] = 255;
            }
        }
    }
    terrainCtx.putImageData(imageData, x0, y0);
}

// --- INPUT & UI HELPERS (RE-ADDED) ---
window.addEventListener('keydown', e => { 
    if (e.repeat) return;
    if(e.key === 'ArrowUp') { keys.ArrowUp = true; kbState.ArrowUp = true; }
    if(e.key === 'ArrowDown') { keys.ArrowDown = true; kbState.ArrowDown = true; }
    if(e.key === 'ArrowLeft') { keys.ArrowLeft = true; kbState.ArrowLeft = true; }
    if(e.key === 'ArrowRight') { keys.ArrowRight = true; kbState.ArrowRight = true; }
    if(e.key === 'Shift') { keys.Shift = true; kbState.Shift = true; }
    if(e.code === 'Space') { kbState.Space = true; if(gameState==='PLAYING') fireStunGun(); }
    if(e.key === 'x' || e.key === 'X') { if(gameState==='PLAYING') triggerRepulsor(); }
    if(e.key === 'p' || e.key === 'P') { togglePauseAndMenu(); }
    if(e.key === 'Enter') { kbState.Enter = true; if(gameState==='MENU' && !MenuNav.active) handleAction(); }
    
    if (gameState !== 'PLAYING') {
         if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Shift','Enter',' '].includes(e.key)) MenuNav.active = true;
    }
});
window.addEventListener('keyup', e => {
    if(e.key === 'ArrowUp') { keys.ArrowUp = false; kbState.ArrowUp = false; }
    if(e.key === 'ArrowDown') { keys.ArrowDown = false; kbState.ArrowDown = false; }
    if(e.key === 'ArrowLeft') { keys.ArrowLeft = false; kbState.ArrowLeft = false; }
    if(e.key === 'ArrowRight') { keys.ArrowRight = false; kbState.ArrowRight = false; }
    if(e.key === 'Shift') { keys.Shift = false; kbState.Shift = false; }
    if(e.code === 'Space') kbState.Space = false;
    if(e.key === 'Enter') kbState.Enter = false;
});

function handleDpad(key, active) { 
    touchState[key] = active; 
    const btn = document.getElementById(key === 'ArrowUp' ? 'btn-up' : key === 'ArrowDown' ? 'btn-down' : key === 'ArrowLeft' ? 'btn-left' : 'btn-right');
    if(active) btn.classList.add('active'); else btn.classList.remove('active');
    updateInputState(); 
}
function handleSpeed(active) { touchState.Shift = active; const btn = document.getElementById('btn-speed'); if(active) btn.classList.add('active'); else btn.classList.remove('active'); updateInputState(); }
function handleFire() { fireStunGun(); }
function handleRepulsor() { triggerRepulsor(); }

function updateInputState() {
    keys.ArrowUp = kbState.ArrowUp || touchState.ArrowUp || gpState.ArrowUp || virtualState.ArrowUp;
    keys.ArrowDown = kbState.ArrowDown || touchState.ArrowDown || gpState.ArrowDown || virtualState.ArrowDown;
    keys.ArrowLeft = kbState.ArrowLeft || touchState.ArrowLeft || gpState.ArrowLeft || virtualState.ArrowLeft;
    keys.ArrowRight = kbState.ArrowRight || touchState.ArrowRight || gpState.ArrowRight || virtualState.ArrowRight;
    keys.Shift = kbState.Shift || touchState.Shift || gpState.Shift || virtualState.Shift;

    // Queue movement
    if (gameState === 'PLAYING') {
        const lastMove = moveQueue.length > 0 ? moveQueue[moveQueue.length - 1] : {x: player.dx, y: player.dy};
        let newMove = null;
        if (keys.ArrowUp && lastMove.y !== 1) newMove = {x: 0, y: -1};
        else if (keys.ArrowDown && lastMove.y !== -1) newMove = {x: 0, y: 1};
        else if (keys.ArrowLeft && lastMove.x !== 1) newMove = {x: -1, y: 0};
        else if (keys.ArrowRight && lastMove.x !== -1) newMove = {x: 1, y: 0};
        
        if (newMove && (newMove.x !== lastMove.x || newMove.y !== lastMove.y)) {
             if (moveQueue.length < 2) moveQueue.push(newMove);
        }
    }
}

function stopPlayer() { moveQueue = []; keys.ArrowUp = false; keys.ArrowDown = false; keys.ArrowLeft = false; keys.ArrowRight = false; }
function processMoveQueue() {
    // Direct input check for immediate response if not drawing
    if (!player.isDrawing) return;
    // Simple logic for this version: relying on update() reading keys object directly
}

function updateModeIndicator() {
    const el = document.getElementById('mode-indicator');
    if (keys.Shift) { el.innerText = t('mode_turbo'); el.style.color = '#f00'; el.style.textShadow = '0 0 5px #f00'; }
    else { el.innerText = t('mode_slow'); el.style.color = '#f80'; el.style.textShadow = '0 0 5px #f00'; }
}

// --- SHOP LOGIC (RE-ADDED) ---
function openShop() { 
    if(score < 1000) return; // Basic check
    document.getElementById('message-overlay').style.display = 'none'; document.getElementById('shop-overlay').style.display = 'flex'; 
    updateShopUI(); MenuNav.refresh(); 
}
function closeShop() { document.getElementById('shop-overlay').style.display = 'none'; document.getElementById('message-overlay').style.display = 'flex'; MenuNav.refresh(); }
function updateShopUI() {
    document.getElementById('shop-score-display').innerText = score;
    const items = document.querySelectorAll('.shop-item');
    items.forEach(item => {
        const costDiv = item.querySelector('.shop-cost');
        const cost = parseInt(costDiv.innerText);
        if (score >= cost) { item.classList.remove('disabled'); } else { item.classList.add('disabled'); }
        // Grey out one-time items
        const id = item.querySelector('.shop-name').id;
        if ((id === 'n_decoy' && runUpgrades.hasDecoy) || (id === 'n_sweeper' && runUpgrades.hasSweeper) || (id === 'n_alchemy' && runUpgrades.hasAlchemy) || (id === 'n_stun' && runUpgrades.hasStun) || (id === 'n_repulsor' && runUpgrades.hasRepulsor)) {
            item.classList.add('disabled');
        }
    });
}
function buyUpgrade(type) {
    const cost = SHOP_PRICES[type];
    if (score >= cost) {
        let bought = false;
        if (type === 'life') { lives++; currentRunLives++; bought = true; }
        else if (type === 'speed') { runUpgrades.speed += 0.1; bought = true; showFloatingText(t('float_speed'), WORLD_WIDTH/2, WORLD_HEIGHT/2, '#0ff'); }
        else if (type === 'shield') { runUpgrades.shield += 120; bought = true; showFloatingText(t('float_shield'), WORLD_WIDTH/2, WORLD_HEIGHT/2, '#0f0'); }
        else if (type === 'time') { runUpgrades.time += 0.2; bought = true; showFloatingText(t('float_time'), WORLD_WIDTH/2, WORLD_HEIGHT/2, '#ff0'); }
        else if (type === 'lucky') { runUpgrades.lucky += 0.5; bought = true; showFloatingText(t('float_chance'), WORLD_WIDTH/2, WORLD_HEIGHT/2, '#f0f'); }
        else if (type === 'greed') { runUpgrades.greed += 0.2; bought = true; showFloatingText(t('float_score'), WORLD_WIDTH/2, WORLD_HEIGHT/2, '#ffd700'); }
        else if (type === 'sabotage') { runUpgrades.sabotage += 1; bought = true; showFloatingText(t('float_slow'), WORLD_WIDTH/2, WORLD_HEIGHT/2, '#0ff'); }
        else if (type === 'decoy' && !runUpgrades.hasDecoy) { runUpgrades.hasDecoy = true; bought = true; showFloatingText(t('float_decoy_bought'), WORLD_WIDTH/2, WORLD_HEIGHT/2, '#f0f'); }
        else if (type === 'sweeper' && !runUpgrades.hasSweeper) { runUpgrades.hasSweeper = true; bought = true; showFloatingText(t('float_sweeper'), WORLD_WIDTH/2, WORLD_HEIGHT/2, '#f00'); }
        else if (type === 'alchemy' && !runUpgrades.hasAlchemy) { runUpgrades.hasAlchemy = true; bought = true; showFloatingText(t('float_alchemy'), WORLD_WIDTH/2, WORLD_HEIGHT/2, '#ffd700'); }
        else if (type === 'stun' && !runUpgrades.hasStun) { runUpgrades.hasStun = true; bought = true; showFloatingText(t('float_missile'), WORLD_WIDTH/2, WORLD_HEIGHT/2, '#0ff'); }
        else if (type === 'repulsor' && !runUpgrades.hasRepulsor) { runUpgrades.hasRepulsor = true; bought = true; showFloatingText(t('float_repulsor'), WORLD_WIDTH/2, WORLD_HEIGHT/2, '#f0f'); }

        if (bought) {
            score -= cost; AudioController.playPowerUp(); updateShopUI(); localStorage.setItem('qix_run_score', score); localStorage.setItem('qix_run_lives', lives); localStorage.setItem('qix_run_upgrades', JSON.stringify(runUpgrades));
            updateTexts();
        }
    } else { AudioController.playDie(); }
}

function openRules() { document.getElementById('settings-panel').style.display = 'none'; document.getElementById('rules-overlay').style.display = 'flex'; MenuNav.refresh(); }
function closeRules() { document.getElementById('rules-overlay').style.display = 'none'; document.getElementById('settings-panel').style.display = 'flex'; MenuNav.refresh(); }
function adjustStartLevel(delta) { startLevel += delta; if(startLevel < 1) startLevel = 1; if(startLevel > 50) startLevel = 50; updateLevelSelectorUI(); }
function updateLevelSelectorUI() {
    const disp = document.getElementById('start-level-display'); const btnL = document.querySelector('.lvl-btn:first-child'); const btnR = document.querySelector('.lvl-btn:last-child');
    disp.innerText = t('level_prefix') + startLevel;
    if (completedLevels.includes(startLevel)) { disp.innerText += t('level_done'); disp.classList.add('lvl-completed'); } else { disp.classList.remove('lvl-completed'); }
    // Only allow selecting levels up to max reached + 1
    let maxReached = 1; 
    if(completedLevels.length > 0) maxReached = Math.max(...completedLevels) + 1;
    // Allow selecting any previous level or the next uncompleted
    if (startLevel > maxReached && startLevel > 1) startLevel = maxReached;
}

function togglePause() {
    isPaused = !isPaused;
    if (isPaused) {
        AudioController.suspend(); document.getElementById('pause-overlay').style.display = 'flex';
    } else {
        AudioController.resume(); document.getElementById('pause-overlay').style.display = 'none';
    }
    updateTexts(); MenuNav.refresh();
}

function resetLevel() {
    let cycleIndex = (level - 1) % 10;
    currentTheme = THEMES[cycleIndex];
    let isBossLevel = (cycleIndex === 4 || cycleIndex === 9); // Levels 5, 10, 15...
    BgGenerator.generate(level); initGrid(); resetPlayer();
    
    // UPDATE UI LEVEL DISPLAY
    document.getElementById('level-display').innerText = level;
    
    particles = []; flashAnimations = []; floatingTexts = []; activePowerUp = null; playerProjectiles = [];
    powerUpSpawnTimer = 300 * runUpgrades.lucky; globalEffects.freezeTimer = 0; comboCount = 0; comboTimer = 0; 
    maxLevelTime = (LEVEL_TIME_SECONDS * 60) * runUpgrades.time; levelTime = maxLevelTime; superSparx = []; projectiles = [];
    currentQixSpeed = BASE_QIX_SPEED + ((level - 1) * 0.5); if (currentQixSpeed > 8) currentQixSpeed = 8; shakeIntensity = 0; shockwave = { active: false, x: 0, y: 0, radius: 0 };
    hunter.active = false; timeSinceLastCapture = 0; 
    decoy = { active: false, x: 0, y: 0, timer: 0 }; 
    if (runUpgrades.hasDecoy) { decoy.active = true; decoy.x = player.x; decoy.y = player.y; decoy.timer = 600; runUpgrades.hasDecoy = false; showFloatingText(t('float_decoy_active'), player.x, player.y, '#f0f'); }
    qixEntities = [];
    if (isBossLevel) { let q = { x: WORLD_WIDTH/2, y: WORLD_HEIGHT/2, dx: 0, dy: 0, targetX: 0, targetY: 0, timer: 0, isBoss: true, bossState: 'MOVING', attackTimer: 120, stunTimer: 0, warpTimer: 0 }; pickQixTarget(q); qixEntities.push(q); } 
    else { let qixCount = (level >= 3) ? 2 : 1; for(let i = 0; i < qixCount; i++) { let offsetX = (i * 80) - 40; let q = { x: WORLD_WIDTH/2+offsetX, y: WORLD_HEIGHT/2+offsetX, dx: 0, dy: 0, targetX: 0, targetY: 0, timer: 0, stunTimer: 0, warpTimer: 0 }; pickQixTarget(q); qixEntities.push(q); } }
    let sparxCount = 2 + (level - 1); sparx = []; for (let i = 0; i < sparxCount; i++) { sparx.push({ x: WORLD_WIDTH / 2, y: 0, dir: (i % 2 === 0) ? 3 : 1, color: (i < 2 ? '#f44' : '#f80'), freezeTimer: 0, warpTimer: 0 }); }
    mines = []; relays = []; portalPairs = []; portalCooldown = 0; prisoners = []; moles = []; pulsars = []; teslas = []; lastCaptureTimestamp = 0;
    
    if (level >= 2 && !isBossLevel) { 
        let mineCount = level * 5; 
        for(let i=0; i<mineCount; i++) { 
            let valid = false; let mx, my; let attempts = 0; 
            while(!valid && attempts < 100) { 
                mx = Math.floor(20 + Math.random() * (WORLD_WIDTH - 40)); my = Math.floor(20 + Math.random() * (WORLD_HEIGHT - 40)); 
                let dSq = (mx - WORLD_WIDTH/2)**2 + (my - WORLD_HEIGHT)**2;
                if (getCell(mx, my) === T_EMPTY && dSq > 10000) valid = true; attempts++; 
            } 
            if(valid) { mines.push({x: mx, y: my}); setCell(mx, my, T_MINE); } 
        } 
        
        let relayCount = 1; // FIX: Max 1 Relay
        for(let i=0; i<relayCount; i++) {
             let valid = false; let rx, ry; let attempts = 0; 
             while(!valid && attempts < 100) { 
                 rx = Math.floor(40 + Math.random() * (WORLD_WIDTH - 80)); ry = Math.floor(40 + Math.random() * (WORLD_HEIGHT - 80)); 
                 let dSq = (rx - WORLD_WIDTH/2)**2 + (rx - WORLD_HEIGHT)**2;
                 if (getCell(rx, ry) === T_EMPTY && dSq > 10000) valid = true; attempts++; 
             }
             if(valid) { relays.push({x: rx, y: ry}); }
        }
        
        if (level >= 3) {
            let p1 = null, p2 = null;
            for(let i=0; i<50; i++) { let rx = Math.floor(60 + Math.random() * (WORLD_WIDTH - 120)); let ry = Math.floor(60 + Math.random() * (WORLD_HEIGHT - 120)); if (getCell(rx, ry) === T_EMPTY) { p1 = {x: rx, y: ry}; break; } }
            for(let i=0; i<50; i++) { 
                let rx = Math.floor(60 + Math.random() * (WORLD_WIDTH - 120)); let ry = Math.floor(60 + Math.random() * (WORLD_HEIGHT - 120)); 
                let dSq = (rx - p1.x)**2 + (ry - p1.y)**2;
                if (getCell(rx, ry) === T_EMPTY && dSq > 90000) { p2 = {x: rx, y: ry}; break; } 
            }
            if (p1 && p2) { portalPairs.push({p1: p1, p2: p2, color: `hsl(${Math.random()*360}, 100%, 70%)`}); }
        }

        let moleCount = Math.floor(level / 3) + 1; for(let i=0; i<moleCount; i++) { moles.push({ x: 0, y: Math.random() * WORLD_HEIGHT, dir: Math.floor(Math.random()*4), moveTimer: 0 }); }
        if (level >= 4) { let pulsarCount = Math.floor(level / 5) + 1; for(let i=0; i<pulsarCount; i++) { let rx, ry; for(let k=0; k<50; k++) { rx = 100 + Math.random() * (WORLD_WIDTH - 200); ry = 100 + Math.random() * (WORLD_HEIGHT - 200); if(getCell(rx, ry) === T_EMPTY) break; } pulsars.push({ x: rx, y: ry, timer: Math.random() * 180, maxTimer: 180, radius: 0, active: true }); } }
        if (level >= 3) { let teslaCount = Math.min(3, Math.floor(level / 3)); for(let i=0; i<teslaCount; i++) { let rx, ry; for(let k=0; k<50; k++) { rx = 50 + Math.random() * (WORLD_WIDTH - 100); ry = 50 + Math.random() * (WORLD_HEIGHT - 100); if(getCell(rx, ry) === T_EMPTY) break; } teslas.push({ x: rx, y: ry, vx: (Math.random() - 0.5) * 1.5, vy: (Math.random() - 0.5) * 1.5, state: 'IDLE', timer: Math.random() * 120, targetX: 0, targetY: 0, hasHit: false }); } }
    }
    renderStaticTerrain();
    
    if (runUpgrades.hasSweeper) { mines.forEach(m => { createExplosion(m.x, m.y, '#f00'); setCell(m.x, m.y, T_EMPTY); score += 500; }); mines = []; runUpgrades.hasSweeper = false; showFloatingText(t('float_mines_cleared'), player.x, player.y, '#f55'); triggerShake(20); AudioController.playSplit(); renderStaticTerrain(); }
    if (runUpgrades.hasAlchemy) { mines.forEach(m => { createExplosion(m.x, m.y, '#ffd700'); setCell(m.x, m.y, T_EMPTY); score += 1000; }); mines = []; runUpgrades.hasAlchemy = false; showFloatingText(t('float_gold_mines'), player.x, player.y, '#ffd700'); triggerShake(20); AudioController.playCapture(5); renderStaticTerrain(); }
    document.getElementById('lives').innerText = lives; document.getElementById('score').innerText = score; document.getElementById('high-score').innerText = highScore;
    keys.Shift = false; kbState.Shift = false; touchState.Shift = false; virtualState.Shift = false;
    document.querySelectorAll('.dpad-btn').forEach(b => b.classList.remove('active')); document.getElementById('btn-speed').classList.remove('active');
    updateModeIndicator(); updateBonusUI(); isPaused = false; document.getElementById('pause-overlay').style.display = 'none'; document.getElementById('m_pause').innerText = t('menu_pause');
}

function resetPlayer() {
    player.x = WORLD_WIDTH / 2; player.y = WORLD_HEIGHT - 1; player.dx = 0; player.dy = 0;
    player.isDrawing = false; player.drawMode = 'SLOW'; player.shield = false; player.speedBoostTimer = 0; player.facing = {x: 0, y: -1};
    player.idleTimer = 0; player.lastX = player.x; player.lastY = player.y;
    player.antiQixTimer = 0; // Initialize antiQixTimer
    comboCount = 0; comboTimer = 0; trailPoints = []; resetFuse(); stopPlayer(); currentTrailRelays = []; player.history = [];
    if (getCell(Math.round(player.x), Math.round(player.y)) !== T_WALL && getCell(Math.round(player.x), Math.round(player.y)) !== T_ELECTRIC_WALL) { for(let x=0; x<WORLD_WIDTH; x++) { if (getCell(x, WORLD_HEIGHT-1) === T_WALL) { player.x = x; player.y = WORLD_HEIGHT-1; break; } } }
    updateBonusUI();
    camera.x = Math.max(0, Math.min(WORLD_WIDTH - VIEW_WIDTH, player.x - VIEW_WIDTH / 2)); camera.y = Math.max(0, Math.min(WORLD_HEIGHT - VIEW_HEIGHT, player.y - VIEW_HEIGHT / 2));
}

function resetFuse() { fuse.active = false; fuse.timer = 0; fuse.index = 0; }
function spawnPowerUp() {
    for(let i=0; i<50; i++) {
        let rx = 20 + Math.random() * (WORLD_WIDTH - 40); let ry = 20 + Math.random() * (WORLD_HEIGHT - 40);
        if (getCell(Math.floor(rx), Math.floor(ry)) === T_EMPTY) {
            let r = Math.random(); let type = POWERUPS.FREEZE;
            if (r < 0.20) type = POWERUPS.SPEED; else if (r < 0.40) type = POWERUPS.SHIELD; else if (r < 0.60) type = POWERUPS.ZAP; else if (r < 0.80) type = POWERUPS.DECOY;
            activePowerUp = { x: rx, y: ry, def: type, life: 600 }; return;
        }
    }
}
function activatePowerUp(def) {
    createExplosion(activePowerUp.x, activePowerUp.y, def.color); AudioController.playPowerUp(); 
    if (def.type === 'FREEZE') globalEffects.freezeTimer = def.duration;
    else if (def.type === 'SPEED') player.speedBoostTimer = def.duration;
    else if (def.type === 'SHIELD') { player.shield = true; } 
    else if (def.type === 'ZAP') { let count = sparx.length; sparx.forEach(s => { createExplosion(s.x, s.y, s.color); }); sparx = []; score += count * 500; showFloatingText(t('float_zap').replace('X', count), player.x, player.y, '#f0f'); triggerShake(15); } 
    else if (def.type === 'DECOY') { decoy.active = true; decoy.x = player.x; decoy.y = player.y; decoy.timer = def.duration; showFloatingText(t('float_decoy_active'), player.x, player.y, '#f0f'); }
    activePowerUp = null; powerUpSpawnTimer = (600 + Math.random() * 600) * runUpgrades.lucky; updateBonusUI();
}
function updateBonusUI() { const el = document.getElementById('bonus-indicator'); let text = ""; if (player.shield) text += t('bonus_shield'); if (player.speedBoostTimer > 0) text += t('bonus_speed'); if (globalEffects.freezeTimer > 0) text += t('bonus_freeze'); if (decoy.active) text += t('bonus_decoy'); el.innerText = text; }

let fireCooldown = 0;
function fireStunGun() { if (!runUpgrades.hasStun || fireCooldown > 0 || gameState !== 'PLAYING') return; fireCooldown = 60; AudioController.playShoot(); let dx = player.facing.x; let dy = player.facing.y; if (dx === 0 && dy === 0) dy = -1; playerProjectiles.push({ x: player.x, y: player.y, dx: dx * 12, dy: dy * 12, life: 100 }); triggerShake(2); }

let repulsorCooldown = 0;
function triggerRepulsor() {
    if (!runUpgrades.hasRepulsor || repulsorCooldown > 0 || gameState !== 'PLAYING') return; 
    repulsorCooldown = 300; shockwave.active = true; shockwave.x = player.x; shockwave.y = player.y; shockwave.radius = 10; 
    AudioController.playRepulse(); triggerShake(20); showFloatingText(t('float_repulsor_active'), player.x, player.y, '#f0f');
    qixEntities.forEach(q => { 
        let dx = q.x - player.x; let dy = q.y - player.y; let distSq = dx*dx + dy*dy; 
        if (distSq < 90000) { 
            let dist = Math.sqrt(distSq); q.x += (dx/dist) * 200; q.y += (dy/dist) * 200; 
            q.x = Math.max(20, Math.min(WORLD_WIDTH-20, q.x)); q.y = Math.max(20, Math.min(WORLD_HEIGHT-20, q.y)); 
            q.targetX = q.x; q.targetY = q.y; q.stunTimer = 60; 
        } 
    });
    if (hunter.active) { 
        let dx = hunter.x - player.x; let dy = hunter.y - player.y; let distSq = dx*dx + dy*dy;
        if (distSq < 90000) { 
            let dist = Math.sqrt(distSq); hunter.x += (dx/dist) * 300; hunter.y += (dy/dist) * 300; 
            hunter.x = Math.max(20, Math.min(WORLD_WIDTH-20, hunter.x)); hunter.y = Math.max(20, Math.min(WORLD_HEIGHT-20, hunter.y)); 
        } 
    }
    sparx.forEach(s => { let dx = s.x - player.x; let dy = s.y - player.y; if (dx*dx + dy*dy < 90000) { s.freezeTimer = 300; createExplosion(s.x, s.y, '#fff'); } });
}
function updatePlayerProjectiles() {
    if (fireCooldown > 0) fireCooldown--; if (repulsorCooldown > 0) repulsorCooldown--;
    if (shockwave.active) { shockwave.radius += 15; if (shockwave.radius > 400) shockwave.active = false; }
    for (let i = playerProjectiles.length - 1; i >= 0; i--) {
        let p = playerProjectiles[i]; p.x += p.dx; p.y += p.dy; p.life--;
        if (p.x < 0 || p.x >= WORLD_WIDTH || p.y < 0 || p.y >= WORLD_HEIGHT || p.life <= 0) { playerProjectiles.splice(i, 1); continue; }
        for (let q of qixEntities) { 
            let distSq = (p.x - q.x)**2 + (p.y - q.y)**2; 
            if (distSq < 900) { 
                q.stunTimer = 300; createExplosion(q.x, q.y, '#0ff'); showFloatingText(t('float_stunned'), q.x, q.y, '#0ff'); playerProjectiles.splice(i, 1); break; 
            } 
        }
    }
}

function updateTimeAndSuperSparx() { if (levelTime > 0) { levelTime--; if (levelTime === 0) spawnSuperSparx(); } else { updateSuperSparx(); } }
function spawnSuperSparx() { AudioController.playAlarm(); triggerShake(10); superSparx = [{ x: 0, y: 0, color: '#f0f' }, { x: WORLD_WIDTH-1, y: 0, color: '#f0f' }]; }
function updateSuperSparx() {
    if (globalEffects.freezeTimer > 0) return;
    superSparx.forEach(s => { 
        let dx = player.x - s.x; let dy = player.y - s.y; let distSq = dx*dx + dy*dy; 
        if (distSq < 100) { playerHit(); return; } 
        let dist = Math.sqrt(distSq); dx /= dist; dy /= dist; s.x += dx * SUPER_SPARX_SPEED; s.y += dy * SUPER_SPARX_SPEED; 
    });
}

function updateProjectiles() {
    for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i]; p.x += p.dx; p.y += p.dy; 
        let distSq = (p.x - player.x)**2 + (p.y - player.y)**2;
        if (distSq < 100) { createExplosion(p.x, p.y, '#f00'); projectiles.splice(i, 1); playerHit(); continue; }
        let gx = Math.round(p.x); let gy = Math.round(p.y);
        if (gx >= 0 && gx < WORLD_WIDTH && gy >= 0 && gy < WORLD_HEIGHT) { if (grid[gy * WORLD_WIDTH + gx] === T_TRAIL) { createExplosion(p.x, p.y, '#f00'); projectiles.splice(i, 1); playerHit(); continue; } }
        if (p.x < 0 || p.x > WORLD_WIDTH || p.y < 0 || p.y > WORLD_HEIGHT) projectiles.splice(i, 1);
    }
}

function updateHunter() {
    timeSinceLastCapture++;
    if (decoy.active) { decoy.timer--; if (decoy.timer <= 0) { decoy.active = false; updateBonusUI(); } }
    if (!hunter.active) { if (timeSinceLastCapture > HUNTER_SPAWN_TIME) { hunter.active = true; hunter.x = WORLD_WIDTH / 2; hunter.y = 0; AudioController.playHunterSpawn(); triggerShake(10); } } 
    else {
        if (globalEffects.freezeTimer > 0) return;
        let moves = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}]; let bestMove = null; let minSq = Infinity;
        let hx = Math.round(hunter.x); let hy = Math.round(hunter.y);
        let targetX = decoy.active ? decoy.x : player.x; let targetY = decoy.active ? decoy.y : player.y;
        for(let m of moves) { 
            let nx = hx + m.x * 5; let ny = hy + m.y * 5; 
            if (nx >= 0 && nx < WORLD_WIDTH && ny >= 0 && ny < WORLD_HEIGHT) { 
                let type = getCell(nx, ny); 
                if (type !== T_EMPTY && type !== T_MINE) { 
                    let distSq = ((hx + m.x) - targetX)**2 + ((hy + m.y) - targetY)**2; 
                    if (distSq < minSq) { minSq = distSq; bestMove = m; } 
                } 
            } 
        }
        if (bestMove) { hunter.x += bestMove.x * HUNTER_SPEED; hunter.y += bestMove.y * HUNTER_SPEED; }
        if ((hunter.x - player.x)**2 + (hunter.y - player.y)**2 < 100) { playerHit(); }
    }
}

function drawHunter() { if (!hunter.active) return; let pulse = 1 + 0.2 * Math.sin(Date.now() / 50); let size = 10 * pulse; ctx.save(); ctx.translate(hunter.x - camera.x, hunter.y - camera.y); let targetX = decoy.active ? decoy.x : player.x; let targetY = decoy.active ? decoy.y : player.y; let angle = Math.atan2(targetY - hunter.y, targetX - hunter.x); ctx.rotate(angle); ctx.fillStyle = '#f40'; ctx.beginPath(); ctx.moveTo(size, 0); ctx.lineTo(-size, -size/1.5); ctx.lineTo(-size, size/1.5); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0, 3, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
function drawDecoy() { if (!decoy.active) return; let pulse = 1 + 0.2 * Math.sin(Date.now() / 100); let size = 20 * pulse; ctx.save(); ctx.translate(decoy.x - camera.x, decoy.y - camera.y); ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.stroke(); ctx.beginPath(); ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2); ctx.globalAlpha = 0.5; ctx.stroke(); ctx.globalAlpha = 1; ctx.fillStyle = '#ff00ff'; ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }

function createExplosion(x, y, color) { if (particles.length > MAX_PARTICLES) return; for (let i = 0; i < 20; i++) { particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, life: 40 + Math.random() * 20, color: color, size: 3 + Math.random() * 3, gravity: 0.1 }); } }
function createTrailSpark(x, y) { if (particles.length > MAX_PARTICLES) return; particles.push({ x: x + (Math.random() - 0.5) * 4, y: y + (Math.random() - 0.5) * 4, vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5, life: 15, color: '#fff', size: 1 + Math.random(), gravity: 0 }); }
function updateParticles() { if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES); for (let i = particles.length - 1; i >= 0; i--) { let p = particles[i]; p.x += p.vx; p.y += p.vy; p.vy += p.gravity; p.life--; if (p.life <= 0) particles.splice(i, 1); } for (let i = floatingTexts.length - 1; i >= 0; i--) { let ft = floatingTexts[i]; ft.y += ft.dy; ft.life--; if(ft.life <= 0) floatingTexts.splice(i, 1); } }

function checkPortal(entity, entry, exit) {
    if (entity === player && portalCooldown > 0) return false;
    if (entity !== player && entity.warpTimer > 0) { entity.warpTimer--; return false; }
    let distSq = (entity.x - entry.x)**2 + (entity.y - entry.y)**2;
    if (distSq < 400) { 
        if (entity === player && player.isDrawing) return false;
        entity.x = exit.x; entity.y = exit.y;
        if (entity !== player) { entity.warpTimer = 120; if(entity.targetX !== undefined) { pickQixTarget(entity); } } 
        else { portalCooldown = 60; showFloatingText(t('float_warp'), exit.x, exit.y, "#0ff"); AudioController.playPowerUp(); triggerShake(5); }
        createExplosion(entry.x, entry.y, '#0ff'); createExplosion(exit.x, exit.y, '#0ff');
        return true;
    }
    return false;
}

function updateMoles() {
    if (globalEffects.freezeTimer > 0) return;
    moles.forEach(m => {
        m.moveTimer++; if (m.moveTimer % 2 !== 0) return;
        let cx = Math.round(m.x); let cy = Math.round(m.y);
        let isWorldBorder = (cx <= 2 || cx >= WORLD_WIDTH - 3 || cy <= 2 || cy >= WORLD_HEIGHT - 3);
        if (!isWorldBorder) {
            let currentType = getCell(cx, cy);
            if (currentType === T_WALL || currentType === T_FILLED_BLUE || currentType === T_FILLED_RED || currentType === T_FILLED_RAINBOW || currentType === T_ELECTRIC_WALL) { setCell(cx, cy, T_EMPTY); filledPixels--; if(Math.random() > 0.8) { particles.push({ x: cx, y: cy, vx: (Math.random()-0.5), vy: (Math.random()-0.5), life: 10, color: '#885522', size: 2, gravity: 0.1 }); } }
        }
        const dirs = [{x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}]; let validDirs = [];
        for(let i=0; i<4; i++) { let nx = cx + dirs[i].x; let ny = cy + dirs[i].y; if (nx >= 0 && nx < WORLD_WIDTH && ny >= 0 && ny < WORLD_HEIGHT) { let t = getCell(nx, ny); if (t === T_WALL || t === T_FILLED_BLUE || t === T_FILLED_RED || t === T_FILLED_RAINBOW || t === T_ELECTRIC_WALL) { validDirs.push(i); } } }
        if (validDirs.length > 0) { if (validDirs.includes(m.dir)) {} else { m.dir = validDirs[Math.floor(Math.random() * validDirs.length)]; } m.x += dirs[m.dir].x; m.y += dirs[m.dir].y; } else { m.dir = (m.dir + 1) % 4; m.x += dirs[m.dir].x; m.y += dirs[m.dir].y; }
        m.x = Math.max(0, Math.min(WORLD_WIDTH-1, m.x)); m.y = Math.max(0, Math.min(WORLD_HEIGHT-1, m.y));
    });
}

function updatePulsars() {
    if (globalEffects.freezeTimer > 0) return;
    pulsars.forEach(p => {
        p.x += (Math.random() - 0.5) * 0.2; p.y += (Math.random() - 0.5) * 0.2; p.timer++;
        if (p.timer >= p.maxTimer) {
            p.timer = 0; p.radius = 20; 
            let dx = player.x - p.x; let dy = player.y - p.y;
            let distSq = dx*dx + dy*dy;
            let rangeSq = 62500; 
            if (distSq < rangeSq) {
                let dist = Math.sqrt(distSq);
                let force = (250 - dist) / 250; 
                let push = 15 * force; 
                let angle = Math.atan2(dy, dx);
                player.x += Math.cos(angle) * push; player.y += Math.sin(angle) * push;
                player.x = Math.max(0, Math.min(WORLD_WIDTH-1, player.x)); player.y = Math.max(0, Math.min(WORLD_HEIGHT-1, player.y));
                triggerShake(5 * force); if(player.isDrawing) { showFloatingText("PUSH!", player.x, player.y - 20, "#f00"); }
            }
            if ((camera.x + VIEW_WIDTH/2 - p.x)**2 + (camera.y + VIEW_HEIGHT/2 - p.y)**2 < VIEW_WIDTH**2) { AudioController.playRepulse(); }
        }
        if (p.radius > 0) { p.radius += 5; if (p.radius > 250) p.radius = 0; }
    });
}

function updateTeslas() {
    if (globalEffects.freezeTimer > 0) return;
    teslas.forEach(t => {
        if (player.idleTimer > 120 && t.state === 'CHARGE') { 
        }
        if (t.state === 'IDLE' || t.state === 'CHARGE') {
            t.x += t.vx; t.y += t.vy;
            if (t.x < 20 || t.x > WORLD_WIDTH - 20) t.vx *= -1; if (t.y < 20 || t.y > WORLD_HEIGHT - 20) t.vy *= -1;
            let cx = Math.round(t.x); let cy = Math.round(t.y); let type = getCell(cx, cy); if (type !== T_EMPTY && type !== T_MINE) { t.vx *= -1; t.vy *= -1; t.x += t.vx * 2; t.y += t.vy * 2; }
        }
        if (t.state === 'IDLE') {
            t.timer++; 
            let distSq = (player.x - t.x)**2 + (player.y - t.y)**2;
            if (t.timer > 120 && distSq < 62500) { t.state = 'CHARGE'; t.timer = 0; }
        } else if (t.state === 'CHARGE') {
            t.timer++; if (t.timer > 60) { t.state = 'FIRE'; t.timer = 0; t.targetX = player.x; t.targetY = player.y; t.hasHit = false; AudioController.playShoot(); triggerShake(5); }
        } else if (t.state === 'FIRE') {
            t.timer++;
            function distToSegmentSq(p, v, w) {
                function sqr(x) { return x * x }
                function dist2(v, w) { return sqr(v.x - w.x) + sqr(v.y - w.y) }
                var l2 = dist2(v, w); if (l2 == 0) return dist2(p, v);
                var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                return dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) });
            }
            let d2 = distToSegmentSq(player, {x:t.x, y:t.y}, {x:t.targetX, y:t.targetY});
            if (d2 < 100 && !t.hasHit) { 
                t.hasHit = true; score = Math.max(0, score - 10000); showFloatingText("-10000 PTS!", player.x, player.y, "#f00"); triggerShake(20); AudioController.playDie();
                for(let i=0; i<10; i++) { particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 20, color: '#f00', size: 2, gravity: 0.2 }); }
            }
            if (t.timer > 15) { t.state = 'IDLE'; t.timer = 0; }
        }
    });
}

function updatePrisoners() {
    for (let i = prisoners.length - 1; i >= 0; i--) {
        let p = prisoners[i]; p.x += p.vx; p.y += p.vy; let bounce = false;
        if(p.x < 0 || p.x >= WORLD_WIDTH) { p.vx *= -1; bounce = true; } if(p.y < 0 || p.y >= WORLD_HEIGHT) { p.vy *= -1; bounce = true; }
        let gx = Math.round(p.x); let gy = Math.round(p.y); if (getCell(gx, gy) === T_WALL || getCell(gx, gy) === T_ELECTRIC_WALL) { p.vx *= -1; p.vy *= -1; bounce = true; }
        if (bounce) { score += 50; showFloatingText("+50", p.x, p.y, "#ff0"); }
        p.timer--; if (p.timer % 30 === 0) { score += 10; }
        if (p.timer <= 0) { createExplosion(p.x, p.y, p.color); score += 1000; showFloatingText("EXECUTED", p.x, p.y, "#f00"); AudioController.playDie(); prisoners.splice(i, 1); }
    }
}

function activateAntiQix() {
    player.antiQixTimer = 480; // 8 seconds
    AudioController.playRepulse();
    showFloatingText("SURCHARGE!", player.x, player.y, "#0ff");
    triggerShake(5);
}

function update() {
    updateInputState(); 
    
    if (gameState !== 'PLAYING' && gameState !== 'RESPAWN' && gameState !== 'GAMEOVER_ANIMATION') {
        MenuNav.update();
        if (isPaused) return; 
    } else {
        if (isPaused) {
             MenuNav.update(); return; 
        }
    }
    
    const tension = Math.min(1, filledPixels / totalPixels); AudioController.updateAudio(tension);
    
    if (gameState === 'GAMEOVER_ANIMATION') {
        splashTimer--;
        updateParticles();
        if (splashTimer <= 0) {
             finishGameOverSequence();
        }
        return;
    }

    if (gameState === 'WIN_ANIMATION') {
        winAnimTimer--; const cx = WORLD_WIDTH / 2; const cy = WORLD_HEIGHT / 2;
        winParticles.forEach(p => { let dx = cx - p.x; let dy = cy - p.y; let dist = Math.sqrt(dx*dx + dy*dy); p.x += (dx / dist) * 15; p.y += (dy / dist) * 15; p.life--; });
        if (winAnimTimer % 20 === 0) { let fx = camera.x + 100 + Math.random() * (VIEW_WIDTH - 200); let fy = camera.y + 100 + Math.random() * (VIEW_HEIGHT - 200); createFirework(fx, fy); AudioController.playShoot(); triggerShake(8); }
        for (let i = fireworks.length - 1; i >= 0; i--) { let p = fireworks[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life--; if (p.life <= 0) fireworks.splice(i, 1); }
        if (winAnimTimer <= 0) { finishWinSequence(); } return;
    }

    if (gameState === 'PLAYING') {
        if (!isCalculating) {
            updateTimeAndSuperSparx(); updateProjectiles(); updatePlayerProjectiles(); updateHunter();
            updatePrisoners(); updateMoles(); updatePulsars(); updateTeslas(); 
            if (comboTimer > 0) comboTimer--; else comboCount = 0;
            
            updatePlayer(); updateQix(); updateSparx(); updateFuse(); 
        } else {
            // While calculating...
        }
        
        let targetCamX = player.x - VIEW_WIDTH / 2; let targetCamY = player.y - VIEW_HEIGHT / 2;
        camera.x += (targetCamX - camera.x) * 0.1; camera.y += (targetCamY - camera.y) * 0.1;
        camera.x = Math.max(0, Math.min(WORLD_WIDTH - VIEW_WIDTH, camera.x)); camera.y = Math.max(0, Math.min(WORLD_HEIGHT - VIEW_HEIGHT, camera.y));
    }
    if (globalEffects.freezeTimer > 0) globalEffects.freezeTimer--;
    if (player.speedBoostTimer > 0) player.speedBoostTimer--;
    if (player.antiQixTimer > 0) player.antiQixTimer--; // Countdown the battery
    
    if ((globalEffects.freezeTimer % 60 === 0) || (player.speedBoostTimer % 60 === 0)) updateBonusUI();
    if (!activePowerUp) { powerUpSpawnTimer--; if (powerUpSpawnTimer <= 0) spawnPowerUp(); } else { activePowerUp.life--; if (activePowerUp.life <= 0) { activePowerUp = null; powerUpSpawnTimer = 300 * runUpgrades.lucky; } }
    
    for (let i = flashAnimations.length - 1; i >= 0; i--) { 
        let anim = flashAnimations[i]; 
        anim.timer--; 
        if (anim.timer <= 0) { 
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (let idx of anim.pixels) { 
                grid[idx] = anim.finalType; 
                let x = idx % WORLD_WIDTH; let y = Math.floor(idx / WORLD_WIDTH);
                if(x < minX) minX = x; if(x > maxX) maxX = x;
                if(y < minY) minY = y; if(y > maxY) maxY = y;
            }
            renderTerrainPart(minX, minY, maxX + 1, maxY + 1);
            flashAnimations.splice(i, 1); 
        } 
    }
    updateParticles();
    if (gameState === 'RESPAWN') { respawnTimer--; if (respawnTimer <= 0) { resetPlayer(); gameState = 'PLAYING'; } return; }
    if (gameState !== 'PLAYING') return;
    const coverage = filledPixels / totalPixels;
    document.getElementById('percent').innerText = Math.floor(coverage * 100); document.getElementById('score').innerText = score; document.getElementById('lives').innerText = lives;
    currentRunScore = score; currentRunLives = lives; localStorage.setItem('qix_run_score', score); localStorage.setItem('qix_run_lives', lives);
    if (score > highScore) { highScore = score; document.getElementById('high-score').innerText = score; localStorage.setItem('qix_hiscore_v2', highScore); }
    if (coverage >= WIN_THRESHOLD) gameOver(true);
}

function updatePlayer() {
    processMoveQueue();
    let currentSpeed = SPEED_SLOW; let isTurbo = (player.drawMode === 'FAST' || keys.Shift || player.speedBoostTimer > 0);
    AudioController.setTurboEffect(isTurbo);
    if(isTurbo) { player.history.push({x: player.x, y: player.y}); if(player.history.length > 10) player.history.shift(); } else { player.history = []; }

    if (Math.abs(player.x - player.lastX) < 0.1 && Math.abs(player.y - player.lastY) < 0.1 && !player.isDrawing) {
        player.idleTimer++;
        if (player.idleTimer > 120 && player.idleTimer % 60 === 0) { AudioController.playTick(); }
        if (player.idleTimer >= 300) {
            let tx, ty; let found = false;
            for(let i=0; i<50; i++) { tx = Math.floor(Math.random() * WORLD_WIDTH); ty = Math.floor(Math.random() * WORLD_HEIGHT); let cell = getCell(tx, ty); if (cell === T_WALL || cell === T_ELECTRIC_WALL) { found = true; break; } }
            if (!found) { tx = WORLD_WIDTH/2; ty = WORLD_HEIGHT-1; }
            createExplosion(player.x, player.y, '#f0f'); player.x = tx; player.y = ty; createExplosion(player.x, player.y, '#f0f');
            AudioController.playPowerUp(); showFloatingText("UNSTABLE!", player.x, player.y - 30, "#f0f"); triggerShake(10); player.idleTimer = 0; 
        }
    } else { player.idleTimer = 0; }
    player.lastX = player.x; player.lastY = player.y;

    if (!player.isDrawing && portalCooldown <= 0) {
        let magnetRangeSq = 2500; 
        let pullStrength = 2; 
        for (let pair of portalPairs) {
            [pair.p1, pair.p2].forEach(p => {
                let dx = p.x - player.x; let dy = p.y - player.y; let distSq = dx*dx + dy*dy;
                if (distSq < magnetRangeSq && distSq > 25) { 
                    let dist = Math.sqrt(distSq);
                    let angle = Math.atan2(dy, dx);
                    player.x += Math.cos(angle) * pullStrength; player.y += Math.sin(angle) * pullStrength;
                    if (Math.random() > 0.7) { particles.push({ x: player.x + (Math.random()-0.5)*10, y: player.y + (Math.random()-0.5)*10, vx: (dx/dist) * 2, vy: (dy/dist) * 2, life: 20, color: pair.color, size: 1, gravity: 0 }); }
                }
            });
        }
    }

    if (portalCooldown > 0) portalCooldown--;
    for (let pair of portalPairs) { if (checkPortal(player, pair.p1, pair.p2)) break; if (checkPortal(player, pair.p2, pair.p1)) break; }

    if (player.isDrawing && trailPoints.length > 10) {
        let cx = Math.round(player.x); let cy = Math.round(player.y);
        let snapDist = 6; let bestSnap = null; let minSq = snapDist * snapDist;
        for(let dy = -snapDist; dy <= snapDist; dy++) {
            for(let dx = -snapDist; dx <= snapDist; dx++) {
                let tx = cx + dx; let ty = cy + dy;
                if (tx >= 0 && tx < WORLD_WIDTH && ty >= 0 && ty < WORLD_HEIGHT) {
                    let t = getCell(tx, ty);
                    if (t === T_WALL || t === T_FILLED_BLUE || t === T_FILLED_RED || t === T_FLASH || t === T_ELECTRIC_WALL) {
                        let dSq = dx*dx + dy*dy; if (dSq < minSq) { minSq = dSq; bestSnap = {x: tx, y: ty}; }
                    }
                }
            }
        }
        if (bestSnap) { drawLineOnGrid(cx, cy, bestSnap.x, bestSnap.y, T_TRAIL); player.x = bestSnap.x; player.y = bestSnap.y; createExplosion(player.x, player.y, '#fff'); showFloatingText(t('float_snap'), player.x, player.y - 30, "#fff"); fillTerritory(); return; }
    }

    if (player.isDrawing) { currentSpeed = (player.drawMode === 'FAST') ? SPEED_FAST : SPEED_SLOW; if (Math.random() > 0.5) createTrailSpark(player.x, player.y); AudioController.setDrawSound(true, player.drawMode === 'FAST'); } 
    else { currentSpeed = SPEED_FAST; player.drawMode = keys.Shift ? 'FAST' : 'SLOW'; AudioController.setDrawSound(false, false); }
    if (player.speedBoostTimer > 0) currentSpeed *= 2; 
    let nextX = player.x; let nextY = player.y;
    if (keys.ArrowUp) { nextY -= currentSpeed; player.facing = {x:0, y:-1}; } else if (keys.ArrowDown) { nextY += currentSpeed; player.facing = {x:0, y:1}; } else if (keys.ArrowLeft) { nextX -= currentSpeed; player.facing = {x:-1, y:0}; } else if (keys.ArrowRight) { nextX += currentSpeed; player.facing = {x:1, y:0}; }
    nextX = Math.max(0, Math.min(WORLD_WIDTH - 1, nextX)); nextY = Math.max(0, Math.min(WORLD_HEIGHT - 1, nextY));
    
    if (player.isDrawing) { 
        let hasMoved = (nextX !== player.x || nextY !== player.y); 
        if (!hasMoved && !fuse.active) { fuse.timer++; if (fuse.timer >= FUSE_DELAY_FRAMES) { fuse.active = true; fuse.index = 0; } } else if (hasMoved && !fuse.active) fuse.timer = 0; 
        relays.forEach(r => {
            if (!currentTrailRelays.includes(r)) {
                if ((player.x - r.x)**2 + (player.y - r.y)**2 < 625) { 
                    currentTrailRelays.push(r); createExplosion(r.x, r.y, '#0ff'); AudioController.playShoot();
                    // TRIGGER OVERCHARGE ON TOUCH
                    activateAntiQix();
                }
            }
        });
    } else { resetFuse(); }
    
    let gx = Math.round(nextX); let gy = Math.round(nextY); let currentType = getCell(Math.round(player.x), Math.round(player.y)); let nextType = getCell(gx, gy);
    if (nextType === T_TRAIL) return; if (nextType === T_FILLED_BLUE || nextType === T_FILLED_RED || nextType === T_FLASH || nextType === T_ELECTRIC_WALL) return;
    if (currentType === T_MINE || nextType === T_MINE) { playerHit(); return; }
    if (currentType === T_WALL || currentType === T_FILLED_BLUE || currentType === T_FILLED_RED || currentType === T_FLASH || currentType === T_ELECTRIC_WALL) { if (nextType === T_EMPTY) { player.isDrawing = true; currentTrailRelays = []; } }
    if (player.isDrawing) { drawLineOnGrid(Math.round(player.x), Math.round(player.y), gx, gy, T_TRAIL); if (nextType === T_WALL || nextType === T_FILLED_BLUE || nextType === T_FILLED_RED || nextType === T_FLASH || nextType === T_ELECTRIC_WALL) { fillTerritory(); } }
    player.x = nextX; player.y = nextY;
}

function drawLineOnGrid(x0, y0, x1, y1, type) {
    let dx = Math.abs(x1 - x0); let dy = Math.abs(y1 - y0); let sx = (x0 < x1) ? 1 : -1; let sy = (y0 < y1) ? 1 : -1; let err = dx - dy;
    while(true) { if (getCell(x0, y0) === T_MINE) { playerHit(); return; } setCell(x0, y0, type); if (type === T_TRAIL) trailPoints.push({x: x0, y: y0}); if ((x0 === x1) && (y0 === y1)) break; let e2 = 2 * err; if (e2 > -dy) { err -= dy; x0 += sx; } if (e2 < dx) { err += dx; y0 += sy; } }
}

function updateFuse() { if (!fuse.active) return; if (globalEffects.freezeTimer > 0) return; if (fuse.visibleTimer % 20 === 0) AudioController.playFuse(); fuse.index += FUSE_SPEED; fuse.visibleTimer++; if (fuse.index >= trailPoints.length - 1) { playerHit(); return; } }

function fillTerritory() {
    if (isCalculating) return; 
    isCalculating = true;
    
    hunter.active = false; timeSinceLastCapture = 0; 
    if (comboTimer > 0) comboCount++; else comboCount = 1; comboTimer = COMBO_WINDOW; AudioController.playCapture(comboCount); 
    
    if (currentTrailRelays.length >= 2) { showFloatingText(t('float_relay'), player.x, player.y, '#0ff'); AudioController.playRepulse(); triggerShake(10); }

    if (fillWorker) {
        fillWorker.postMessage({
            gridBuffer: grid.buffer, 
            worldWidth: WORLD_WIDTH,
            worldHeight: WORLD_HEIGHT,
            trailPoints: trailPoints,
            qixEntities: qixEntities,
            trailRelaysCount: currentTrailRelays.length
        });
    } else {
        initWorker();
        isCalculating = false; 
    }
}

function updateQix() {
    if (globalEffects.freezeTimer > 0) return;
    qixEntities.forEach(q => {
        if (q.stunTimer > 0) { q.stunTimer--; return; }
        
        // ANTI-QIX ZONE REPULSION (OVERCHARGE BATTERY)
        if (player.antiQixTimer > 0) {
            let dx = q.x - player.x; let dy = q.y - player.y;
            let distSq = dx*dx + dy*dy;
            if (distSq < 22500) { // 150 pixels radius
                let dist = Math.sqrt(distSq);
                // Push Qix away strongly
                q.x += (dx / dist) * 8; 
                q.y += (dy / dist) * 8;
                // Bounce effect
                q.dx = (dx / dist) * currentQixSpeed;
                q.dy = (dy / dist) * currentQixSpeed;
                
                // If extremely close, push harder
                if (dist < 100) {
                    q.x += (dx / dist) * 15; 
                    q.y += (dy / dist) * 15;
                }
                
                // Visual spark effect on contact
                if (Math.random() > 0.5) {
                    createTrailSpark(q.x, q.y);
                }
            }
        }

        for (let pair of portalPairs) { if (checkPortal(q, pair.p1, pair.p2)) break; if (checkPortal(q, pair.p2, pair.p1)) break; }
        if (q.warpTimer <= 0) {
            let magnetRangeSq = 6400; 
            for (let pair of portalPairs) {
                [pair.p1, pair.p2].forEach(p => {
                    let dx = p.x - q.x; let dy = p.y - q.y; let distSq = dx*dx + dy*dy;
                    if (distSq < magnetRangeSq && distSq > 100) { 
                        let dist = Math.sqrt(distSq);
                        q.x += (dx / dist); q.y += (dy / dist);
                        if (Math.random() > 0.8) { particles.push({x: q.x, y: q.y, vx: (dx/dist)*2, vy: (dy/dist)*2, life: 10, color: '#f0f', size: 2, gravity: 0}); }
                    }
                });
            }
        }

        if (q.isBoss) {
            if (q.bossState === 'MOVING') { q.attackTimer--; if (q.attackTimer <= 0) { q.bossState = 'CHARGING'; q.attackTimer = 60; AudioController.playBossCharge(); triggerShake(5); } }
            else if (q.bossState === 'CHARGING') { q.attackTimer--; if (q.attackTimer <= 0) q.bossState = 'FIRING'; }
            else if (q.bossState === 'FIRING') { AudioController.playBossShoot(); triggerShake(8); let dx = player.x - q.x; let dy = player.y - q.y; let dist = Math.sqrt(dx*dx+dy*dy); let speed = 3; projectiles.push({ x: q.x, y: q.y, dx: (dx/dist)*speed, dy: (dy/dist)*speed }); q.bossState = 'MOVING'; q.attackTimer = 120 + Math.random() * 120; }
            if (q.bossState !== 'MOVING') return;
        }
        q.timer--; if (q.timer <= 0 || (Math.abs(q.x - q.targetX) < 5 && Math.abs(q.y - q.targetY) < 5)) pickQixTarget(q);
        let targetX = decoy.active ? decoy.x : q.targetX; let targetY = decoy.active ? decoy.y : q.targetY;
        let angle = Math.atan2(targetY - q.y, targetX - q.x); q.dx = Math.cos(angle) * currentQixSpeed; q.dy = Math.sin(angle) * currentQixSpeed;
        let steps = Math.ceil(currentQixSpeed); let collision = false;
        for (let i = 1; i <= steps; i++) {
            let stepRatio = i / steps; 
            let checkX = q.x + (q.dx * stepRatio); 
            let checkY = q.y + (q.dy * stepRatio);
            
            let killRadius = q.isBoss ? 10 : 6; let hitTrail = false;
            for (let dy = -killRadius; dy <= killRadius; dy += 3) { for (let dx = -killRadius; dx <= killRadius; dx += 3) { if (getCell(Math.round(checkX + dx), Math.round(checkY + dy)) === T_TRAIL) { hitTrail = true; break; } } if (hitTrail) break; }
            if (hitTrail) { playerHit(); collision = true; return; } 
            let centerType = getCell(Math.round(checkX), Math.round(checkY));
            if (centerType === T_ELECTRIC_WALL) { 
                q.stunTimer = 120; 
                createExplosion(checkX, checkY, '#0ff'); 
                pickQixTarget(q); 
                collision = true; 
                AudioController.playDie(); 
                showFloatingText(t('float_stunned'), q.x, q.y, '#0ff'); 
                break; 
            }
            if (centerType === T_WALL || centerType === T_FILLED_BLUE || centerType === T_FILLED_RED || centerType === T_FLASH) { pickQixTarget(q); collision = true; break; }
        }
        if (!collision) { q.x += q.dx; q.y += q.dy; }
    });
}

function pickQixTarget(qEntity) { for(let i=0; i<10; i++) { let rx = Math.floor(Math.random() * WORLD_WIDTH); let ry = Math.floor(Math.random() * WORLD_HEIGHT); let type = getCell(rx, ry); if (type === T_EMPTY || type === T_MINE) { qEntity.targetX = rx; qEntity.targetY = ry; qEntity.timer = 60 + Math.random() * 60; return; } } qEntity.targetX = WORLD_WIDTH/2; qEntity.targetY = WORLD_HEIGHT/2; qEntity.timer = 60; }

function updateSparx() {
    if (globalEffects.freezeTimer > 0) return;
    const steps = Math.max(1, Math.floor(SPARX_SPEED * runUpgrades.sabotage));
    for (let k = 0; k < steps; k++) {
        sparx.forEach((s, index) => {
            if (s.freezeTimer > 0) { s.freezeTimer--; return; }
            
            // ANTI-QIX ZONE REPULSION for Sparx too
            if (player.antiQixTimer > 0) {
                 let dx = s.x - player.x; let dy = s.y - player.y;
                 let distSq = dx*dx + dy*dy;
                 if (distSq < 22500) {
                     // Reverse direction if moving towards player
                     s.dir = (s.dir + 2) % 4; 
                     s.freezeTimer = 20; // Stun briefly
                     createTrailSpark(s.x, s.y);
                 }
            }

            for (let pair of portalPairs) { if (checkPortal(s, pair.p1, pair.p2)) break; if (checkPortal(s, pair.p2, pair.p1)) break; }
            let dx = s.x - player.x; let dy = s.y - player.y; if (dx*dx + dy*dy < 64) { playerHit(); return; } 
            const dirs = [{x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}]; let validMoves = [];
            for (let i = 0; i < 4; i++) {
                let nx = Math.round(s.x) + dirs[i].x * 1; let ny = Math.round(s.y) + dirs[i].y * 1;
                if (nx >= 0 && nx < WORLD_WIDTH && ny >= 0 && ny < WORLD_HEIGHT) {
                    let type = getCell(nx, ny);
                    if (type === T_ELECTRIC_WALL) { s.x = WORLD_WIDTH/2; s.y = 0; s.freezeTimer = 600; createExplosion(nx, ny, '#0ff'); score += 200; return; }
                    if (type === T_WALL || type === T_FILLED_BLUE || type === T_FILLED_RED || type === T_FLASH) { let opposite = (s.dir + 2) % 4; if (i !== opposite) validMoves.push(i); }
                }
            }
            if (validMoves.length === 0) { let back = (s.dir + 2) % 4; validMoves.push(back); }
            if (validMoves.length > 0) {
                if (validMoves.length === 1) s.dir = validMoves[0];
                else {
                    if (index % 2 === 0) { let leftTurn = (s.dir + 3) % 4; if (validMoves.includes(leftTurn)) s.dir = leftTurn; else if (validMoves.includes(s.dir)) s.dir = s.dir; else s.dir = validMoves[0]; } 
                    else { let rightTurn = (s.dir + 1) % 4; if (validMoves.includes(rightTurn)) s.dir = rightTurn; else if (validMoves.includes(s.dir)) s.dir = s.dir; else s.dir = validMoves[0]; }
                }
                s.x += dirs[s.dir].x; s.y += dirs[s.dir].y;
            }
        });
    }
}

function playerHit() {
    if (gameState !== 'PLAYING') return;
    if (player.shield) { player.shield = false; createExplosion(player.x, player.y, '#fff'); updateBonusUI(); gameState = 'RESPAWN'; respawnTimer = 60; triggerShake(10); for(let p of trailPoints) setCell(p.x, p.y, T_EMPTY); trailPoints = []; player.isDrawing = false; resetFuse(); stopPlayer(); AudioController.setDrawSound(false, false); currentTrailRelays = []; return; }
    triggerShake(25); AudioController.playDie(); createExplosion(player.x, player.y, currentTheme.player); lives--; 
    
    // FIX: Mise √† jour imm√©diate de l'interface pour √©viter le d√©calage visuel
    document.getElementById('lives').innerText = lives;
    
    for(let p of trailPoints) setCell(p.x, p.y, T_EMPTY); trailPoints = []; player.isDrawing = false; resetFuse(); stopPlayer(); AudioController.setDrawSound(false, false); currentTrailRelays = [];
    if (lives <= 0) { gameOver(false); } else { gameState = 'RESPAWN'; respawnTimer = 60; }
}

function gameOver(win, customMessage) {
    AudioController.stopQixHum(); AudioController.setDrawSound(false, false); 
    if (win) {
        gameState = 'WIN_ANIMATION'; winAnimTimer = 200; winParticles = []; fireworks = [];
        const step = 30; const cx = WORLD_WIDTH / 2; const cy = WORLD_HEIGHT / 2;
        for(let y=0; y<WORLD_HEIGHT; y+=step) { for(let x=0; x<WORLD_WIDTH; x+=step) { let idx = y*WORLD_WIDTH + x; if(grid[idx] === T_EMPTY || grid[idx] === T_MINE) { winParticles.push({ x: x, y: y, color: `hsl(${Math.random()*360}, 50%, 50%)`, life: 200 }); } } }
        AudioController.playCapture(5); 
    } else {
        // TRIGGER DEFEAT ANIMATION
        gameState = 'GAMEOVER_ANIMATION';
        splashTimer = 180; // 3 seconds splash
        for(let i=0; i<50; i++) {
             particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15, life: 120, color: '#f00', size: 3 + Math.random()*3, gravity: 0.1 });
        }
        // AudioController.playDie(); // Already played in playerHit
    }
}

function finishGameOverSequence() {
    gameState = 'GAMEOVER';
    const overlay = document.getElementById('message-overlay'); const title = document.getElementById('message-title'); const sub = document.getElementById('message-subtitle'); const btn = document.getElementById('action-btn'); const shopBtn = document.getElementById('shop-btn'); const selector = document.getElementById('level-selector');
    document.getElementById('settings-panel').style.display = 'none';
    completedLevels = []; localStorage.removeItem('qix_completed'); currentRunScore = 0; currentRunLives = 3; localStorage.setItem('qix_run_score', 0); localStorage.setItem('qix_run_lives', 3);
    runUpgrades = { speed: 1.0, shield: 0, time: 1.0, lucky: 1.0, greed: 1.0, sabotage: 1.0, hasDecoy: false, hasSweeper: false, hasAlchemy: false, hasStun: false, hasRepulsor: false }; localStorage.setItem('qix_run_upgrades', JSON.stringify(runUpgrades));
    
    // FIX: Affichage du bouton boutique (m√™me si score √† 0, pour coh√©rence UI)
    selector.style.display = 'flex'; title.innerText = t('title_gameover'); title.style.color = "#f0f"; sub.innerText = `${t('score_final')} ${score}`; btn.innerText = t('btn_newgame'); btn.onclick = handleAction; 
    shopBtn.style.display = 'inline-block'; 
    startLevel = 1; updateLevelSelectorUI(); overlay.style.display = 'flex';
    
    MenuNav.refresh();
}

function createFirework(x, y) { let hue = Math.random() * 360; for(let i=0; i<50; i++) { fireworks.push({ x: x, y: y, vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10, life: 60 + Math.random()*30, color: `hsl(${hue}, 100%, 50%)`, size: 2 + Math.random() * 3 }); } }
function finishWinSequence() {
    gameState = 'WIN';
    const overlay = document.getElementById('message-overlay'); const title = document.getElementById('message-title'); const sub = document.getElementById('message-subtitle'); const btn = document.getElementById('action-btn'); const shopBtn = document.getElementById('shop-btn'); const selector = document.getElementById('level-selector');
    document.getElementById('settings-panel').style.display = 'none';
    if (!completedLevels.includes(level)) { completedLevels.push(level); localStorage.setItem('qix_completed', JSON.stringify(completedLevels)); }
    currentRunScore = score; currentRunLives = lives; localStorage.setItem('qix_run_score', currentRunScore); localStorage.setItem('qix_run_lives', currentRunLives);
    
    // MODIFICATION ICI : Utilisation de 'btn_continue' au lieu de 'btn_menu'
    selector.style.display = 'none'; title.innerText = (t('title_win')); title.style.color = "#0f0"; sub.innerText = `${t('score_total')} ${score}`; 
    btn.innerText = t('btn_continue'); 
    btn.onclick = handleAction; btn.disabled = false; shopBtn.style.display = 'none'; overlay.style.display = 'flex';
    
    MenuNav.refresh();
}

function drawDangerIndicators() {
    const padding = 20; const cx = player.x; const cy = player.y; const vx = camera.x; const vy = camera.y; const vw = VIEW_WIDTH; const vh = VIEW_HEIGHT; const targets = [];
    if (hunter.active) targets.push({x: hunter.x, y: hunter.y, color: '#f50', type: 'HUNTER'}); qixEntities.forEach(q => { targets.push({x: q.x, y: q.y, color: q.isBoss ? '#f00' : '#0ff', type: 'QIX'}); });
    targets.forEach(t => {
        if (t.x >= vx && t.x <= vx + vw && t.y >= vy && t.y <= vy + vh) return;
        let dx = t.x - cx; let dy = t.y - cy; let angle = Math.atan2(dy, dx); let tVal = Infinity; const cos = Math.cos(angle); const sin = Math.sin(angle);
        let screenRightDist = (vx + vw) - cx - padding; let screenLeftDist = cx - vx - padding; let screenBottomDist = (vy + vh) - cy - padding; let screenTopDist = cy - vy - padding;
        if (cos > 0) tVal = Math.min(tVal, screenRightDist / cos); else if (cos < 0) tVal = Math.min(tVal, -screenLeftDist / cos);
        if (sin > 0) tVal = Math.min(tVal, screenBottomDist / sin); else if (sin < 0) tVal = Math.min(tVal, -screenTopDist / sin);
        if (tVal === Infinity || tVal < 0) return;
        const ix = cx + tVal * cos; const iy = cy + tVal * sin;
        ctx.save(); ctx.translate(ix - vx, iy - vy); ctx.rotate(angle); ctx.globalAlpha = 0.6 + 0.4 * Math.sin(Date.now() / 200); ctx.fillStyle = t.color; ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-10, 8); ctx.lineTo(-10, -8); ctx.fill(); ctx.restore();
    });
    // Boss Warning Bar
    if (qixEntities.some(q => q.isBoss)) {
        let boss = qixEntities.find(q => q.isBoss);
        if (boss.bossState !== 'MOVING') {
            let color = boss.bossState === 'CHARGING' ? '#fff' : '#f00';
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, VIEW_WIDTH, 5);
            ctx.fillRect(0, VIEW_HEIGHT-5, VIEW_WIDTH, 5);
            ctx.fillRect(0, 0, 5, VIEW_HEIGHT);
            ctx.fillRect(VIEW_WIDTH-5, 0, 5, VIEW_HEIGHT);
        }
    }
}

function drawMiniMap() {
    const mmCanvas = document.getElementById('minimap'); const mmCtx = mmCanvas.getContext('2d');
    const scaleW = mmCanvas.width / WORLD_WIDTH; const scaleH = mmCanvas.height / WORLD_HEIGHT;
    mmCtx.fillStyle = 'rgba(0, 0, 0, 0.5)'; mmCtx.fillRect(0, 0, mmCanvas.width, mmCanvas.height);
    const stride = 20;
    for(let y=0; y<WORLD_HEIGHT; y+=stride) { for(let x=0; x<WORLD_WIDTH; x+=stride) { let type = getCell(x, y); if(type === T_FILLED_BLUE || type === T_FILLED_RED) { mmCtx.fillStyle = type === T_FILLED_BLUE ? '#00f' : '#f00'; mmCtx.fillRect(x * scaleW, y * scaleH, stride * scaleW, stride * scaleH); } } }
    mmCtx.strokeStyle = '#fff'; mmCtx.lineWidth = 1; mmCtx.beginPath();
    if (trailPoints.length > 0) { mmCtx.moveTo(trailPoints[0].x * scaleW, trailPoints[0].y * scaleH); for (let i = 1; i < trailPoints.length; i++) { mmCtx.lineTo(trailPoints[i].x * scaleW, trailPoints[i].y * scaleH); } mmCtx.lineTo(player.x * scaleW, player.y * scaleH); mmCtx.stroke(); }
    mmCtx.fillStyle = '#0f0'; mmCtx.fillRect(player.x * scaleW - 1, player.y * scaleH - 1, 3, 3);
    mmCtx.fillStyle = '#f00'; qixEntities.forEach(q => { mmCtx.fillRect(q.x * scaleW - 1, q.y * scaleH - 1, 3, 3); });
    mmCtx.fillStyle = '#f80'; sparx.forEach(s => { mmCtx.fillRect(s.x * scaleW - 1, s.y * scaleH - 1, 2, 2); });
    if(hunter.active) { mmCtx.fillStyle = '#f50'; mmCtx.fillRect(hunter.x * scaleW - 2, hunter.y * scaleH - 2, 4, 4); }
    if(decoy.active) { mmCtx.fillStyle = '#ff00ff'; mmCtx.fillRect(decoy.x * scaleW - 2, decoy.y * scaleH - 2, 4, 4); }
    if (moles.length > 0) { mmCtx.fillStyle = '#8B4513'; moles.forEach(m => { mmCtx.fillRect(m.x * scaleW - 1, m.y * scaleH - 1, 3, 3); }); }
    if (pulsars.length > 0) { pulsars.forEach(p => { mmCtx.fillStyle = (Math.floor(Date.now()/200)%2===0) ? '#fff' : '#f00'; mmCtx.fillRect(p.x * scaleW - 2, p.y * scaleH - 2, 4, 4); }); }
    if (teslas.length > 0) { mmCtx.fillStyle = '#0ff'; teslas.forEach(t => { mmCtx.fillRect(t.x * scaleW - 2, t.y * scaleH - 2, 4, 4); }); }
    mmCtx.strokeStyle = '#ff0'; mmCtx.lineWidth = 1; mmCtx.strokeRect(camera.x * scaleW, camera.y * scaleH, VIEW_WIDTH * scaleW, VIEW_HEIGHT * scaleH);
}

function draw() {
    if (!currentTheme || !currentTheme.bg) return;
    
    ctx.drawImage(
        terrainCanvas, 
        camera.x, camera.y, VIEW_WIDTH, VIEW_HEIGHT, 
        0, 0, VIEW_WIDTH, VIEW_HEIGHT
    );

    if (trailPoints.length > 0) {
        const cTrailBlue = currentTheme.trailFast; 
        const cTrailRed = currentTheme.trailSlow;
        let col = (player.drawMode === 'FAST') ? cTrailBlue : cTrailRed;
        ctx.fillStyle = `rgb(${col[0]},${col[1]},${col[2]})`;
        
        for(let p of trailPoints) {
            if (p.x >= camera.x && p.x < camera.x + VIEW_WIDTH && p.y >= camera.y && p.y < camera.y + VIEW_HEIGHT) {
                ctx.fillRect(p.x - camera.x, p.y - camera.y, 1, 1);
            }
        }
    }

    ctx.save();
    if (shakeIntensity > 0) { let dx = (Math.random() - 0.5) * shakeIntensity; let dy = (Math.random() - 0.5) * shakeIntensity; ctx.translate(dx, dy); shakeIntensity *= 0.9; if (shakeIntensity < 0.5) shakeIntensity = 0; }
    
    ctx.save(); ctx.fillStyle = "rgba(255, 255, 255, 0.05)"; ctx.font = "bold 150px Courier New"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; let pct = Math.floor(filledPixels / totalPixels * 100); ctx.fillText(pct + "%", VIEW_WIDTH / 2, VIEW_HEIGHT / 2); ctx.restore();

    ctx.save(); ctx.translate(-camera.x, -camera.y);
    const vLeft = camera.x - 20; const vRight = camera.x + VIEW_WIDTH + 20; const vTop = camera.y - 20; const vBottom = camera.y + VIEW_HEIGHT + 20;
    const minePulse = 1 + 0.2 * Math.sin(Date.now() / 100); const mineRadius = 6 * minePulse;
    const nowTime = Date.now();

    mines.forEach(m => { if (m.x < vLeft || m.x > vRight || m.y < vTop || m.y > vBottom) return; ctx.fillStyle = "#f00"; ctx.beginPath(); ctx.arc(m.x, m.y, mineRadius, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(m.x - 2, m.y - 2, 2, 0, Math.PI*2); ctx.fill(); });
    moles.forEach(m => { ctx.save(); ctx.translate(m.x, m.y); ctx.fillStyle = "#8B4513"; ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(-2, -2, 1, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(2, -2, 1, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "#ccc"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-6, 2); ctx.lineTo(-8, 5); ctx.stroke(); ctx.beginPath(); ctx.moveTo(6, 2); ctx.lineTo(8, 5); ctx.stroke(); ctx.restore(); });

    const useGlow = currentTheme.name !== 'Op Art';
    if (useGlow) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
    }

    relays.forEach(r => { let pulse = 1 + 0.3 * Math.sin(Date.now() / 100); ctx.font = `${20 * pulse}px Arial`; ctx.fillStyle = "#0ff"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('‚ö°', r.x, r.y); ctx.strokeStyle = "rgba(0, 255, 255, 0.3)"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(r.x, r.y, 15, 0, Math.PI*2); ctx.stroke(); });

    pulsars.forEach(p => {
        ctx.save(); ctx.translate(p.x, p.y); let charge = p.timer / p.maxTimer; let color = `rgb(${charge * 255}, ${255 - charge * 255}, 0)`; if (charge > 0.9 && Math.floor(Date.now()/50)%2===0) color = "#fff"; ctx.fillStyle = color; ctx.shadowColor = color; ctx.shadowBlur = 10 + charge * 20; ctx.beginPath(); let spikes = 8; let outerRadius = 15 + Math.sin(Date.now()/100)*2; let innerRadius = 7; for(let i=0; i<spikes; i++) { let x = Math.cos(Math.PI*2*i/spikes - Math.PI/2) * outerRadius; let y = Math.sin(Math.PI*2*i/spikes - Math.PI/2) * outerRadius; ctx.lineTo(x, y); x = Math.cos(Math.PI*2*i/spikes - Math.PI/2 + Math.PI/spikes) * innerRadius; y = Math.sin(Math.PI*2*i/spikes - Math.PI/2 + Math.PI/spikes) * innerRadius; ctx.lineTo(x, y); } ctx.closePath(); ctx.fill(); if (p.radius > 0) { ctx.strokeStyle = `rgba(255, 255, 255, ${1 - p.radius/250})`; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(0, 0, p.radius, 0, Math.PI*2); ctx.stroke(); } ctx.restore();
    });
    teslas.forEach(t => {
        ctx.save(); ctx.translate(t.x, t.y); let shake = (t.state === 'CHARGE') ? (Math.random() - 0.5) * 5 : 0; ctx.fillStyle = "#0ff"; ctx.shadowColor = "#00f"; ctx.shadowBlur = (t.state === 'CHARGE') ? 20 : 10; ctx.beginPath(); ctx.arc(shake, shake, 12, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(shake, shake, 6, 0, Math.PI*2); ctx.fill();
        if (t.state === 'CHARGE') { ctx.strokeStyle = "#0ff"; ctx.lineWidth = 1; for(let i=0; i<3; i++) { let a = Math.random() * Math.PI * 2; let r = 15 + Math.random() * 10; ctx.beginPath(); ctx.moveTo(Math.cos(a)*r, Math.sin(a)*r); ctx.lineTo(0,0); ctx.stroke(); } } ctx.restore(); 
        if (t.state === 'FIRE') { ctx.save(); ctx.strokeStyle = "#fff"; ctx.lineWidth = 3; ctx.shadowColor = "#0ff"; ctx.shadowBlur = 15; ctx.beginPath(); ctx.moveTo(t.x, t.y); let dist = Math.hypot(t.targetX - t.x, t.targetY - t.y); let steps = Math.floor(dist / 10); for(let i=1; i<steps; i++) { let r = i / steps; let tx = t.x + (t.targetX - t.x) * r; let ty = t.y + (t.targetY - t.y) * r; let off = (Math.random() - 0.5) * 20; ctx.lineTo(tx + off, ty + off); } ctx.lineTo(t.targetX, t.targetY); ctx.stroke(); ctx.restore(); }
    });

    // DRAW ANTI-QIX ZONE EFFECT
    if (player.antiQixTimer > 0) {
        ctx.save();
        ctx.translate(player.x, player.y);
        
        // Timer Text
        ctx.fillStyle = "#0ff";
        ctx.font = "bold 12px Courier New";
        ctx.textAlign = "center";
        ctx.shadowColor = "#0ff";
        ctx.shadowBlur = 5;
        ctx.fillText((player.antiQixTimer/60).toFixed(1) + "s", 0, -35);
        
        // Boundary Circle
        ctx.strokeStyle = `rgba(0, 255, 255, ${0.2 + 0.1 * Math.sin(Date.now()/50)})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, 150, 0, Math.PI * 2);
        ctx.stroke();

        // Electric Arcs
        let boltCount = 3;
        ctx.strokeStyle = "#0ff";
        ctx.lineWidth = 2;
        ctx.shadowBlur = 10;
        for(let i=0; i<boltCount; i++) {
            let angle = Math.random() * Math.PI * 2;
            let len = 150;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            let cx = 0, cy = 0;
            let steps = 6;
            for(let j=0; j<steps; j++) {
                let r = len/steps;
                cx += Math.cos(angle)*r + (Math.random()-0.5)*30;
                cy += Math.sin(angle)*r + (Math.random()-0.5)*30;
                ctx.lineTo(cx, cy);
            }
            ctx.stroke();
        }
        ctx.restore();
    }

    const particleBatches = {};
    for (let p of particles) {
        if (!particleBatches[p.color]) particleBatches[p.color] = [];
        particleBatches[p.color].push(p);
    }
    for (let color in particleBatches) {
        ctx.fillStyle = color;
        ctx.beginPath();
        for (let p of particleBatches[color]) {
            ctx.rect(p.x, p.y, p.size, p.size);
        }
        ctx.fill();
    }

    if (gameState === 'PLAYING' || gameState === 'RESPAWN' || isPaused || gameState === 'GAMEOVER_ANIMATION') {
        if (player.history.length > 0) { player.history.forEach((pos, idx) => { ctx.globalAlpha = (idx + 1) / player.history.length * 0.3; ctx.fillStyle = '#0ff'; ctx.fillRect(pos.x - 6, pos.y - 6, 12, 12); }); ctx.globalAlpha = 1.0; }

        let breathe = 1 + 0.3 * Math.sin(Date.now() / 250); let qixSize = 40 * breathe;
        let qixColor = (globalEffects.freezeTimer > 0) ? '#0ff' : `hsl(${(Date.now() / 10 + currentTheme.qixBase) % 360}, 100%, 50%)`;
        qixEntities.forEach(q => {
            let size = qixSize; let color = qixColor; if (q.stunTimer > 0) { color = (Math.floor(Date.now() / 50) % 2 === 0) ? '#fff' : '#00f'; size *= 0.9; } else if (q.isBoss) { size *= 1.5; if (q.bossState === 'CHARGING') { color = '#fff'; size *= 0.8; } if (q.bossState === 'FIRING') color = '#f00'; }
            ctx.strokeStyle = color; ctx.shadowColor = color; ctx.shadowBlur = 15; ctx.lineWidth = q.isBoss ? 3 : 2;
            let p1 = {x: q.x, y: q.y}; let p2 = {x: q.x + Math.sin(Date.now()/100)*size, y: q.y + Math.cos(Date.now()/100)*size}; let p3 = {x: q.x + Math.cos(Date.now()/80)*size, y: q.y + Math.sin(Date.now()/80)*size};
            const drawBolt = (start, end) => { ctx.beginPath(); ctx.moveTo(start.x, start.y); let dist = Math.sqrt((end.x - start.x)**2 + (end.y - start.y)**2); let steps = Math.floor(dist / 10); if(steps < 2) { ctx.lineTo(end.x, end.y); } else { for(let i=1; i<steps; i++) { let t = i/steps; let tx = start.x + (end.x - start.x)*t; let ty = start.y + (end.y - start.y)*t; let jitter = (Math.random() - 0.5) * 20; ctx.lineTo(tx + jitter, ty + jitter); } ctx.lineTo(end.x, end.y); } ctx.stroke(); };
            drawBolt(p1, p2); drawBolt(p2, p3); drawBolt(p3, p1); ctx.shadowBlur = 0; if (q.stunTimer > 0) { ctx.fillStyle = '#0ff'; ctx.fillRect(q.x - 20, q.y - 30, 40 * (q.stunTimer / 300), 4); }
        });
        projectiles.forEach(p => { ctx.fillStyle = '#f0f'; ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 10; ctx.shadowColor = '#f0f'; ctx.stroke(); ctx.shadowBlur = 0; });
        playerProjectiles.forEach(p => { ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - p.dx, p.y - p.dy); ctx.stroke(); });
        if (activePowerUp) { let scale = 1 + 0.2 * Math.sin(Date.now() / 100); ctx.font = `${20 * scale}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(activePowerUp.def.icon, activePowerUp.x, activePowerUp.y); }
        if (gameState === 'PLAYING' || (gameState === 'RESPAWN' && Math.floor(Date.now() / 100) % 2 === 0)) {
            if (gameState === 'PLAYING') {
                ctx.fillStyle = '#0f0'; ctx.fillRect(player.x - 6, player.y - 6, 12, 12); 
                if (player.idleTimer > 120) { let timeLeft = Math.ceil((300 - player.idleTimer) / 60); ctx.save(); ctx.fillStyle = (Math.floor(Date.now() / 100) % 2 === 0) ? "#f00" : "#ff0"; ctx.font = "bold 20px Courier New"; ctx.textAlign = "center"; ctx.fillText(timeLeft, player.x, player.y - 25); ctx.restore(); }
                ctx.shadowBlur = 0;
                if (lives > 0) { ctx.beginPath(); ctx.strokeStyle = "rgba(0, 255, 255, 0.6)"; ctx.lineWidth = 3; let arcLen = (Math.PI * 2) / 3; let startAngle = -Math.PI / 2; let displayLives = Math.min(lives, 3); for (let i = 0; i < displayLives; i++) { ctx.beginPath(); ctx.arc(player.x, player.y, 16, startAngle + (i * arcLen) + 0.2, startAngle + ((i+1) * arcLen) - 0.2); ctx.stroke(); } }
                if (player.shield) { ctx.strokeStyle = `rgba(0, 255, 0, ${0.4 + 0.3 * Math.sin(Date.now() / 100)})`; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(player.x, player.y, 22, 0, Math.PI * 2); ctx.stroke(); }
                if (player.speedBoostTimer > 0) { ctx.shadowBlur = 10; ctx.shadowColor = '#ff0'; } else { ctx.shadowBlur = 0; }
                if (keys.Shift || player.drawMode === 'FAST') { ctx.fillStyle = '#fff'; ctx.fillRect(player.x - 2, player.y - 2, 4, 4); }
            }
        }
        if (fuse.active) { let ptIndex = Math.floor(fuse.index); if (ptIndex >= 0 && ptIndex < trailPoints.length) { let pt = trailPoints[ptIndex]; ctx.fillStyle = (Math.floor(fuse.visibleTimer / 4) % 2 === 0) ? '#f00' : '#ff0'; ctx.beginPath(); ctx.arc(pt.x, pt.y, 5, 0, Math.PI * 2); ctx.fill(); } }
        sparx.forEach(s => {
            let drawColor = s.color; if (globalEffects.freezeTimer > 0) drawColor = '#0ff'; else if (Math.floor(Date.now() / 50) % 2 === 0) drawColor = '#fff';
            ctx.fillStyle = drawColor; ctx.beginPath(); ctx.arc(s.x, s.y, 8, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = (globalEffects.freezeTimer > 0) ? '#fff' : s.color; ctx.lineWidth = 2; ctx.stroke();
            if (s.freezeTimer > 0) { ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; let secondsLeft = Math.ceil(s.freezeTimer / 60); let textY = (s.y < 20) ? s.y + 25 : s.y - 10; ctx.lineWidth = 3; ctx.strokeStyle = '#000'; ctx.strokeText(secondsLeft, s.x, textY); ctx.fillStyle = '#f00'; ctx.fillText(secondsLeft, s.x, textY); }
        });
        superSparx.forEach(s => { ctx.save(); ctx.translate(s.x, s.y); ctx.rotate(Date.now() / 100); ctx.fillStyle = s.color; ctx.beginPath(); for (let i = 0; i < 5; i++) { ctx.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * 10, Math.sin((18 + i * 72) / 180 * Math.PI) * 10); ctx.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * 5, Math.sin((54 + i * 72) / 180 * Math.PI) * 5); } ctx.fill(); ctx.restore(); });
        drawDecoy();
    }
    
    if (gameState === 'WIN_ANIMATION') {
        winParticles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = Math.min(1, p.life / 50); ctx.fillRect(p.x, p.y, 10, 10); });
        fireworks.forEach(f => { ctx.fillStyle = f.color; ctx.globalAlpha = Math.min(1, f.life / 30); ctx.beginPath(); ctx.arc(f.x, f.y, f.size, 0, Math.PI*2); ctx.fill(); });
    }

    if (useGlow) ctx.restore(); 
    
    if (gameState === 'GAMEOVER_ANIMATION') {
         ctx.save();
         ctx.translate(camera.x + VIEW_WIDTH/2, camera.y + VIEW_HEIGHT/2);
         
         let shakeX = (Math.random() - 0.5) * 15;
         let shakeY = (Math.random() - 0.5) * 15;
         let scale = 1 + (splashTimer / 180) * 0.5; 
         
         ctx.scale(scale, scale);
         ctx.font = "900 80px 'Courier New'";
         ctx.textAlign = "center";
         ctx.textBaseline = "middle";
         
         ctx.fillStyle = "rgba(255, 0, 0, 0.7)";
         ctx.fillText("GAME OVER", shakeX + 5, shakeY + 5);
         
         ctx.fillStyle = "rgba(0, 255, 255, 0.7)";
         ctx.fillText("GAME OVER", -shakeX - 5, -shakeY - 5);
         
         ctx.fillStyle = "#fff";
         ctx.shadowColor = "#f00";
         ctx.shadowBlur = 20;
         ctx.fillText("GAME OVER", 0, 0);
         
         ctx.restore();
         
         ctx.save();
         ctx.fillStyle = `rgba(50, 0, 0, ${0.3 + 0.1 * Math.sin(Date.now()/50)})`;
         ctx.fillRect(camera.x, camera.y, VIEW_WIDTH, VIEW_HEIGHT);
         ctx.restore();
    }
    
    if (gameState === 'WIN_ANIMATION') {
        ctx.save(); let shakeX = (Math.random() - 0.5) * 8; let shakeY = (Math.random() - 0.5) * 8; 
        ctx.translate(camera.x + VIEW_WIDTH/2 + shakeX, camera.y + VIEW_HEIGHT/2 + shakeY);
        let gradient = ctx.createLinearGradient(0, -60, 0, 60); gradient.addColorStop(0, "#ffd700"); gradient.addColorStop(0.2, "#fffacd"); gradient.addColorStop(0.5, "#ffffff"); gradient.addColorStop(0.8, "#ffd700"); gradient.addColorStop(1, "#b8860b");
        ctx.font = "bold 30px 'Courier New'"; ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.shadowColor = "#000"; ctx.shadowBlur = 5; ctx.fillText("LEVEL CLEARED!", 0, -80);
        ctx.font = "900 120px 'Courier New'"; ctx.fillStyle = gradient; ctx.shadowColor = "#ff4500"; ctx.shadowBlur = 40; ctx.lineWidth = 8; ctx.strokeStyle = "#000"; ctx.strokeText(score, 0, 10); ctx.fillText(score, 0, 10);
        ctx.font = "bold 20px 'Courier New'"; ctx.fillStyle = "#aaa"; ctx.shadowBlur = 0; ctx.fillText("TOTAL POINTS", 0, 80); ctx.restore();
    }
    
    if (gameState === 'PLAYING' || gameState === 'RESPAWN' || isPaused) {
        floatingTexts.forEach(ft => { ctx.font = "bold 24px Courier New"; ctx.fillStyle = ft.color; ctx.textAlign = "center"; ctx.strokeStyle = "#000"; ctx.lineWidth = 3; ctx.strokeText(ft.text, ft.x, ft.y); ctx.fillText(ft.text, ft.x, ft.y); });
        drawMiniMap();
    }

    ctx.restore();
    ctx.save(); ctx.translate(-camera.x, -camera.y);
    if (hunter.active) { 
        if (useGlow) { ctx.save(); ctx.globalCompositeOperation = 'lighter'; }
        let pulse = 1 + 0.2 * Math.sin(Date.now() / 50); let size = 10 * pulse; ctx.save(); ctx.translate(hunter.x, hunter.y); let targetX = decoy.active ? decoy.x : player.x; let targetY = decoy.active ? decoy.y : player.y; let angle = Math.atan2(targetY - hunter.y, targetX - hunter.x); ctx.rotate(angle); ctx.fillStyle = '#f40'; ctx.beginPath(); ctx.moveTo(size, 0); ctx.lineTo(-size, -size/1.5); ctx.lineTo(-size, size/1.5); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0, 3, 0, Math.PI*2); ctx.fill(); ctx.restore(); 
        if (useGlow) { ctx.restore(); }
    }
    ctx.restore();
    if (gameState === 'PLAYING' || gameState === 'RESPAWN' || isPaused) {
        if (player.drawMode === 'FAST' || keys.Shift || player.speedBoostTimer > 0) { let grad = ctx.createRadialGradient(VIEW_WIDTH/2, VIEW_HEIGHT/2, VIEW_HEIGHT/3, VIEW_WIDTH/2, VIEW_HEIGHT/2, VIEW_HEIGHT); grad.addColorStop(0, 'rgba(0,0,0,0)'); grad.addColorStop(1, 'rgba(0,0,0,0.8)'); ctx.fillStyle = grad; ctx.fillRect(0, 0, VIEW_WIDTH, VIEW_HEIGHT); }
        if (levelTime > 0) { let ratio = levelTime / maxLevelTime; let barColor = ratio > 0.3 ? '#0f0' : '#f00'; ctx.fillStyle = barColor; ctx.fillRect(0, 0, VIEW_WIDTH * ratio, 5); }
        if (hunter.active || (qixEntities.some(q => q.isBoss && (q.bossState === 'CHARGING' || q.bossState === 'FIRING')))) { ctx.save(); let jx = (Math.random() - 0.5) * 10; let jy = (Math.random() - 0.5) * 10; ctx.translate(VIEW_WIDTH / 2 + jx, VIEW_HEIGHT / 4 + jy); ctx.font = "bold 40px Courier New"; ctx.fillStyle = "#f00"; ctx.textAlign = "center"; ctx.shadowColor = "#f00"; ctx.shadowBlur = 10; let text = hunter.active ? "HUNTER" : "BOSS WARNING"; ctx.fillText(text, 0, 0); ctx.fillStyle = "rgba(0,0,0,0.5)"; if (Math.random() > 0.5) ctx.fillRect(-150, -25, 300, 4); ctx.restore(); }
        if (comboCount > 1) { ctx.save(); let shake = Math.min(comboCount * 1.5, 10); let dx = (Math.random() - 0.5) * shake; let dy = (Math.random() - 0.5) * shake; ctx.translate(VIEW_WIDTH/2 + dx, 100 + dy); ctx.rotate((Math.random()-0.5) * 0.1); ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStyle = `hsl(${Date.now() / 2 % 360}, 100%, 50%)`; ctx.font = "900 40px Arial"; ctx.shadowColor = "#000"; ctx.shadowBlur = 5; ctx.strokeText(`${comboCount}x COMBO!`, 0, 0); ctx.fillText(`${comboCount}x COMBO!`, 0, 0); ctx.fillStyle = "#fff"; ctx.shadowBlur = 0; let barW = 100 * (comboTimer / COMBO_WINDOW); ctx.fillRect(-50, 25, barW, 6); ctx.restore(); }
        drawDangerIndicators();
    }
    ctx.restore();
}

function loop() { requestAnimationFrame(loop); update(); draw(); }
initGame();
</script>
</body>
</html>
