<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberMetropolis - Simulation de Trafic Urbain 3D</title>

    <!-- META SEO -->
    <meta name="description" content="Une simulation 3D interactive d'une métropole futuriste avec intelligence artificielle de trafic, visualisation en temps réel et contrôles avancés. Explorez une ville cyberpunk avec véhicules autonomes et drones.">
    <meta name="keywords" content="three.js, 3d, simulation, ville futuriste, trafic intelligent, cyberpunk, AI, drones, véhicules autonomes, explosion, néon">
    <meta name="author" content="CyberMetropolis Team">

    <!-- META Open Graph -->
    <meta property="og:title" content="CyberMetropolis - Simulation de Trafic Urbain 3D">
    <meta property="og:description" content="Explorez une métropole futuriste avec simulation de trafic intelligent et visualisation 3D immersive.">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://leonce-equity.com/city/city.png">

    <!-- META Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="CyberMetropolis - Simulation de Trafic Urbain 3D">
    <meta name="twitter:description" content="Explorez une métropole futuriste avec simulation de trafic intelligent et visualisation 3D immersive.">
    <meta name="twitter:image" content="https://leonce-equity.com/city/city.png">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #00ff00;
            font-family: 'Orbitron', 'Courier New', Courier, monospace;
            font-weight: 400;
        }
        
        canvas {
            display: block;
        }

        .hidden {
            display: none !important;
        }
        
        /* Interface principale */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Panneaux */
        .panel {
            position: absolute;
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            pointer-events: all;
            transition: all 0.3s ease;
        }

        #control-panel {
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.9) 0%, rgba(0, 10, 20, 0.9) 100%);
            border: 2px solid #00ff00;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.3), inset 0 0 20px rgba(0, 255, 0, 0.1);
            min-width: 300px;
        }
        
        #control-panel:hover {
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.5), inset 0 0 25px rgba(0, 255, 0, 0.15);
        }
        
        .panel-header {
            font-size: 18px;
            font-weight: 900;
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #00ff00;
            letter-spacing: 2px;
        }
        
        .control-section {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 8px;
            background: rgba(0, 255, 0, 0.05);
        }
        
        .control-label {
            font-size: 12px;
            margin-bottom: 8px;
            color: #66ff66;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-button {
            padding: 8px 15px;
            background: linear-gradient(45deg, #003300, #006600);
            border: 1px solid #00ff00;
            color: #00ff00;
            border-radius: 5px;
            cursor: pointer;
            margin: 2px;
            font-family: 'Orbitron', monospace;
            font-size: 11px;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }
        
        .control-button:hover {
            background: linear-gradient(45deg, #006600, #00aa00);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.4);
            transform: translateY(-1px);
        }
        
        .control-button.active {
            background: linear-gradient(45deg, #00aa00, #00ff00);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
        }
        
        .control-slider {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: linear-gradient(90deg, #003300, #00ff00);
            border-radius: 3px;
            outline: none;
        }
        
        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #00ff00;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        #stats-panel {
            top: 20px;
            right: 20px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(40, 0, 40, 0.9) 0%, rgba(20, 0, 20, 0.9) 100%);
            border: 2px solid #ff00ff;
            border-radius: 12px;
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.3);
            min-width: 250px;
            font-size: 11px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255, 0, 255, 0.2);
        }
        
        .stat-value {
            color: #ff66ff;
            font-weight: 700;
        }
        
        #info-panel {
            bottom: 20px;
            left: 20px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(0, 40, 40, 0.9) 0%, rgba(0, 20, 20, 0.9) 100%);
            border: 2px solid #00ffff;
            border-radius: 12px;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.3);
            max-width: 400px;
            font-size: 11px;
            line-height: 1.4;
        }
        
        #performance-panel {
            bottom: 20px;
            right: 20px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(40, 20, 0, 0.9) 0%, rgba(20, 10, 0, 0.9) 100%);
            border: 2px solid #ffaa00;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.3);
            font-size: 10px;
        }
        
        .performance-bar {
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin: 5px 0;
            overflow: hidden;
        }
        
        .performance-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            transition: width 0.3s ease;
        }
        
        /* Boutons de fenêtre */
        .window-toggle-btn {
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 20px;
            color: #ff3333;
            text-decoration: none;
            text-shadow: 0 0 10px #ff3333;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .window-toggle-btn:hover {
            color: #ffffff;
            transform: scale(1.1);
        }

        #reopen-panel-container {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: all;
            z-index: 101;
        }

        .reopen-btn {
             padding: 5px 10px;
            background: linear-gradient(45deg, #003300, #006600);
            border: 1px solid #00ff00;
            color: #00ff00;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Orbitron', monospace;
            font-size: 12px;
            transition: all 0.2s ease;
            text-transform: uppercase;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }
        .reopen-btn:hover {
            background: linear-gradient(45deg, #006600, #00aa00);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.4);
        }

        /* Effets de lueur globaux */
        .glow-green { text-shadow: 0 0 10px #00ff00; }
        .glow-cyan { text-shadow: 0 0 10px #00ffff; }
        .glow-magenta { text-shadow: 0 0 10px #ff00ff; }
        .glow-orange { text-shadow: 0 0 10px #ffaa00; }
        
        /* Écran de chargement cyberpunk */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }
        
        #loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .cyber-logo {
            font-family: 'Orbitron', monospace;
            font-size: 4rem;
            font-weight: 900;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00, 0 0 60px #00ff00, 0 0 80px #ff00ff, 0 0 100px #ff00ff;
            margin-bottom: 2rem;
            animation: logoGlow 2s ease-in-out infinite alternate;
            letter-spacing: 4px;
        }
        
        .loading-text {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 2rem;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        .progress-container {
            width: 60%;
            max-width: 500px;
            height: 4px;
            background: rgba(0, 255, 0, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 1rem;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00ffff, #00ff00);
            background-size: 200% 100%;
            animation: progressShine 2s linear infinite;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .loading-percentage {
            font-family: 'Orbitron', monospace;
            color: #00ff00;
            font-size: 1rem;
            text-shadow: 0 0 5px #00ff00;
        }
        
        .cyber-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 0, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            z-index: -1;
        }
        
        @keyframes logoGlow {
            0% { text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00, 0 0 60px #ff00ff, 0 0 80px #ff00ff; }
            100% { text-shadow: 0 0 30px #00ff00, 0 0 60px #00ff00, 0 0 90px #ff00ff, 0 0 120px #ff00ff; }
        }
        
        @keyframes progressShine {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .panel {
                font-size: 10px;
                padding: 10px;
                min-width: auto;
                max-width: calc(100vw - 40px);
            }
            
            .panel-header {
                font-size: 14px;
            }
        }
        
        /* Animations */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .pulse { animation: pulse 2s infinite; }
        
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .slide-in { animation: slideIn 0.5s ease-out; }
    </style>
</head>
<body>
    <!-- Conteneur pour les boutons de réouverture -->
    <div id="reopen-panel-container">
        <a href="#" class="reopen-btn" data-lang-key="back">[&lt;-] Retour</a>
        <button id="reopen-control-btn" class="reopen-btn" data-lang-key="controlsBtn">[+] Contrôles</button>
        <button id="reopen-stats-btn" class="reopen-btn" data-lang-key="statsBtn">[+] Stats</button>
        <button id="reopen-info-btn" class="reopen-btn" data-lang-key="infoBtn">[+] Infos</button>
        <button id="reopen-performance-btn" class="reopen-btn" data-lang-key="perfBtn">[+] Perf</button>
    </div>

    <!-- Interface utilisateur HUD -->
    <div id="hud">
        <!-- Panneau de contrôle principal -->
        <div id="control-panel" class="panel slide-in hidden">
            <a class="window-toggle-btn" data-target="control-panel">[-]</a>
            <div class="panel-header glow-green">CYBERMETROPOLIS</div>
            <div class="control-section">
                <div class="control-label" data-lang-key="simControls">Contrôles de Simulation</div>
                <button id="pause-btn" class="control-button" data-lang-key="pause">⏸ Pause</button>
                <button id="reset-btn" class="control-button" data-lang-key="reset">🔄 Reset</button>
                <button id="view-btn" class="control-button" data-lang-key="view">📷 Vue</button>
                <button id="render-mode-btn" class="control-button" data-lang-key="solid">🏢 Solide</button>
                <button id="infrared-btn" class="control-button" data-lang-key="infrared">♨️ Infra</button>
                <button id="convoy-mode-btn" class="control-button" data-lang-key="convoy">🚗 Convoi</button>
                <button id="zeppelin-toggle-btn" class="control-button" data-lang-key="zeppelin">🛸 Zeppelin</button>
            </div>
            <div class="control-section">
                <div class="control-label" data-lang-key="droneFormation">Formation des Drones</div>
                <button id="drone-random" class="control-button active" data-lang-key="random">Aléatoire</button>
                <button id="drone-circle" class="control-button" data-lang-key="circle">Cercle</button>
                <button id="drone-square" class="control-button" data-lang-key="square">Carré</button>
                <button id="drone-heart" class="control-button" data-lang-key="heart">Coeur</button>
                <button id="drone-cross" class="control-button" data-lang-key="cross">Croix</button>
            </div>
            <div class="control-section">
                <div class="control-label" data-lang-key="simSpeed">Vitesse de Simulation</div>
                <input type="range" id="speed-slider" class="control-slider" min="0.1" max="3" step="0.1" value="1">
                <span id="speed-value">1.0x</span>
            </div>
            <div class="control-section">
                <div class="control-label" data-lang-key="trafficDensity">Densité du Trafic</div>
                <input type="range" id="traffic-slider" class="control-slider" min="0.1" max="2" step="0.1" value="1">
                <span id="traffic-value">100%</span>
            </div>
            <div class="control-section">
                <div class="control-label" data-lang-key="language">Langue</div>
                <button class="control-button lang-btn" data-lang="en">EN</button>
                <button class="control-button lang-btn active" data-lang="fr">FR</button>
                <button class="control-button lang-btn" data-lang="de">DE</button>
                <button class="control-button lang-btn" data-lang="es">ES</button>
                <button class="control-button lang-btn" data-lang="zh">ZH</button>
            </div>
        </div>
        
        <!-- Panneau de statistiques -->
        <div id="stats-panel" class="panel slide-in hidden">
            <a class="window-toggle-btn" data-target="stats-panel">[-]</a>
            <div class="panel-header glow-magenta" data-lang-key="statsTitle">STATISTIQUES TEMPS RÉEL</div>
            <div class="stat-item">
                <span data-lang-key="activeVehicles">Véhicules Actifs:</span>
                <span id="vehicle-count" class="stat-value">280</span>
            </div>
            <div class="stat-item">
                <span data-lang-key="blueDrones">Drones Bleus:</span>
                <span id="blue-drone-count" class="stat-value">20</span>
            </div>
            <div class="stat-item">
                <span data-lang-key="redDrones">Drones Rouges:</span>
                <span id="red-drone-count" class="stat-value">10</span>
            </div>
            <div class="stat-item">
                <span data-lang-key="formation">Formation:</span>
                <span id="formation-status" class="stat-value" data-lang-key="random">Aléatoire</span>
            </div>
            <div class="stat-item">
                <span data-lang-key="simTime">Temps Simulation:</span>
                <span id="sim-time" class="stat-value">00:00</span>
            </div>
            <div class="stat-item">
                <span data-lang-key="collisionsAvoided">Collisions Évitées:</span>
                <span id="collision-count" class="stat-value pulse">1,247</span>
            </div>
            <div class="stat-item">
                <span data-lang-key="vehiclesDestroyed">Véhicules Détruits:</span>
                <span id="destroyed-count" class="stat-value">0</span>
            </div>
        </div>
        
        <!-- Panneau d'information -->
        <div id="info-panel" class="panel slide-in hidden">
            <a class="window-toggle-btn" data-target="info-panel">[-]</a>
            <div class="panel-header glow-cyan" data-lang-key="infoTitle">NAVIGATION & CONTRÔLES</div>
            <div><strong>🖱️ Souris/Tactile:</strong></div>
            <div data-lang-key="orbit"> • Clic gauche + glisser : Rotation orbite</div>
            <div data-lang-key="pan"> • Clic droit + glisser : Déplacement panoramique</div>
            <div data-lang-key="zoom"> • Molette/Pincement : Zoom avant/arrière</div>
            <div style="margin-top: 10px;"><strong>🎮 Simulation:</strong></div>
            <div data-lang-key="trafficAI"> • IA de trafic autonome avec évitement</div>
            <div data-lang-key="droneSwarms"> • Formations dynamiques de drones</div>
            <div data-lang-key="tunnelSystem"> • Système de tunnels urbains</div>
            <div data-lang-key="postProcessing"> • Rendu post-processing avec effets bloom</div>
        </div>
        
        <!-- Panneau de performance -->
        <div id="performance-panel" class="panel slide-in hidden">
            <a class="window-toggle-btn" data-target="performance-panel">[-]</a>
            <div class="panel-header glow-orange" data-lang-key="perfTitle">PERFORMANCE</div>
            <div>FPS: <span id="fps-counter">60</span></div>
            <div class="performance-bar">
                <div id="fps-bar" class="performance-fill" style="width: 100%"></div>
            </div>
            <div>GPU: <span id="gpu-usage">45%</span></div>
            <div class="performance-bar">
                <div id="gpu-bar" class="performance-fill" style="width: 45%"></div>
            </div>
        </div>
    </div>

    <!-- Écran de chargement -->
    <div id="loading-screen">
        <div class="cyber-grid"></div>
        <div class="cyber-logo">CYBERMETROPOLIS</div>
        <div class="loading-text">INITIALISATION DU SYSTÈME</div>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <div class="loading-percentage" id="loading-percentage">0%</div>
    </div>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        // Import des modules Three.js
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // --- Configuration de base ---
        let scene, camera, renderer, controls, composer, bloomPass, infraredPass;
        const vehicles = [];
        const blueDrones = [];
        const redDrones = [];
        const buildingColliders = [];
        const allBuildingMeshes = [];
        const housePositions = [];
        const tunnelAreas = [];
        const tunnelEntranceColliders = []; 
        const explosions = [];
        const scrollingAds = [];
        const particlePool = [];
        let zeppelin, zeppelinLaser, raycaster, groundPlane;
        const citySize = 1000;
        const roadWidth = 20;
        const RAYCAST_LAYER = 1;
        
        // Variables de contrôle de simulation
        let simulationSpeed = 1.0;
        let trafficDensity = 1.0;
        let isPaused = false;
        let simulationTime = 0;
        let collisionCount = 1247;
        let destroyedCount = 0;
        let frameCount = 0;
        let lastFPSUpdate = 0;
        let isSolidMode = false;
        let isInfraredMode = false;
        let isConvoyMode = false;
        
        // Variables de chargement
        let loadingProgress = 0;
        let loadingSteps = [
            { name: "CHARGEMENT DES MODULES...", duration: 1000 },
            { name: "GÉNÉRATION DE LA VILLE...", duration: 2000 },
            { name: "INITIALISATION DES VÉHICULES...", duration: 1500 },
            { name: "ACTIVATION DES DRONES...", duration: 1000 },
            { name: "OPTIMISATION DES SHADERS...", duration: 1500 },
            { name: "SYSTÈME PRÊT", duration: 500 }
        ];
        let currentLoadingStep = 0;
        
        // Materials
        let wireframeBuildingMaterial, solidBuildingMaterial, wireframeHouseMaterial, solidHouseMaterial, tunnelEntranceMaterial;
        let solidCarMaterial, solidBusMaterial, solidTruckMaterial;

        // Couleurs
        const buildingColor = 0x00ff00;
        const houseColor = 0xffff00;
        const carColor = 0xff00ff;
        const busColor = 0x00ffff;
        const truckColor = 0xff0000;
        const blueDroneColor = 0x00aaff;
        const redDroneColor = 0xff0000;
        const tunnelColor = 0xffa500;
        const explosionColors = [0xff0000, 0xffa500, 0xffff00, 0xffffff];

        // Gestion des formations de drones
        let droneFormationState = 'random';
        let droneFormationCenter = new THREE.Vector3(0, 350, 0);
        let needsNewDroneTargets = true;

        function simulateLoading() {
            return new Promise((resolve) => {
                function nextStep() {
                    if (currentLoadingStep < loadingSteps.length) {
                        const step = loadingSteps[currentLoadingStep];
                        const progressPercent = (currentLoadingStep / loadingSteps.length) * 100;
                        
                        document.querySelector('.loading-text').textContent = step.name;
                        document.getElementById('progress-bar').style.width = progressPercent + '%';
                        document.getElementById('loading-percentage').textContent = Math.round(progressPercent) + '%';
                        
                        currentLoadingStep++;
                        
                        setTimeout(nextStep, step.duration);
                    } else {
                        document.getElementById('progress-bar').style.width = '100%';
                        document.getElementById('loading-percentage').textContent = '100%';
                        setTimeout(() => {
                            const loadingScreen = document.getElementById('loading-screen');
                            loadingScreen.classList.add('fade-out');
                            
                            // Les panneaux restent fermés au démarrage.
                            setTimeout(() => {
                                loadingScreen.style.display = 'none';
                            }, 1000);
                            
                            resolve();
                        }, 500);
                    }
                }
                nextStep();
            });
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a2a);
            scene.fog = new THREE.Fog(0x000000, 1, 1500);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(250, 200, 250);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Limitation du pixel ratio pour améliorer les performances
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);
            
            initLights();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.minDistance = 50;
            controls.maxDistance = 1200;
            
            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.8, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.5;
            bloomPass.radius = 0.8;

            // Infrared Shader
            const InfraredShader = {
                uniforms: { 'tDiffuse': { value: null } },
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    varying vec2 vUv;
                    void main() {
                        vec4 tex = texture2D(tDiffuse, vUv);
                        float luma = dot(tex.rgb, vec3(0.299, 0.587, 0.114));
                        vec3 color = vec3(0.0);
                        color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(0.0, 0.2, luma));
                        color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(0.2, 0.5, luma));
                        color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(0.5, 0.8, luma));
                        color = mix(color, vec3(1.0, 1.0, 1.0), smoothstep(0.8, 1.0, luma));
                        gl_FragColor = vec4(color, 1.0);
                    }`
            };
            infraredPass = new ShaderPass(InfraredShader);
            infraredPass.enabled = false;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(infraredPass);

            initMaterials();
            initParticlePool();
            createCityGrid();
            createTunnels();
            createBuildings();
            createHouses();
            createVehicles();
            createBlueDrones();
            createRedDrones();
            createZeppelin();
            
            setupUI();
            setInterval(changeDroneFormation, 20000);
            setInterval(updateStats, 1000);
            window.addEventListener('resize', onWindowResize, false);
            
            // Simuler le chargement puis démarrer l'animation
            simulateLoading().then(() => {
                animate();
            });
        }

        function initLights() {
            // Éclairage ambiant cyberpunk plus sombre
            const nightAmbient = new THREE.AmbientLight(0x0033ff, 0.15);
            scene.add(nightAmbient);
            
            // Lumière directionnelle principale avec couleur cyberpunk
            const nightDir1 = new THREE.DirectionalLight(0x00ff88, 0.6);
            nightDir1.position.set(1, 1, 1);
            nightDir1.castShadow = true;
            scene.add(nightDir1);
            
            // Lumière d'accent cyan
            const nightDir2 = new THREE.DirectionalLight(0x00ffff, 0.4);
            nightDir2.position.set(-1, 0.5, -1);
            scene.add(nightDir2);
            
            // Lumière de remplissage magenta
            const accentLight = new THREE.DirectionalLight(0xff0088, 0.3);
            accentLight.position.set(0, -1, 0.5);
            scene.add(accentLight);
            
            // Ajout de particules atmosphériques
            createAtmosphericParticles();
        }
        
        function createAtmosphericParticles() {
            const particleCount = 1000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * citySize * 2;
                positions[i * 3 + 1] = Math.random() * 500;
                positions[i * 3 + 2] = (Math.random() - 0.5) * citySize * 2;
                
                // Couleurs cyberpunk aléatoires
                const colorChoice = Math.random();
                if (colorChoice < 0.4) {
                    colors[i * 3] = 0; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1; // Cyan
                } else if (colorChoice < 0.7) {
                    colors[i * 3] = 0; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 0; // Vert
                } else {
                    colors[i * 3] = 1; colors[i * 3 + 1] = 0; colors[i * 3 + 2] = 1; // Magenta
                }
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
            
            // Animation des particules
            function animateParticles() {
                const positions = particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3 + 1] -= 0.5; // Chute lente
                    if (positions[i * 3 + 1] < 0) {
                        positions[i * 3 + 1] = 500; // Reset en haut
                    }
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
                requestAnimationFrame(animateParticles);
            }
            animateParticles();
        }

        function initMaterials() {
            wireframeBuildingMaterial = new THREE.MeshBasicMaterial({ color: buildingColor, wireframe: true });
            solidBuildingMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x002244, transmission: 0.9, roughness: 0.1, metalness: 0.2,
                reflectivity: 0.9, ior: 1.5, transparent: true, opacity: 0.8
            });

            wireframeHouseMaterial = new THREE.MeshBasicMaterial({ color: houseColor, wireframe: true });
            solidHouseMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x444400, transmission: 0.8, roughness: 0.2, metalness: 0.1,
                reflectivity: 0.7, ior: 1.4, transparent: true, opacity: 0.85
            });
            
            tunnelEntranceMaterial = new THREE.MeshBasicMaterial({ color: tunnelColor, wireframe: true });

            solidCarMaterial = new THREE.MeshStandardMaterial({ color: carColor, metalness: 0.8, roughness: 0.2 });
            solidBusMaterial = new THREE.MeshStandardMaterial({ color: busColor, metalness: 0.8, roughness: 0.2 });
            solidTruckMaterial = new THREE.MeshStandardMaterial({ color: truckColor, metalness: 0.8, roughness: 0.2 });
        }

        function initParticlePool() {
            const particleGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            for (let i = 0; i < 2500; i++) {
                const material = new THREE.MeshBasicMaterial({
                    color: explosionColors[i % explosionColors.length],
                    transparent: true,
                    opacity: 0
                });
                const particle = new THREE.Mesh(particleGeo, material);
                particle.visible = false;
                scene.add(particle);
                particlePool.push(particle);
            }
        }

        function setupUI() {
            document.getElementById('pause-btn').addEventListener('click', () => {
                isPaused = !isPaused;
                updateLanguage();
            });
            
            document.getElementById('reset-btn').addEventListener('click', () => {
                resetSimulation();
            });
            
            document.getElementById('view-btn').addEventListener('click', () => {
                const views = [ { pos: [250, 200, 250], target: [0, 0, 0] }, { pos: [0, 500, 0], target: [0, 0, 0] }, { pos: [400, 100, 0], target: [0, 0, 0] }, { pos: [-300, 150, 300], target: [0, 0, 0] }];
                const view = views[Math.floor(Math.random() * views.length)];
                camera.position.set(...view.pos);
                controls.target.set(...view.target);
                controls.update();
            });

            document.getElementById('render-mode-btn').addEventListener('click', () => {
                isSolidMode = !isSolidMode;
                updateLanguage();

                allBuildingMeshes.forEach(item => {
                    if (item.type === 'building') item.mesh.material = isSolidMode ? solidBuildingMaterial : wireframeBuildingMaterial;
                    else if (item.type === 'house') item.mesh.material = isSolidMode ? solidHouseMaterial : wireframeHouseMaterial;
                });

                vehicles.forEach(v => {
                    v.object.material = isSolidMode ? v.solidMaterial : v.wireframeMaterial;
                });

                tunnelEntranceMaterial.wireframe = !isSolidMode;
            });

            document.getElementById('infrared-btn').addEventListener('click', (e) => {
                isInfraredMode = !isInfraredMode;
                e.target.classList.toggle('active', isInfraredMode);
                infraredPass.enabled = isInfraredMode;
                bloomPass.enabled = !isInfraredMode;
            });

            document.getElementById('convoy-mode-btn').addEventListener('click', () => {
                toggleConvoyMode();
                updateLanguage();
            });

            document.getElementById('zeppelin-toggle-btn').addEventListener('click', (e) => {
                zeppelin.visible = !zeppelin.visible;
                e.target.classList.toggle('active', zeppelin.visible);
            });
            
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const lang = e.target.dataset.lang;
                    document.documentElement.lang = lang;
                    updateLanguage();
                    document.querySelector('.lang-btn.active').classList.remove('active');
                    e.target.classList.add('active');
                });
            });

            document.getElementById('drone-random').addEventListener('click', () => setDroneFormation('random'));
            document.getElementById('drone-circle').addEventListener('click', () => setDroneFormation('circle'));
            document.getElementById('drone-square').addEventListener('click', () => setDroneFormation('square'));
            document.getElementById('drone-heart').addEventListener('click', () => setDroneFormation('heart'));
            document.getElementById('drone-cross').addEventListener('click', () => setDroneFormation('cross'));
            
            document.getElementById('speed-slider').addEventListener('input', (e) => {
                simulationSpeed = parseFloat(e.target.value);
                document.getElementById('speed-value').textContent = simulationSpeed.toFixed(1) + 'x';
            });
            
            document.getElementById('traffic-slider').addEventListener('input', (e) => {
                trafficDensity = parseFloat(e.target.value);
                document.getElementById('traffic-value').textContent = Math.round(trafficDensity * 100) + '%';
            });

            document.querySelectorAll('.window-toggle-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const targetPanelId = e.target.dataset.target;
                    document.getElementById(targetPanelId).classList.add('hidden');
                    let reopenBtnId = (targetPanelId === 'performance-panel') ? 'reopen-performance-btn' : `reopen-${targetPanelId.split('-')[0]}-btn`;
                    const reopenBtn = document.getElementById(reopenBtnId);
                    if (reopenBtn) reopenBtn.classList.remove('hidden');
                });
            });

            document.querySelectorAll('.reopen-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    let targetPanelId = (e.target.id === 'reopen-performance-btn') ? 'performance-panel' : e.target.id.replace('reopen-', '').replace('-btn', '-panel');
                    const targetPanel = document.getElementById(targetPanelId);
                    if (targetPanel) targetPanel.classList.remove('hidden');
                    e.target.classList.add('hidden');
                });
            });
            updateLanguage();
        }
        
        function toggleConvoyMode() {
            isConvoyMode = !isConvoyMode;
            if (isConvoyMode) {
                setupConvoys();
            } else {
                disbandConvoys();
            }
        }

        function setupConvoys() {
            disbandConvoys(); // Clear previous setup
            let lastLeader = null;
            let convoyCount = 0;
            vehicles.forEach((v, i) => {
                if (i % 5 === 0) { // Every 5th vehicle is a leader
                    v.isLeader = true;
                    lastLeader = v;
                    convoyCount = 0;
                } else if (lastLeader && convoyCount < 4) {
                    v.isFollower = true;
                    v.leader = lastLeader;
                    convoyCount++;
                }
            });
        }

        function disbandConvoys() {
            vehicles.forEach(v => {
                v.isLeader = false;
                v.isFollower = false;
                v.leader = null;
            });
        }

        function setDroneFormation(formation) {
            droneFormationState = formation;
            needsNewDroneTargets = true;
            
            document.querySelectorAll('#control-panel .control-button').forEach(btn => {
                if (btn.id.includes('drone-')) btn.classList.remove('active');
            });
            document.getElementById(`drone-${formation}`).classList.add('active');
            
            updateLanguage();
        }
        
        function resetSimulation() {
            simulationTime = 0;
            collisionCount = 0;
            destroyedCount = 0;
            document.getElementById('destroyed-count').textContent = destroyedCount;
            vehicles.forEach(v => resetVehicle(v.object, v.direction, v.size));
            blueDrones.forEach(d => {
                d.object.position.set(
                    Math.random() * citySize - citySize / 2,
                    Math.random() * 150 + 300,
                    Math.random() * citySize - citySize / 2
                );
            });
        }
        
        function updateStats() {
            if (!isPaused) {
                simulationTime += 1;
                if (Math.random() < 0.3) collisionCount += Math.floor(Math.random() * 3);
            }
            
            const minutes = Math.floor(simulationTime / 60);
            const seconds = simulationTime % 60;
            document.getElementById('sim-time').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('collision-count').textContent = collisionCount.toLocaleString();
            document.getElementById('destroyed-count').textContent = destroyedCount.toLocaleString();
            
            const gpu = 30 + Math.random() * 40;
            document.getElementById('gpu-usage').textContent = Math.round(gpu) + '%';
            document.getElementById('gpu-bar').style.width = gpu + '%';
        }

        function createCityGrid() {
            const gridHelper = new THREE.GridHelper(citySize, citySize / roadWidth, 0x005500, 0x005500);
            gridHelper.position.y = -0.5;
            scene.add(gridHelper);

            // Create ground plane for raycasting
            const groundGeo = new THREE.PlaneGeometry(citySize, citySize);
            const groundMat = new THREE.MeshBasicMaterial({ visible: false });
            groundPlane = new THREE.Mesh(groundGeo, groundMat);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.layers.enable(RAYCAST_LAYER);
            scene.add(groundPlane);
        }

        function createTunnels() {
            const tunnelMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
            const tunnels = [
                { x: 0, z: 0, length: 400, rotation: 0 }, { x: 200, z: 0, length: 500, rotation: Math.PI / 2 },
                { x: -200, z: 100, length: 300, rotation: Math.PI / 2 }, { x: 300, z: 200, length: 400, rotation: 0 },
                { x: -300, z: -250, length: 350, rotation: 0 }, { x: 150, z: -300, length: 600, rotation: Math.PI / 2 },
                { x: -400, z: 0, length: 400, rotation: Math.PI / 2 }, { x: 400, z: -100, length: 250, rotation: 0 },
                { x: -100, z: 300, length: 500, rotation: 0 }
            ];

            tunnels.forEach(t => {
                const floorGeo = new THREE.PlaneGeometry(roadWidth, t.length);
                const floor = new THREE.Mesh(floorGeo, tunnelMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(t.x, -1, t.z);
                if (t.rotation !== 0) floor.rotation.z = t.rotation;
                scene.add(floor);
                const entranceGeo = new THREE.BoxGeometry(roadWidth + 4, 20, 5);
                const entrance1 = new THREE.Mesh(entranceGeo, tunnelEntranceMaterial);
                const entrance2 = new THREE.Mesh(entranceGeo, tunnelEntranceMaterial);
                const offset = t.length / 2;
                let tunnelBox, entranceBox1, entranceBox2;
                if (t.rotation === 0) {
                    entrance1.position.set(t.x, 10, t.z - offset); entrance2.position.set(t.x, 10, t.z + offset);
                    tunnelBox = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(t.x, 0, t.z), new THREE.Vector3(roadWidth, 40, t.length));
                    entranceBox1 = new THREE.Box3().setFromCenterAndSize(entrance1.position, new THREE.Vector3(roadWidth + 20, 40, 20));
                    entranceBox2 = new THREE.Box3().setFromCenterAndSize(entrance2.position, new THREE.Vector3(roadWidth + 20, 40, 20));
                } else {
                    entrance1.position.set(t.x - offset, 10, t.z); entrance2.position.set(t.x + offset, 10, t.z);
                    entrance1.rotation.y = Math.PI / 2; entrance2.rotation.y = Math.PI / 2;
                    tunnelBox = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(t.x, 0, t.z), new THREE.Vector3(t.length, 40, roadWidth));
                    entranceBox1 = new THREE.Box3().setFromCenterAndSize(entrance1.position, new THREE.Vector3(20, 40, roadWidth + 20));
                    entranceBox2 = new THREE.Box3().setFromCenterAndSize(entrance2.position, new THREE.Vector3(20, 40, roadWidth + 20));
                }
                tunnelAreas.push(tunnelBox);
                tunnelEntranceColliders.push(entranceBox1, entranceBox2);
                buildingColliders.push(entranceBox1, entranceBox2);
                scene.add(entrance1);
                scene.add(entrance2);
            });
        }

        function createBuildings() {
            const buildingGeometry = new THREE.BoxGeometry(1, 1, 1);
            const buildingGroup = new THREE.Group();
            const margin = 50;
            const innerCitySize = citySize - margin * 2;
            const gridSnap = roadWidth * 1.5;
            let createdCount = 0;
            let totalAttempts = 0;
            // Réduction du nombre de bâtiments pour améliorer les performances
            while (createdCount < 80 && totalAttempts < 3000) {
                totalAttempts++;
                const height = Math.random() * 250 + 50;
                const scaleX = Math.random() * 30 + 15;
                const scaleZ = Math.random() * 30 + 15;
                const x = Math.random() * innerCitySize - innerCitySize / 2;
                const z = Math.random() * innerCitySize - innerCitySize / 2;
                const tempPosition = new THREE.Vector3(Math.round(x / gridSnap) * gridSnap, height / 2, Math.round(z / gridSnap) * gridSnap);
                const tempBox = new THREE.Box3().setFromCenterAndSize(tempPosition, new THREE.Vector3(scaleX, height, scaleZ));
                let intersects = false;
                for (const existingCollider of buildingColliders) { if (existingCollider.intersectsBox(tempBox)) { intersects = true; break; } }
                if (!intersects) {
                    const building = new THREE.Mesh(buildingGeometry, wireframeBuildingMaterial);
                    building.position.copy(tempPosition);
                    building.scale.set(scaleX, height, scaleZ);
                    building.layers.enable(RAYCAST_LAYER);
                    buildingColliders.push(tempBox);
                    allBuildingMeshes.push({mesh: building, type: 'building'});
                    buildingGroup.add(building);
                    createdCount++;

                    if (height > 150 && Math.random() < 0.25) {
                        createAdOnBuilding(building, height, scaleX, scaleZ, buildingGroup);
                    }
                }
            }
            scene.add(buildingGroup);
        }
        
        function createAdOnBuilding(building, height, scaleX, scaleZ, group) {
            const adTexts = [
                "CYBERTECH • Votre avenir commence ici", "NEURO-LINK • Connectez votre esprit", "QUANTUM-CORP • L'IA qui vous comprend",
                "URBAN-FLOW • Transport intelligent", "DIGITAL-DREAMS • Réalité augmentée", "CYBER-SECURITY • Protection totale",
                "SMART-CITY • Ville intelligente 2084", "NEURAL-INTERFACE • Pensée amplifiée", "FUSION-ENERGY • Énergie propre",
                "DATA-STREAM • Information en temps réel", "HOLO-DISPLAYS • Affichage 3D", "CYBER-DEFENSE • Sécurité maximale",
                "NANO-TECH • Technologie microscopique", "AI-ASSISTANT • Assistant personnel", "VIRTUAL-REALITY • Monde parallèle",
                "DRONE-DELIVERY • Livraison autonome", "BIOMETRIC-ID • Identification unique", "CLOUD-COMPUTING • Puissance infinie"
            ];
            const adText = adTexts[Math.floor(Math.random() * adTexts.length)];

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const font_size = 48;
            const canvasWidth = 1024;
            const canvasHeight = 128;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            context.font = `bold ${font_size}px Orbitron`;

            const texture = new THREE.CanvasTexture(canvas);
            const adMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.9 });

            const adHeight = height * 0.15;
            const adWidth = Math.random() > 0.5 ? scaleX : scaleZ;
            const adGeo = new THREE.PlaneGeometry(adWidth * 0.9, adHeight);
            
            const ad1 = new THREE.Mesh(adGeo, adMaterial);
            
            const canvas2 = document.createElement('canvas');
            canvas2.width = canvasWidth;
            canvas2.height = canvasHeight;
            const context2 = canvas2.getContext('2d');
            context2.font = `bold ${font_size}px Orbitron`;
            const texture2 = new THREE.CanvasTexture(canvas2);
            const adMaterial2 = new THREE.MeshBasicMaterial({ map: texture2, transparent: true, opacity: 0.9 });
            const ad2 = new THREE.Mesh(adGeo, adMaterial2);

            const adY = height - adHeight / 2;

            if (adWidth === scaleX) {
                ad1.position.set(building.position.x, adY, building.position.z + scaleZ / 2 + 0.1);
                ad2.position.set(building.position.x, adY, building.position.z - scaleZ / 2 - 0.1);
                ad2.rotation.y = Math.PI;
            } else {
                ad1.position.set(building.position.x + scaleX / 2 + 0.1, adY, building.position.z);
                ad1.rotation.y = Math.PI / 2;
                ad2.position.set(building.position.x - scaleX / 2 - 0.1, adY, building.position.z);
                ad2.rotation.y = -Math.PI / 2;
            }
            
            group.add(ad1);
            group.add(ad2);

            const textWidth = context.measureText(adText).width;
            scrollingAds.push({ context, text: adText, canvas, texture, x: canvas.width, textWidth });
            scrollingAds.push({ context: context2, text: adText, canvas: canvas2, texture: texture2, x: canvas.width, textWidth });
        }

        function createHouses() {
            const houseGeometry = new THREE.BoxGeometry(1, 1, 1);
            const houseGroup = new THREE.Group();
            const margin = 50;
            const innerCitySize = citySize - margin * 2;
            const gridSnap = roadWidth * 1.5;
            let createdCount = 0;
            let totalAttempts = 0;
            while (createdCount < 30 && totalAttempts < 2000) {
                totalAttempts++;
                const height = Math.random() * 20 + 10;
                const scaleX = Math.random() * 10 + 8;
                const scaleZ = Math.random() * 10 + 8;
                const x = Math.random() * innerCitySize - innerCitySize / 2;
                const z = Math.random() * innerCitySize - innerCitySize / 2;
                const tempPosition = new THREE.Vector3(Math.round(x / gridSnap) * gridSnap, height / 2, Math.round(z / gridSnap) * gridSnap);
                const tempBox = new THREE.Box3().setFromCenterAndSize(tempPosition, new THREE.Vector3(scaleX, height, scaleZ));
                let intersects = false;
                for (const existingCollider of buildingColliders) { if (existingCollider.intersectsBox(tempBox)) { intersects = true; break; } }
                if (!intersects) {
                    const house = new THREE.Mesh(houseGeometry, wireframeHouseMaterial);
                    house.position.copy(tempPosition);
                    house.scale.set(scaleX, height, scaleZ);
                    house.layers.enable(RAYCAST_LAYER);
                    buildingColliders.push(tempBox);
                    allBuildingMeshes.push({mesh: house, type: 'house'});
                    housePositions.push(house.position.clone());
                    houseGroup.add(house);
                    createdCount++;
                }
            }
            scene.add(houseGroup);
        }

        function createVehicles() {
            // Réduction initiale pour améliorer les performances de chargement
            for (let i = 0; i < Math.floor(150 * trafficDensity); i++) createVehicle('car');
            for (let i = 0; i < Math.floor(40 * trafficDensity); i++) createVehicle('bus');
            for (let i = 0; i < Math.floor(25 * trafficDensity); i++) createVehicle('truck');
        }

        function createVehicle(type) {
            let size, color, solidMaterial;
            switch(type) {
                case 'bus': size = { w: 4, h: 4, d: 12 }; color = busColor; solidMaterial = solidBusMaterial; break;
                case 'truck': size = { w: 4.5, h: 5, d: 10 }; color = truckColor; solidMaterial = solidTruckMaterial; break;
                case 'car': default: size = { w: 3, h: 3, d: 6 }; color = carColor; solidMaterial = solidCarMaterial; break;
            }
            const vehicleGeometry = new THREE.BoxGeometry(size.w, size.h, size.d);
            const wireframeMaterial = new THREE.MeshBasicMaterial({ color: color, wireframe: true });
            const vehicle = new THREE.Mesh(vehicleGeometry, wireframeMaterial);
            const speed = Math.random() * 1.0 + 0.5;
            const direction = new THREE.Vector3();
            resetVehicle(vehicle, direction, size);
            vehicles.push({ 
                object: vehicle, speed, direction, size,
                stuckTimer: 0, lastPosition: new THREE.Vector3(),
                wireframeMaterial, solidMaterial
            });
            scene.add(vehicle);
        }

        function createBlueDrones() {
            for (let i = 0; i < 20; i++) {
                const droneGeometry = new THREE.OctahedronGeometry(2.5, 0);
                const wireframeGeometry = new THREE.EdgesGeometry(droneGeometry);
                const material = new THREE.LineBasicMaterial({ color: blueDroneColor });
                const drone = new THREE.LineSegments(wireframeGeometry, material);
                const x = Math.random() * citySize - citySize / 2;
                const y = Math.random() * 150 + 300;
                const z = Math.random() * citySize - citySize / 2;
                drone.position.set(x, y, z);
                const target = new THREE.Vector3(Math.random() * citySize - citySize / 2, Math.random() * 150 + 300, Math.random() * citySize - citySize / 2);
                blueDrones.push({ object: drone, target: target, speed: Math.random() * 0.5 + 0.2 });
                scene.add(drone);
            }
        }

        function createRedDrones() {
            for (let i = 0; i < 10; i++) {
                const droneGeometry = new THREE.IcosahedronGeometry(1.5, 0);
                const wireframeGeometry = new THREE.EdgesGeometry(droneGeometry);
                const material = new THREE.LineBasicMaterial({ color: redDroneColor });
                const drone = new THREE.LineSegments(wireframeGeometry, material);
                const x = Math.random() * citySize - citySize / 2;
                const y = Math.random() * 100 + 250;
                const z = Math.random() * citySize - citySize / 2;
                drone.position.set(x, y, z);
                const target = new THREE.Vector3(Math.random() * citySize - citySize / 2, Math.random() * 100 + 250, Math.random() * citySize - citySize / 2);
                redDrones.push({
                    object: drone, target: target, speed: Math.random() * 0.4 + 0.1,
                    explosionTimer: Math.random() * 1000 + 500
                });
                scene.add(drone);
            }
        }
        
        function createZeppelin() {
            zeppelin = new THREE.Group();
            
            const bodyGeo = new THREE.CapsuleGeometry(20, 80, 20, 32);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.9, roughness: 0.1 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.z = Math.PI / 2;
            zeppelin.add(body);

            const gondolaGeo = new THREE.BoxGeometry(15, 8, 20);
            const gondolaMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });
            const gondola = new THREE.Mesh(gondolaGeo, gondolaMat);
            gondola.position.y = -25;
            zeppelin.add(gondola);

            const laserGeo = new THREE.CylinderGeometry(0.5, 0.5, 1, 8);
            laserGeo.translate(0, -0.5, 0); // Move pivot to the top
            const laserMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.7,
                blending: THREE.AdditiveBlending 
            });
            zeppelinLaser = new THREE.Mesh(laserGeo, laserMat);
            zeppelinLaser.rotation.x = THREE.MathUtils.degToRad(15);
            zeppelin.add(zeppelinLaser);

            zeppelin.position.set(0, 400, 0);
            zeppelin.visible = false;
            scene.add(zeppelin);
            
            raycaster = new THREE.Raycaster();
            raycaster.layers.set(RAYCAST_LAYER);
        }
        
        function resetVehicle(vehicle, direction, size) {
            const laneOffset = roadWidth / 4;
            let positionOk = false;
            let attempts = 0;
            const halfCity = citySize / 2;
            const roadCount = citySize / roadWidth;

            vehicle.visible = false; 

            while (!positionOk && attempts < 200) {
                attempts++;
                let potentialPosition = new THREE.Vector3();

                if (Math.random() > 0.5) {
                    const roadIndex = Math.floor(Math.random() * roadCount) - roadCount / 2;
                    const xPos = roadIndex * roadWidth + laneOffset;
                    const zPos = Math.random() * citySize - halfCity;
                    potentialPosition.set(xPos, 1.5, zPos);
                    direction.set(0, 0, Math.random() > 0.5 ? 1 : -1);
                } else {
                    const roadIndex = Math.floor(Math.random() * roadCount) - roadCount / 2;
                    const zPos = roadIndex * roadWidth + laneOffset;
                    const xPos = Math.random() * citySize - halfCity;
                    potentialPosition.set(xPos, 1.5, zPos);
                    direction.set(Math.random() > 0.5 ? 1 : -1, 0, 0);
                }

                const vehicleBox = new THREE.Box3();
                const vehicleDimensions = new THREE.Vector3(size.w, size.h, size.d);
                if (direction.x !== 0) {
                    vehicleDimensions.set(size.d, size.h, size.w);
                }
                vehicleBox.setFromCenterAndSize(potentialPosition, vehicleDimensions);

                let intersectsBuilding = false;
                for (const box of buildingColliders) {
                    if (box.intersectsBox(vehicleBox)) {
                        intersectsBuilding = true;
                        break;
                    }
                }

                let inTunnel = false;
                for (const tunnel of tunnelAreas) {
                    if (tunnel.intersectsBox(vehicleBox)) {
                        inTunnel = true;
                        break;
                    }
                }

                let intersectsVehicle = false;
                for (const v of vehicles) {
                    if (v.object !== vehicle && v.object.visible && v.object.position.distanceTo(potentialPosition) < 15) {
                        intersectsVehicle = true;
                        break;
                    }
                }

                if (!intersectsBuilding && !inTunnel && !intersectsVehicle) {
                    positionOk = true;
                    vehicle.position.copy(potentialPosition);
                    if (direction.x !== 0) {
                        vehicle.rotation.y = direction.x > 0 ? Math.PI / 2 : -Math.PI / 2;
                    } else {
                        vehicle.rotation.y = direction.z > 0 ? 0 : Math.PI;
                    }
                    vehicle.visible = true; 
                }
            }
        }

        function turnVehicle(vehicleData, turnDirection) {
            const axis = new THREE.Vector3(0, 1, 0);
            const angle = turnDirection === 'left' ? Math.PI / 2 : -Math.PI / 2;
            vehicleData.direction.applyAxisAngle(axis, angle).round();
            vehicleData.object.rotation.y += angle;
        }

        function updateVehicles() {
            if (isPaused) return;
            
            const halfCity = citySize / 2;
            const stuckThreshold = 180;
            const followDistance = 20;

            vehicles.forEach(v => {
                const vehicle = v.object;
                if (!vehicle.visible) {
                    resetVehicle(vehicle, v.direction, v.size);
                    return;
                }

                if (vehicle.position.distanceTo(v.lastPosition) < 0.1) {
                    v.stuckTimer++;
                } else {
                    v.stuckTimer = 0;
                    v.lastPosition.copy(vehicle.position);
                }

                if (v.stuckTimer > stuckThreshold) {
                    createExplosion(vehicle.position);
                    destroyedCount++;
                    v.stuckTimer = 0;
                    resetVehicle(vehicle, v.direction, v.size);
                    return;
                }

                let isInTunnel = false;
                for (const tunnel of tunnelAreas) { if (tunnel.containsPoint(vehicle.position)) { isInTunnel = true; break; } }
                
                const targetY = isInTunnel ? -5.0 : 1.5;
                vehicle.position.y = THREE.MathUtils.lerp(vehicle.position.y, targetY, 0.1);
                
                let effectiveSpeed = v.speed * simulationSpeed;

                // Convoy Logic
                if (isConvoyMode && v.isFollower && v.leader && v.leader.object.visible) {
                    const leaderPos = v.leader.object.position;
                    const directionToLeader = new THREE.Vector3().subVectors(leaderPos, vehicle.position);
                    const distanceToLeader = directionToLeader.length();
                    
                    if (distanceToLeader > followDistance) {
                        v.direction.lerp(directionToLeader.normalize(), 0.1);
                        vehicle.rotation.y = Math.atan2(v.direction.x, v.direction.z);
                    } else {
                        effectiveSpeed *= 0.5; // Slow down when close
                    }
                }

                const frontSensor = vehicle.position.clone().add(v.direction.clone().multiplyScalar(v.size.d / 2 + effectiveSpeed));
                
                let blockedByVehicle = false;
                for (const otherV of vehicles) {
                    if (v !== otherV && otherV.object.visible && frontSensor.distanceTo(otherV.object.position) < 8) {
                        blockedByVehicle = true;
                        break;
                    }
                }

                let blockedByBuilding = false;
                if (!isInTunnel) {
                    for (const box of buildingColliders) {
                        const isTunnelEntrance = tunnelEntranceColliders.includes(box);
                        
                        if (!isTunnelEntrance && box.containsPoint(frontSensor)) {
                            blockedByBuilding = true;
                            break;
                        }
                    }
                }

                if (!v.isFollower && (blockedByBuilding || blockedByVehicle)) {
                    turnVehicle(v, Math.random() > 0.5 ? 'left' : 'right');
                    if (blockedByVehicle && Math.random() < 0.1) collisionCount++;
                } else {
                    vehicle.position.add(v.direction.clone().multiplyScalar(effectiveSpeed));
                    const pos = vehicle.position;
                    const laneOffset = roadWidth / 4;
                    const onIntersection = (Math.abs((pos.x - laneOffset) % roadWidth) < effectiveSpeed) || (Math.abs((pos.z - laneOffset) % roadWidth) < effectiveSpeed);
                    if (!v.isFollower && onIntersection && Math.random() < 0.05 && !isInTunnel) {
                        turnVehicle(v, Math.random() > 0.5 ? 'left' : 'right');
                    }
                }

                if (Math.abs(vehicle.position.x) > halfCity || Math.abs(vehicle.position.z) > halfCity) {
                    resetVehicle(vehicle, v.direction, v.size);
                }
            });
        }

        function changeDroneFormation() {
            if (!isPaused) {
                const formations = ['random', 'circle', 'square', 'heart', 'cross'];
                setDroneFormation(formations[Math.floor(Math.random() * formations.length)]);
            }
        }

        function updateBlueDrones() {
            if (isPaused) return;
            
            const halfCity = citySize / 2;
            if (needsNewDroneTargets) {
                switch (droneFormationState) {
                    case 'circle':
                        const radius = 100;
                        blueDrones.forEach((d, i) => {
                            const angle = (i / blueDrones.length) * Math.PI * 2;
                            d.target.set(droneFormationCenter.x + radius * Math.cos(angle), droneFormationCenter.y, droneFormationCenter.z + radius * Math.sin(angle));
                        });
                        break;
                    case 'square':
                        const size = 150;
                        const perRow = 5;
                        blueDrones.forEach((d, i) => {
                            const x = (i % perRow - (perRow - 1) / 2) * (size / perRow);
                            const z = (Math.floor(i / perRow) - (Math.floor((blueDrones.length - 1) / perRow)) / 2) * (size / perRow);
                            d.target.set(droneFormationCenter.x + x, droneFormationCenter.y, droneFormationCenter.z + z);
                        });
                        break;
                    case 'heart':
                        const scale = 8;
                        blueDrones.forEach((d, i) => {
                            const t = (i / blueDrones.length) * Math.PI * 2;
                            const x = scale * 16 * Math.pow(Math.sin(t), 3);
                            const z = scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                            d.target.set(droneFormationCenter.x + x, droneFormationCenter.y, droneFormationCenter.z - z);
                        });
                        break;
                    case 'cross':
                        const spacing = 15;
                        const halfDrones = Math.floor(blueDrones.length / 2);
                        blueDrones.forEach((d, i) => {
                            if (i < halfDrones) {
                                const pos = (i - (halfDrones - 1) / 2) * spacing;
                                d.target.set(droneFormationCenter.x + pos, droneFormationCenter.y, droneFormationCenter.z);
                            } else {
                                const pos = ((i - halfDrones) - (blueDrones.length - halfDrones - 1) / 2) * spacing;
                                d.target.set(droneFormationCenter.x, droneFormationCenter.y, droneFormationCenter.z + pos);
                            }
                        });
                        break;
                    default: // random
                        blueDrones.forEach(d => {
                            d.target.set(Math.random() * citySize - halfCity, Math.random() * 150 + 300, Math.random() * citySize - halfCity);
                        });
                        break;
                }
                needsNewDroneTargets = false;
            }
            if (droneFormationState !== 'random') {
                droneFormationCenter.x += 0.05 * simulationSpeed;
            }
            blueDrones.forEach(d => {
                d.object.position.lerp(d.target, (d.speed / 100) * simulationSpeed);
                d.object.rotation.y += 0.01 * simulationSpeed;
                d.object.rotation.x += 0.005 * simulationSpeed;
            });
        }

        function updateRedDrones() {
            if (isPaused) return;
            const halfCity = citySize / 2;
            redDrones.forEach(d => {
                d.object.position.lerp(d.target, (d.speed / 100) * simulationSpeed);
                d.object.rotation.y -= 0.015 * simulationSpeed;
                d.object.rotation.z += 0.008 * simulationSpeed;

                if (d.object.position.distanceTo(d.target) < 20) {
                    d.target.set(Math.random() * citySize - halfCity, Math.random() * 100 + 250, Math.random() * citySize - halfCity);
                }

                d.explosionTimer -= simulationSpeed;
                if (d.explosionTimer <= 0) {
                    createExplosion(d.object.position);
                    destroyedCount++;
                    d.object.position.set(
                        Math.random() * citySize - halfCity,
                        Math.random() * 100 + 250,
                        Math.random() * citySize - halfCity
                    );
                    d.target.set(
                        Math.random() * citySize - halfCity,
                        Math.random() * 100 + 250,
                        Math.random() * citySize - halfCity
                    );
                    d.explosionTimer = Math.random() * 1000 + 500;
                }
            });
        }

        function createExplosion(position) {
            const particleCount = 50;
            const activeParticles = [];
            let particlesAdded = 0;

            for (let i = 0; i < particlePool.length && particlesAdded < particleCount; i++) {
                const particle = particlePool[i];
                if (!particle.visible) {
                    particle.visible = true;
                    particle.material.opacity = 1.0;
                    particle.position.copy(position);
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2
                    );
                    velocity.normalize().multiplyScalar(Math.random() * 2 + 1);
                    
                    activeParticles.push({ mesh: particle, velocity: velocity });
                    particlesAdded++;
                }
            }

            if (activeParticles.length > 0) {
                explosions.push({ particles: activeParticles, life: 60 });
            }
        }

        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                explosion.life--;

                if (explosion.life <= 0) {
                    explosion.particles.forEach(p => {
                        p.mesh.visible = false;
                    });
                    explosions.splice(i, 1);
                } else {
                    explosion.particles.forEach(p => {
                        p.mesh.position.add(p.velocity);
                        p.velocity.multiplyScalar(0.95);
                        p.mesh.material.opacity = explosion.life / 60;
                    });
                }
            }
        }

        function updateScrollingAds() {
            scrollingAds.forEach(ad => {
                const { context, text, canvas, texture, textWidth } = ad;

                context.fillStyle = '#1a001a';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.fillStyle = '#ff44ff';
                context.shadowColor = '#ff00ff';
                context.shadowBlur = 20;
                context.textAlign = 'left';
                context.textBaseline = 'middle';
                context.fillText(text, ad.x, canvas.height / 2);
                
                ad.x -= 2 * simulationSpeed;
                if (ad.x < -textWidth) {
                    ad.x = canvas.width;
                }
                
                texture.needsUpdate = true;
            });
        }

        function updateZeppelin() {
            if (zeppelin && zeppelin.visible) {
                const time = simulationTime * 0.02 * simulationSpeed;
                zeppelin.position.x = Math.cos(time) * 450;
                zeppelin.position.z = Math.sin(time) * 450;
                zeppelin.lookAt(0, zeppelin.position.y, 0);
                
                const origin = new THREE.Vector3();
                zeppelinLaser.getWorldPosition(origin);

                const direction = new THREE.Vector3(0, -1, 0);
                direction.applyQuaternion(zeppelinLaser.getWorldQuaternion(new THREE.Quaternion()));

                raycaster.set(origin, direction);
                const intersects = raycaster.intersectObjects(scene.children, true);

                if (intersects.length > 0) {
                    const distance = intersects[0].distance;
                    zeppelinLaser.scale.y = distance;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            frameCount++;
            const now = performance.now();
            if (now - lastFPSUpdate > 1000) {
                const fps = Math.round(frameCount / ((now - lastFPSUpdate) / 1000));
                document.getElementById('fps-counter').textContent = fps;
                document.getElementById('fps-bar').style.width = Math.min(fps / 60 * 100, 100) + '%';
                frameCount = 0;
                lastFPSUpdate = now;
            }
            
            controls.update();
            if (!isPaused) {
                updateVehicles();
                updateBlueDrones();
                updateRedDrones();
                updateExplosions();
                updateScrollingAds();
                updateZeppelin();
            }
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        const translations = {
            en: {
                back: "[<-] Back", controlsBtn: "[+] Controls", statsBtn: "[+] Stats", infoBtn: "[+] Info", perfBtn: "[+] Perf",
                simControls: "Simulation Controls", pause: "⏸ Pause", play: "▶️ Play", reset: "🔄 Reset", view: "📷 View", solid: "🏢 Solid", wireframe: "🌐 Wireframe", infrared: "♨️ Infrared", convoy: "🚗 Convoy", solo: "🚗 Solo", zeppelin: "🛸 Zeppelin",
                droneFormation: "Drone Formation", random: "Random", circle: "Circle", square: "Square", heart: "Heart", cross: "Cross",
                simSpeed: "Simulation Speed", trafficDensity: "Traffic Density", language: "Language",
                statsTitle: "REAL-TIME STATS", activeVehicles: "Active Vehicles:", blueDrones: "Blue Drones:", redDrones: "Red Drones:", formation: "Formation:", simTime: "Sim Time:", collisionsAvoided: "Collisions Avoided:", vehiclesDestroyed: "Destroyed:",
                infoTitle: "NAVIGATION & CONTROLS", orbit: "• Left-click + drag: Orbit camera", pan: "• Right-click + drag: Pan camera", zoom: "• Scroll/Pinch: Zoom in/out",
                trafficAI: "• Autonomous traffic AI with avoidance", droneSwarms: "• Dynamic drone swarms", tunnelSystem: "• Urban tunnel system", postProcessing: "• Post-processing with bloom effects",
                perfTitle: "PERFORMANCE"
            },
            fr: {
                back: "[<-] Retour", controlsBtn: "[+] Contrôles", statsBtn: "[+] Stats", infoBtn: "[+] Infos", perfBtn: "[+] Perf",
                simControls: "Contrôles de Simulation", pause: "⏸ Pause", play: "▶️ Play", reset: "🔄 Reset", view: "📷 Vue", solid: "🏢 Solide", wireframe: "🌐 Fil de fer", infrared: "♨️ Infra", convoy: "🚗 Convoi", solo: "🚗 Solo", zeppelin: "🛸 Zeppelin",
                droneFormation: "Formation des Drones", random: "Aléatoire", circle: "Cercle", square: "Carré", heart: "Coeur", cross: "Croix",
                simSpeed: "Vitesse de Simulation", trafficDensity: "Densité du Trafic", language: "Langue",
                statsTitle: "STATISTIQUES TEMPS RÉEL", activeVehicles: "Véhicules Actifs:", blueDrones: "Drones Bleus:", redDrones: "Drones Rouges:", formation: "Formation:", simTime: "Temps Simulation:", collisionsAvoided: "Collisions Évitées:", vehiclesDestroyed: "Détruits:",
                infoTitle: "NAVIGATION & CONTRÔLES", orbit: "• Clic gauche + glisser : Rotation orbite", pan: "• Clic droit + glisser : Déplacement panoramique", zoom: "• Molette/Pincement : Zoom avant/arrière",
                trafficAI: "• IA de trafic autonome avec évitement", droneSwarms: "• Formations dynamiques de drones", tunnelSystem: "• Système de tunnels urbains", postProcessing: "• Rendu post-processing avec effets bloom",
                perfTitle: "PERFORMANCE"
            },
            de: {
                back: "[<-] Zurück", controlsBtn: "[+] Steuerung", statsBtn: "[+] Stats", infoBtn: "[+] Infos", perfBtn: "[+] Perf",
                simControls: "Simulationssteuerung", pause: "⏸ Pause", play: "▶️ Start", reset: "🔄 Reset", view: "📷 Ansicht", solid: "🏢 Solide", wireframe: "🌐 Drahtgitter", infrared: "♨️ Infrarot", convoy: "🚗 Konvoi", solo: "🚗 Solo", zeppelin: "🛸 Zeppelin",
                droneFormation: "Drohnenformation", random: "Zufällig", circle: "Kreis", square: "Quadrat", heart: "Herz", cross: "Kreuz",
                simSpeed: "Simulationsgeschwindigkeit", trafficDensity: "Verkehrsdichte", language: "Sprache",
                statsTitle: "ECHTZEIT-STATISTIKEN", activeVehicles: "Aktive Fahrzeuge:", blueDrones: "Blaue Drohnen:", redDrones: "Rote Drohnen:", formation: "Formation:", simTime: "Sim-Zeit:", collisionsAvoided: "Vermiedene Kollisionen:", vehiclesDestroyed: "Zerstört:",
                infoTitle: "NAVIGATION & STEUERUNG", orbit: "• Linksklick + ziehen: Kamera drehen", pan: "• Rechtsklick + ziehen: Kamera schwenken", zoom: "• Scrollen/Pinchen: Zoomen",
                trafficAI: "• Autonome Verkehrs-KI mit Kollisionsvermeidung", droneSwarms: "• Dynamische Drohnenschwärme", tunnelSystem: "• Städtisches Tunnelsystem", postProcessing: "• Nachbearbeitung mit Bloom-Effekten",
                perfTitle: "LEISTUNG"
            },
            es: {
                back: "[<-] Volver", controlsBtn: "[+] Controles", statsBtn: "[+] Stats", infoBtn: "[+] Info", perfBtn: "[+] Perf",
                simControls: "Controles de Simulación", pause: "⏸ Pausa", play: "▶️ Play", reset: "🔄 Reiniciar", view: "📷 Vista", solid: "🏢 Sólido", wireframe: "🌐 Malla", infrared: "♨️ Infrarrojo", convoy: "🚗 Convoy", solo: "🚗 Solo", zeppelin: "🛸 Zepelín",
                droneFormation: "Formación de Drones", random: "Aleatorio", circle: "Círculo", square: "Cuadrado", heart: "Corazón", cross: "Cruz",
                simSpeed: "Velocidad de Simulación", trafficDensity: "Densidad de Tráfico", language: "Idioma",
                statsTitle: "ESTADÍSTICAS EN TIEMPO REAL", activeVehicles: "Vehículos Activos:", blueDrones: "Drones Azules:", redDrones: "Drones Rojos:", formation: "Formación:", simTime: "Tiempo Sim:", collisionsAvoided: "Colisiones Evitadas:", vehiclesDestroyed: "Destruidos:",
                infoTitle: "NAVEGACIÓN Y CONTROLES", orbit: "• Clic izquierdo + arrastrar: Orbitar cámara", pan: "• Clic derecho + arrastrar: Mover cámara", zoom: "• Rueda/Pellizcar: Zoom",
                trafficAI: "• IA de tráfico autónomo con evasión", droneSwarms: "• Enjambres de drones dinámicos", tunnelSystem: "• Sistema de túneles urbanos", postProcessing: "• Post-procesado con efectos de bloom",
                perfTitle: "RENDIMIENTO"
            },
            zh: {
                back: "[<-] 返回", controlsBtn: "[+] 控制", statsBtn: "[+] 统计", infoBtn: "[+] 信息", perfBtn: "[+] 性能",
                simControls: "模拟控制", pause: "⏸ 暂停", play: "▶️ 播放", reset: "🔄 重置", view: "📷 视角", solid: "🏢 实体", wireframe: "🌐 线框", infrared: "♨️ 红外线", convoy: "🚗 车队", solo: "🚗 单独", zeppelin: "🛸 飞艇",
                droneFormation: "无人机编队", random: "随机", circle: "圆形", square: "方形", heart: "心形", cross: "十字形",
                simSpeed: "模拟速度", trafficDensity: "交通密度", language: "语言",
                statsTitle: "实时统计", activeVehicles: "活动车辆:", blueDrones: "蓝色无人机:", redDrones: "红色无人机:", formation: "编队:", simTime: "模拟时间:", collisionsAvoided: "避免碰撞:", vehiclesDestroyed: "已摧毁:",
                infoTitle: "导航与控制", orbit: "• 左键+拖动：轨道相机", pan: "• 右键+拖动：平移相机", zoom: "• 滚轮/双指缩放：缩放",
                trafficAI: "• 具有规避功能的自主交通AI", droneSwarms: "• 动态无人机群", tunnelSystem: "• 城市隧道系统", postProcessing: "• 带辉光效果的后期处理",
                perfTitle: "性能"
            }
        };

        function updateLanguage() {
            const lang = document.documentElement.lang;
            const langData = translations[lang] || translations.fr;

            document.querySelectorAll('[data-lang-key]').forEach(el => {
                const key = el.dataset.langKey;
                if (langData[key]) {
                    el.textContent = langData[key];
                }
            });

            // Special cases
            const pauseBtn = document.getElementById('pause-btn');
            if (isPaused) {
                pauseBtn.textContent = langData.play;
            } else {
                pauseBtn.textContent = langData.pause;
            }

            const renderBtn = document.getElementById('render-mode-btn');
            renderBtn.textContent = isSolidMode ? langData.wireframe : langData.solid;
            
            const convoyBtn = document.getElementById('convoy-mode-btn');
            convoyBtn.textContent = isConvoyMode ? langData.solo : langData.convoy;

            document.getElementById('formation-status').textContent = langData[droneFormationState] || droneFormationState;
        }

        init();
    </script>
</body>
</html>
